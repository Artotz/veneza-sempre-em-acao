Directory structure:
└── artotz-lead-middleware/
    ├── README.md
    ├── eslint.config.mjs
    ├── middleware.ts
    ├── next.config.ts
    ├── package.json
    ├── postcss.config.mjs
    ├── tsconfig.json
    ├── .tmp-openapi.json
    ├── scripts/
    │   └── seedEvents.mjs
    └── src/
        ├── app/
        │   ├── dashboard-client.tsx
        │   ├── globals.css
        │   ├── layout.tsx
        │   ├── not-found.tsx
        │   ├── page.tsx
        │   ├── api/
        │   │   ├── events/
        │   │   │   ├── lead/
        │   │   │   │   └── route.ts
        │   │   │   └── ticket/
        │   │   │       └── route.ts
        │   │   ├── lead-service-orders/
        │   │   │   ├── route.ts
        │   │   │   └── [id]/
        │   │   │       └── route.ts
        │   │   ├── leads/
        │   │   │   ├── route.ts
        │   │   │   ├── [leadId]/
        │   │   │   │   ├── route.ts
        │   │   │   │   └── events/
        │   │   │   │       └── route.ts
        │   │   │   └── import/
        │   │   │       └── route.ts
        │   │   ├── metrics/
        │   │   │   ├── leads/
        │   │   │   │   └── route.ts
        │   │   │   └── tickets/
        │   │   │       └── route.ts
        │   │   └── tickets/
        │   │       ├── route.ts
        │   │       ├── [ticketId]/
        │   │       │   └── route.ts
        │   │       └── options/
        │   │           └── route.ts
        │   ├── auth/
        │   │   └── logout/
        │   │       └── route.ts
        │   ├── cronograma/
        │   │   ├── cronograma-client.tsx
        │   │   └── page.tsx
        │   ├── home/
        │   │   ├── home-client.tsx
        │   │   └── page.tsx
        │   ├── leads/
        │   │   └── import/
        │   │       ├── leads-import-client.tsx
        │   │       └── page.tsx
        │   ├── login/
        │   │   ├── login-client.tsx
        │   │   └── page.tsx
        │   └── metrics/
        │       ├── metrics-client.tsx
        │       └── page.tsx
        ├── components/
        │   ├── ActionButtonCell.tsx
        │   ├── ActionModal.tsx
        │   ├── AssignLeadButton.tsx
        │   ├── Badge.tsx
        │   ├── CreateLeadModal.tsx
        │   ├── FiltersBar.tsx
        │   ├── LeadDetailsAside.tsx
        │   ├── LeadServiceOrdersList.tsx
        │   ├── LeadsFiltersPanel.tsx
        │   ├── LeadsKanban.tsx
        │   ├── LeadsList.tsx
        │   ├── LeadsMapView.tsx
        │   ├── LeadsMetricsView.tsx
        │   ├── LeadStatusMetricsView.tsx
        │   ├── LeadTypesMultiSelect.tsx
        │   ├── MetricCard.tsx
        │   ├── MetricsTabs.tsx
        │   ├── PageShell.tsx
        │   ├── RequireAuth.tsx
        │   ├── Tabs.tsx
        │   ├── TicketDetailsAside.tsx
        │   ├── TicketsList.tsx
        │   ├── TicketsMetricsView.tsx
        │   ├── TimeRangeSelector.tsx
        │   ├── ToastProvider.tsx
        │   ├── UserActionMetricsView.tsx
        │   └── ticket-details/
        │       ├── CollapsibleSection.tsx
        │       ├── KeyValueGrid.tsx
        │       ├── TicketAdvisorCard.tsx
        │       ├── TicketContactCard.tsx
        │       ├── TicketCustomFields.tsx
        │       ├── TicketDescription.tsx
        │       ├── TicketHeader.tsx
        │       ├── TicketMachineList.tsx
        │       ├── TicketMetaInfo.tsx
        │       ├── TicketTags.tsx
        │       └── TicketWatchers.tsx
        ├── contexts/
        │   └── AuthContext.tsx
        ├── hooks/
        │   └── useCreateEvent.ts
        ├── lib/
        │   ├── api.ts
        │   ├── currentUser.ts
        │   ├── domain.ts
        │   ├── events.ts
        │   ├── expertconnect.ts
        │   ├── filters.ts
        │   ├── filterStorage.ts
        │   ├── format.ts
        │   ├── leadData.ts
        │   ├── metrics.ts
        │   ├── metricsAggregation.ts
        │   ├── mockData.ts
        │   ├── supabaseAdmin.ts
        │   ├── supabaseClient.ts
        │   ├── supabaseServer.ts
        │   ├── supabaseUserClient.ts
        │   ├── ticketDetails.ts
        │   ├── ticketDetailsViewModel.ts
        │   ├── ticketFilters.ts
        │   └── supabase/
        │       ├── client.ts
        │       └── server.ts
        └── types/
            └── leaflet-extensions.d.ts

================================================
FILE: README.md
================================================
This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.



================================================
FILE: eslint.config.mjs
================================================
import { defineConfig, globalIgnores } from "eslint/config";
import nextVitals from "eslint-config-next/core-web-vitals";
import nextTs from "eslint-config-next/typescript";

const eslintConfig = defineConfig([
  ...nextVitals,
  ...nextTs,
  // Override default ignores of eslint-config-next.
  globalIgnores([
    // Default ignores of eslint-config-next:
    ".next/**",
    "out/**",
    "build/**",
    "next-env.d.ts",
  ]),
]);

export default eslintConfig;



================================================
FILE: middleware.ts
================================================
import { createServerClient } from "@supabase/ssr";
import { NextResponse, type NextRequest } from "next/server";

const isUuid = (value: string) =>
  /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(
    value.trim(),
  );

export async function middleware(request: NextRequest) {
  const response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
  const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;

  if (!supabaseUrl || !supabaseAnonKey) {
    return response;
  }

  const supabase = createServerClient(supabaseUrl, supabaseAnonKey, {
    cookies: {
      get(name) {
        return request.cookies.get(name)?.value;
      },
      set(name, value, options) {
        response.cookies.set({
          name,
          value,
          ...options,
        });
      },
      remove(name, options) {
        response.cookies.set({
          name,
          value: "",
          ...options,
          maxAge: 0,
        });
      },
    },
  });

  const {
    data: { session },
  } = await supabase.auth.getSession();

  const { pathname } = request.nextUrl;
  const isLoginRoute = pathname.startsWith("/login");
  const isProtectedRoute =
    pathname === "/" ||
    pathname.startsWith("/metrics") ||
    pathname.startsWith("/home") ||
    pathname.startsWith("/leads");

  if (!session && isProtectedRoute) {
    const mockUserId = process.env.MOCK_USER_ID?.trim();
    if (mockUserId && isUuid(mockUserId)) {
      return response;
    }
    const redirectUrl = new URL("/login", request.url);
    redirectUrl.searchParams.set("message", "Faça login para acessar o painel.");
    return NextResponse.redirect(redirectUrl, {
      headers: response.headers,
    });
  }

  if (session && isLoginRoute) {
    const redirectUrl = new URL("/", request.url);
    return NextResponse.redirect(redirectUrl, {
      headers: response.headers,
    });
  }

  return response;
}

export const config = {
  matcher: ["/", "/metrics/:path*", "/home", "/leads/:path*", "/login"],
};



================================================
FILE: next.config.ts
================================================
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;



================================================
FILE: package.json
================================================
{
  "name": "lead-middleware",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "eslint"
  },
  "dependencies": {
    "@supabase/ssr": "^0.8.0",
    "@supabase/supabase-js": "^2.87.1",
    "leaflet": "^1.9.4",
    "leaflet-routing-machine": "^3.2.12",
    "leaflet.markercluster": "^1.5.3",
    "next": "^16.1.1",
    "react": "19.2.0",
    "react-dom": "19.2.0",
    "recharts": "^3.6.0"
  },
  "devDependencies": {
    "@tailwindcss/postcss": "^4",
    "@types/leaflet": "^1.9.21",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "eslint": "^9",
    "eslint-config-next": "16.0.7",
    "tailwindcss": "^4",
    "typescript": "^5"
  }
}



================================================
FILE: postcss.config.mjs
================================================
const config = {
  plugins: {
    "@tailwindcss/postcss": {},
  },
};

export default config;



================================================
FILE: tsconfig.json
================================================
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "react-jsx",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts",
    ".next/dev/types/**/*.ts",
    "**/*.mts"
  ],
  "exclude": ["node_modules"]
}



================================================
FILE: .tmp-openapi.json
================================================
﻿


================================================
FILE: scripts/seedEvents.mjs
================================================
import fs from "node:fs";
import path from "node:path";
import crypto from "node:crypto";
import { fileURLToPath } from "node:url";
import { createClient } from "@supabase/supabase-js";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const repoRoot = path.resolve(__dirname, "..");

function loadDotEnvLocal() {
  const envPath = path.join(repoRoot, ".env.local");
  if (!fs.existsSync(envPath)) return;

  const content = fs.readFileSync(envPath, "utf8");
  content.split(/\r?\n/).forEach((line) => {
    const trimmed = line.trim();
    if (!trimmed || trimmed.startsWith("#")) return;
    const eq = trimmed.indexOf("=");
    if (eq === -1) return;
    const key = trimmed.slice(0, eq).trim();
    let val = trimmed.slice(eq + 1).trim();
    if (
      (val.startsWith("\"") && val.endsWith("\"")) ||
      (val.startsWith("'") && val.endsWith("'"))
    ) {
      val = val.slice(1, -1);
    }
    if (!process.env[key]) {
      process.env[key] = val;
    }
  });
}

loadDotEnvLocal();

const supabaseUrl =
  process.env.NEXT_PUBLIC_SUPABASE_URL || process.env.SUPABASE_URL;
const serviceRoleKey = process.env.SUPABASE_SERVICE_ROLE_KEY;

if (!supabaseUrl || !serviceRoleKey) {
  console.error(
    "Env obrigatǭrias: NEXT_PUBLIC_SUPABASE_URL (ou SUPABASE_URL) e SUPABASE_SERVICE_ROLE_KEY",
  );
  process.exit(1);
}

const supabase = createClient(supabaseUrl, serviceRoleKey, {
  auth: { persistSession: false, autoRefreshToken: false, detectSessionInUrl: false },
});

const parseCsv = (value) =>
  String(value ?? "")
    .split(",")
    .map((v) => v.trim())
    .filter(Boolean);

const seedLeadIdsFromEnv = () =>
  parseCsv(process.env.SEED_LEAD_IDS).map((v) => Number(v)).filter((n) => Number.isFinite(n));

const seedTicketIdsFromEnv = () => parseCsv(process.env.SEED_TICKET_IDS);

const randomFrom = (arr) => arr[Math.floor(Math.random() * arr.length)];

const randomOccurredAt = () => {
  const now = Date.now();
  const days = Math.floor(Math.random() * 25); // last ~25 days
  const minutes = Math.floor(Math.random() * 24 * 60);
  return new Date(now - days * 24 * 60 * 60 * 1000 - minutes * 60 * 1000).toISOString();
};

async function fetchLeadIds(limit = 10) {
  const { data, error } = await supabase
    .from("leads")
    .select("id")
    .order("id", { ascending: true })
    .limit(limit);
  if (error) throw error;
  return (data ?? []).map((row) => row.id).filter(Boolean);
}

async function fetchTicketIds(limit = 10) {
  const { data, error } = await supabase
    .from("tickets")
    .select("ticket_id")
    .not("ticket_id", "is", null)
    .order("ticket_id", { ascending: true })
    .limit(limit);
  if (error) throw error;
  return (data ?? []).map((row) => row.ticket_id).filter(Boolean);
}

async function tryCreateLeadsIfMissing(targetCount) {
  const rows = Array.from({ length: targetCount }).map((_, i) => ({
    regional: randomFrom(["Norte", "Nordeste", "Centro-Oeste", "Sudeste", "Sul"]),
    estado: "SP",
    city: "Sǜo Paulo",
    chassi: `SEED-CHASSI-${Date.now()}-${i}`,
    model_name: "Modelo Seed",
    cliente_base_enriquecida: "Cliente Seed",
    horimetro_atual_machine_list: 1234,
    last_called_group: "seed",
    lead_preventiva: "SIM",
    lead_garantia_basica: null,
    lead_garantia_estendida: null,
    lead_reforma_de_componentes: null,
    lead_lamina: null,
    lead_dentes: null,
    lead_rodante: null,
    lead_disponibilidade: null,
    lead_reconexao: null,
    lead_transferencia_de_aor: null,
    status: "novo",
    imported_at: new Date().toISOString(),
  }));

  const { data, error } = await supabase.from("leads").insert(rows).select("id");
  if (error) {
    console.warn("Nǜo foi possǭvel criar leads seed automaticamente:", error.message);
    return [];
  }
  return (data ?? []).map((row) => row.id).filter(Boolean);
}

async function tryCreateTicketsIfMissing(targetCount) {
  const rows = Array.from({ length: targetCount }).map((_, i) => ({
    ticket_id: crypto.randomUUID(),
    number: `SEED-${Date.now()}-${i}`,
    title: "Ticket Seed",
    status: 1,
    serial_number: `SN-${Date.now()}-${i}`,
    updated_date: new Date().toISOString(),
    created_date: new Date().toISOString(),
    url: null,
  }));

  const { data, error } = await supabase
    .from("tickets")
    .insert(rows)
    .select("ticket_id");
  if (error) {
    console.warn("Nǜo foi possǭvel criar tickets seed automaticamente:", error.message);
    return [];
  }
  return (data ?? []).map((row) => row.ticket_id).filter(Boolean);
}

const users = [
  { id: crypto.randomUUID(), email: "ana.seed@example.com", name: "Ana Seed" },
  { id: crypto.randomUUID(), email: "bruno.seed@example.com", name: "Bruno Seed" },
  { id: crypto.randomUUID(), email: "carla.seed@example.com", name: "Carla Seed" },
];

async function main() {
  let leadIds = seedLeadIdsFromEnv();
  let ticketIds = seedTicketIdsFromEnv();

  if (leadIds.length === 0) {
    leadIds = await fetchLeadIds(10);
  }
  if (ticketIds.length === 0) {
    ticketIds = await fetchTicketIds(10);
  }

  if (leadIds.length < 10 && seedLeadIdsFromEnv().length === 0) {
    const created = await tryCreateLeadsIfMissing(10 - leadIds.length);
    leadIds = leadIds.concat(created).slice(0, 10);
  }

  if (ticketIds.length < 10 && seedTicketIdsFromEnv().length === 0) {
    const created = await tryCreateTicketsIfMissing(10 - ticketIds.length);
    ticketIds = ticketIds.concat(created).slice(0, 10);
  }

  if (leadIds.length === 0 || ticketIds.length === 0) {
    console.error(
      "Nǜo encontrei leads/tickets suficientes. Use SEED_LEAD_IDS e SEED_TICKET_IDS para informar IDs existentes.",
    );
    process.exit(1);
  }

  const leadActions = [
    "register_contact",
    "convert_to_ticket",
    "discard",
  ];
  const ticketActions = [
    "view",
    "add_note",
    "add_tags",
    "remove_tags",
    "assign",
    "close",
    "reopen",
    "external_update_detected",
  ];

  const leadEvents = [];
  for (const leadId of leadIds.slice(0, 10)) {
    for (let i = 0; i < 2; i += 1) {
      const user = randomFrom(users);
      const action = randomFrom(leadActions);
      const payload = {};
      if (action === "register_contact") {
        payload.note = "Contato realizado (seed)";
      }
      if (action === "discard") payload.reason = "Lead fora do perfil (seed)";
      if (action === "convert_to_ticket") payload.method = "manual";
      leadEvents.push({
        lead_id: leadId,
        actor_user_id: user.id,
        actor_email: user.email,
        actor_name: user.name,
        action,
        source: "seed",
        occurred_at: randomOccurredAt(),
        payload,
      });
    }
  }

  const ticketEvents = [];
  for (const ticketId of ticketIds.slice(0, 10)) {
    for (let i = 0; i < 2; i += 1) {
      const user = randomFrom(users);
      const action = randomFrom(ticketActions);
      const payload = {};
      if (action === "add_note") payload.note = "Atualizaǧǜo interna (seed)";
      if (action === "add_tags") payload.tags = ["seed", "vip"];
      if (action === "remove_tags") payload.tags = ["old"];
      if (action === "assign") payload.assignee = "owner.seed@example.com";
      ticketEvents.push({
        ticket_id: ticketId,
        actor_user_id: user.id,
        actor_email: user.email,
        actor_name: user.name,
        action,
        source: "seed",
        occurred_at: randomOccurredAt(),
        payload,
      });
    }
  }

  const { error: leadErr } = await supabase.from("lead_events").insert(leadEvents);
  if (leadErr) throw leadErr;

  const { error: ticketErr } = await supabase.from("ticket_events").insert(ticketEvents);
  if (ticketErr) throw ticketErr;

  console.log("Seed concluǭdo.");
  console.log(`- lead_events: ${leadEvents.length} eventos (${leadIds.length} leads)`);
  console.log(`- ticket_events: ${ticketEvents.length} eventos (${ticketIds.length} tickets)`);
  console.log("- Usuǭrios seed:");
  users.forEach((u) => console.log(`  - ${u.name} <${u.email}> (${u.id})`));
}

main().catch((err) => {
  console.error("Seed falhou:", err?.message ?? err);
  process.exit(1);
});



================================================
FILE: src/app/dashboard-client.tsx
================================================
"use client";

import { useCallback, useEffect, useMemo, useRef, useState } from "react";
import { LeadServiceOrdersList } from "@/components/LeadServiceOrdersList";
import { LeadsList } from "@/components/LeadsList";
import { LeadsFiltersPanel } from "@/components/LeadsFiltersPanel";
import { LeadsMapView } from "@/components/LeadsMapView";
import { PageShell } from "@/components/PageShell";
import { Tabs } from "@/components/Tabs";
import { TicketsList } from "@/components/TicketsList";
import { TicketDetailsAside } from "@/components/TicketDetailsAside";
import { LeadDetailsAside } from "@/components/LeadDetailsAside";
import { getUserDisplayName, useAuth } from "@/contexts/AuthContext";
import {
  fetchLeadServiceOrders,
  fetchLeads,
  fetchTicketOptions,
  fetchTickets,
} from "@/lib/api";
import { Lead, LeadServiceOrder, Ticket } from "@/lib/domain";
import { FiltersState, INITIAL_FILTERS } from "@/lib/filters";
import {
  INITIAL_TICKET_FILTERS,
  TicketFiltersState,
} from "@/lib/ticketFilters";
import {
  FILTER_STORAGE_KEYS,
  loadLeadFilters,
  loadTicketFilters,
  saveFilters,
} from "@/lib/filterStorage";

type DashboardTab = "leads" | "tickets" | "os";
type LeadsViewMode = "list" | "map";

type DashboardInitialFilters = {
  leadFilters: FiltersState;
  serviceOrderFilters: FiltersState;
  ticketFilters: TicketFiltersState;
};

const INITIAL_SERVICE_ORDER_FILTERS: FiltersState = {
  ...INITIAL_FILTERS,
  status: [],
};

export default function DashboardClient() {
  const { user } = useAuth();
  const currentUserName = useMemo(() => getUserDisplayName(user), [user]);
  const [activeTab, setActiveTab] = useState<DashboardTab>("leads");
  const [filtersReady, setFiltersReady] = useState(false);
  const leadFiltersHydrated = useRef(false);
  const serviceOrderFiltersHydrated = useRef(false);
  const ticketFiltersHydrated = useRef(false);

  // Leads
  const [leads, setLeads] = useState<Lead[]>([]);
  const [leadsTotal, setLeadsTotal] = useState<number>(0);
  const [leadsPage, setLeadsPage] = useState<number>(1);
  const [leadsPageSize] = useState<number>(10);
  const [leadsLoading, setLeadsLoading] = useState<boolean>(false);
  const [leadFilters, setLeadFilters] =
    useState<FiltersState>(INITIAL_FILTERS);
  const [leadsView, setLeadsView] = useState<LeadsViewMode>("list");
  const [mapLeads, setMapLeads] = useState<Lead[]>([]);
  const [mapLeadsLoading, setMapLeadsLoading] = useState<boolean>(false);
  const [mapLeadsError, setMapLeadsError] = useState<string | null>(null);
  const [selectedLead, setSelectedLead] = useState<Lead | null>(null);
  const [leadDetailsOpen, setLeadDetailsOpen] = useState<boolean>(false);

  // Service orders
  const [serviceOrders, setServiceOrders] = useState<LeadServiceOrder[]>([]);
  const [serviceOrdersTotal, setServiceOrdersTotal] = useState<number>(0);
  const [serviceOrdersPage, setServiceOrdersPage] = useState<number>(1);
  const [serviceOrdersPageSize] = useState<number>(10);
  const [serviceOrdersLoading, setServiceOrdersLoading] =
    useState<boolean>(false);
  const [serviceOrderFilters, setServiceOrderFilters] = useState<FiltersState>(
    INITIAL_SERVICE_ORDER_FILTERS,
  );

  // Tickets
  const [tickets, setTickets] = useState<Ticket[]>([]);
  const [ticketsTotal, setTicketsTotal] = useState<number>(0);
  const [ticketsPage, setTicketsPage] = useState<number>(1);
  const [ticketsPageSize] = useState<number>(10);
  const [ticketsLoading, setTicketsLoading] = useState<boolean>(false);
  const [ticketFilters, setTicketFilters] = useState<TicketFiltersState>(
    INITIAL_TICKET_FILTERS,
  );
  const [ticketOptions, setTicketOptions] = useState<{
    consultores: string[];
    clientes: string[];
    equipes: string[];
  } | null>(null);
  const [selectedTicketId, setSelectedTicketId] = useState<string | null>(null);
  const [ticketDetailsOpen, setTicketDetailsOpen] = useState<boolean>(false);

  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);

  const loadLeads = useCallback(
    async (page: number, filters: FiltersState) => {
      setLeadsLoading(true);
      setError(null);
      try {
        const resp = await fetchLeads({
          page,
          pageSize: leadsPageSize,
          ...filters,
        });
        setLeads(resp.items);
        setLeadsTotal(resp.total);
        setLeadsPage(resp.page);
      } catch (err) {
        console.error(err);
        setError("NÇœo foi possÇðvel carregar os leads do Supabase.");
      } finally {
        setLeadsLoading(false);
      }
    },
    [leadsPageSize],
  );

  const loadAllLeads = useCallback(async (filters: FiltersState) => {
    setMapLeadsLoading(true);
    setMapLeadsError(null);
    try {
      const pageSize = 100;
      const first = await fetchLeads({ page: 1, pageSize, ...filters });
      const totalPages = Math.max(
        1,
        Math.ceil(first.total / pageSize),
      );
      const allItems = [...first.items];

      if (totalPages > 1) {
        const requests = Array.from(
          { length: totalPages - 1 },
          (_, index) =>
            fetchLeads({
              page: index + 2,
              pageSize,
              ...filters,
            }),
        );
        const responses = await Promise.all(requests);
        responses.forEach((resp) => {
          allItems.push(...resp.items);
        });
      }

      setMapLeads(allItems);
    } catch (err) {
      console.error(err);
      setMapLeadsError("Nao foi possivel carregar o mapa de leads.");
    } finally {
      setMapLeadsLoading(false);
    }
  }, []);

  const loadServiceOrders = useCallback(
    async (page: number, filters: FiltersState) => {
      setServiceOrdersLoading(true);
      setError(null);
      try {
        const resp = await fetchLeadServiceOrders({
          page,
          pageSize: serviceOrdersPageSize,
          ...filters,
        });
        setServiceOrders(resp.items);
        setServiceOrdersTotal(resp.total);
        setServiceOrdersPage(resp.page);
      } catch (err) {
        console.error(err);
        setError("Nao foi possivel carregar as OS do Supabase.");
      } finally {
        setServiceOrdersLoading(false);
      }
    },
    [serviceOrdersPageSize],
  );

  const loadTickets = useCallback(
    async (page: number, filters: TicketFiltersState) => {
      setTicketsLoading(true);
      setError(null);
      try {
        const resp = await fetchTickets({
          page,
          pageSize: ticketsPageSize,
          ...filters,
        });
        setTickets(resp.items);
        setTicketsTotal(resp.total);
        setTicketsPage(resp.page);
        if (resp.options) {
          setTicketOptions(resp.options);
        }
      } catch (err) {
        console.error(err);
        setError("NÇœo foi possÇðvel carregar os tickets do Supabase.");
      } finally {
        setTicketsLoading(false);
      }
    },
    [ticketsPageSize],
  );

  const loadInitial = useCallback(
    async (
      initialFilters: DashboardInitialFilters = {
        leadFilters: INITIAL_FILTERS,
        serviceOrderFilters: INITIAL_SERVICE_ORDER_FILTERS,
        ticketFilters: INITIAL_TICKET_FILTERS,
      },
    ) => {
      const { leadFilters, serviceOrderFilters, ticketFilters } =
        initialFilters;
    setLoading(true);
    setError(null);
    setLeadsLoading(true);
    setServiceOrdersLoading(true);
    setTicketsLoading(true);
    try {
      const [leadsResp, serviceOrdersResp, ticketsResp, optionsResp] =
        await Promise.all([
          fetchLeads({ page: 1, pageSize: leadsPageSize, ...leadFilters }),
          fetchLeadServiceOrders({
            page: 1,
            pageSize: serviceOrdersPageSize,
            ...serviceOrderFilters,
          }),
          fetchTickets({
            page: 1,
            pageSize: ticketsPageSize,
            ...ticketFilters,
          }),
          fetchTicketOptions(),
        ]);
      setLeads(leadsResp.items);
      setLeadsTotal(leadsResp.total);
      setLeadsPage(leadsResp.page);

      setServiceOrders(serviceOrdersResp.items);
      setServiceOrdersTotal(serviceOrdersResp.total);
      setServiceOrdersPage(serviceOrdersResp.page);

      setTickets(ticketsResp.items);
      setTicketsTotal(ticketsResp.total);
      setTicketsPage(ticketsResp.page);
      setTicketOptions(optionsResp);

      setLeadFilters(leadFilters);
      setServiceOrderFilters(serviceOrderFilters);
      setTicketFilters(ticketFilters);
    } catch (err) {
      console.error(err);
      setError("Nao foi possivel carregar os dados iniciais.");
    } finally {
      setLeadsLoading(false);
      setServiceOrdersLoading(false);
      setTicketsLoading(false);
      setLoading(false);
    }
    },
    [leadsPageSize, serviceOrdersPageSize, ticketsPageSize],
  );

  useEffect(() => {
    const storedLeadFilters = loadLeadFilters(
      FILTER_STORAGE_KEYS.dashboardLeads,
      INITIAL_FILTERS,
    );
    const storedServiceOrderFilters = loadLeadFilters(
      FILTER_STORAGE_KEYS.dashboardServiceOrders,
      INITIAL_SERVICE_ORDER_FILTERS,
    );
    const storedTicketFilters = loadTicketFilters(
      FILTER_STORAGE_KEYS.dashboardTickets,
      INITIAL_TICKET_FILTERS,
    );

    void loadInitial({
      leadFilters: storedLeadFilters,
      serviceOrderFilters: storedServiceOrderFilters,
      ticketFilters: storedTicketFilters,
    }).finally(() => {
      setFiltersReady(true);
    });
  }, [loadInitial]);

  const leadsTotalPages = Math.max(1, Math.ceil(leadsTotal / leadsPageSize));
  const serviceOrdersTotalPages = Math.max(
    1,
    Math.ceil(serviceOrdersTotal / serviceOrdersPageSize),
  );
  const ticketsTotalPages = Math.max(
    1,
    Math.ceil(ticketsTotal / ticketsPageSize),
  );

  const handleLeadPageChange = (direction: -1 | 1) => {
    const next = Math.min(
      leadsTotalPages,
      Math.max(1, leadsPage + direction),
    );
    if (next !== leadsPage) {
      void loadLeads(next, leadFilters);
    }
  };

  const handleLeadFiltersChange = (next: FiltersState) => {
    setLeadFilters(next);
    setLeadsPage(1);
  };

  const handleServiceOrdersPageChange = (direction: -1 | 1) => {
    const next = Math.min(
      serviceOrdersTotalPages,
      Math.max(1, serviceOrdersPage + direction),
    );
    if (next !== serviceOrdersPage) {
      void loadServiceOrders(next, serviceOrderFilters);
    }
  };

  const handleServiceOrderFiltersChange = (next: FiltersState) => {
    setServiceOrderFilters(next);
    setServiceOrdersPage(1);
  };

  const handleTicketPageChange = (direction: -1 | 1) => {
    const next = Math.min(
      ticketsTotalPages,
      Math.max(1, ticketsPage + direction),
    );
    if (next !== ticketsPage) {
      void loadTickets(next, ticketFilters);
    }
  };

  const handleTicketFiltersChange = (next: TicketFiltersState) => {
    setTicketFilters(next);
    setTicketsPage(1);
  };

  useEffect(() => {
    if (!filtersReady) {
      return;
    }
    if (!leadFiltersHydrated.current) {
      leadFiltersHydrated.current = true;
      return;
    }
    const timeoutId = window.setTimeout(() => {
      void loadLeads(1, leadFilters);
    }, 400);
    return () => window.clearTimeout(timeoutId);
  }, [filtersReady, leadFilters, loadLeads]);

  useEffect(() => {
    if (!filtersReady || activeTab !== "leads" || leadsView !== "map") {
      return;
    }
    const timeoutId = window.setTimeout(() => {
      void loadAllLeads(leadFilters);
    }, 400);
    return () => window.clearTimeout(timeoutId);
  }, [activeTab, filtersReady, leadFilters, leadsView, loadAllLeads]);

  useEffect(() => {
    if (!filtersReady) {
      return;
    }
    if (!ticketFiltersHydrated.current) {
      ticketFiltersHydrated.current = true;
      return;
    }
    const timeoutId = window.setTimeout(() => {
      void loadTickets(1, ticketFilters);
    }, 400);
    return () => window.clearTimeout(timeoutId);
  }, [filtersReady, loadTickets, ticketFilters]);

  useEffect(() => {
    if (!filtersReady) {
      return;
    }
    if (!serviceOrderFiltersHydrated.current) {
      serviceOrderFiltersHydrated.current = true;
      return;
    }
    const timeoutId = window.setTimeout(() => {
      void loadServiceOrders(1, serviceOrderFilters);
    }, 400);
    return () => window.clearTimeout(timeoutId);
  }, [filtersReady, loadServiceOrders, serviceOrderFilters]);

  useEffect(() => {
    if (!filtersReady) {
      return;
    }
    saveFilters(FILTER_STORAGE_KEYS.dashboardLeads, leadFilters);
  }, [filtersReady, leadFilters]);

  useEffect(() => {
    if (!filtersReady) {
      return;
    }
    saveFilters(
      FILTER_STORAGE_KEYS.dashboardServiceOrders,
      serviceOrderFilters,
    );
  }, [filtersReady, serviceOrderFilters]);

  useEffect(() => {
    if (!filtersReady) {
      return;
    }
    saveFilters(FILTER_STORAGE_KEYS.dashboardTickets, ticketFilters);
  }, [filtersReady, ticketFilters]);

  const handleLeadAssigned = useCallback((leadId: number, assignee: string) => {
    const updatedAt = new Date().toISOString();
    setLeads((prev) =>
      prev.map((lead) =>
        lead.id === leadId
          ? { ...lead, consultor: assignee, status: "atribuido", updatedAt }
          : lead,
      ),
    );
    setServiceOrders((prev) =>
      prev.map((order) =>
        order.lead.id === leadId
          ? {
              ...order,
              lead: {
                ...order.lead,
                consultor: assignee,
                status: "atribuido",
                updatedAt,
              },
            }
          : order,
      ),
    );
    setSelectedLead((prev) =>
      prev && prev.id === leadId
        ? { ...prev, consultor: assignee, status: "atribuido", updatedAt }
        : prev,
    );
  }, []);

  const handleLeadStatusChange = useCallback((leadId: number, status: string) => {
    const updatedAt = new Date().toISOString();
    setLeads((prev) =>
      prev.map((lead) =>
        lead.id === leadId ? { ...lead, status, updatedAt } : lead,
      ),
    );
    setServiceOrders((prev) =>
      prev.map((order) =>
        order.lead.id === leadId
          ? { ...order, lead: { ...order.lead, status, updatedAt } }
          : order,
      ),
    );
    setSelectedLead((prev) =>
      prev && prev.id === leadId ? { ...prev, status, updatedAt } : prev,
    );
  }, []);

  const handleLeadSelect = useCallback((lead: Lead) => {
    setSelectedLead(lead);
    setLeadDetailsOpen(true);
  }, []);

  const handleServiceOrderUpdated = useCallback(
    (update: {
      id: number;
      partsValue: number;
      laborValue: number;
      note: string | null;
      updatedAt: string;
    }) => {
      setServiceOrders((prev) =>
        prev.map((order) =>
          order.id === update.id
            ? {
                ...order,
                partsValue: update.partsValue,
                laborValue: update.laborValue,
                note: update.note,
                updatedAt: update.updatedAt,
              }
            : order,
        ),
      );
    },
    [],
  );

  const renderContent = () => {
    if (loading) {
      return (
        <div className="rounded-xl border border-slate-200 bg-white p-6 text-sm text-slate-600 shadow-sm">
          Carregando leads, OS e tickets...
        </div>
      );
    }

    if (error) {
      return (
        <div className="flex flex-col gap-3 rounded-xl border border-rose-200 bg-rose-50 p-6 text-sm text-rose-900 shadow-sm">
          <span>{error}</span>
          <button
            type="button"
            onClick={() =>
              loadInitial({
                leadFilters,
                serviceOrderFilters,
                ticketFilters,
              })
            }
            className="inline-flex w-fit items-center gap-2 rounded-lg border border-rose-300 px-3 py-2 text-xs font-semibold text-rose-700 transition hover:border-rose-400 hover:text-rose-900"
          >
            Tentar novamente
          </button>
        </div>
      );
    }

    if (activeTab === "leads") {
      return (
        <div className="space-y-3">
          <div className="flex flex-col gap-3 md:flex-row md:items-center md:justify-between">
            <Tabs
              tabs={[
                { id: "list", label: "LISTA" },
                { id: "map", label: "MAPA" },
              ]}
              activeTabId={leadsView}
              onTabChange={(id) => setLeadsView(id as LeadsViewMode)}
            />
            <div className="text-xs font-semibold uppercase tracking-wide text-slate-500">
              {leadsView === "map"
                ? "Mapa mostra todos os leads filtrados (coords mockadas no Brasil)."
                : "Lista de leads filtrados."}
            </div>
          </div>

          <LeadsFiltersPanel
            filters={leadFilters}
            onFiltersChange={handleLeadFiltersChange}
          />

          {leadsView === "list" ? (
            <LeadsList
              leads={leads}
              filters={leadFilters}
              onFiltersChange={handleLeadFiltersChange}
              loading={leadsLoading}
              pageSize={leadsPageSize}
              currentUserName={currentUserName}
              onLeadAssigned={handleLeadAssigned}
              onLeadStatusChange={handleLeadStatusChange}
              onLeadSelect={handleLeadSelect}
              showFilters={false}
            />
          ) : (
            <LeadsMapView
              leads={mapLeads}
              onLeadSelect={handleLeadSelect}
              visible={leadsView === "map"}
              loading={mapLeadsLoading}
              error={mapLeadsError}
            />
          )}
          {leadsView === "list" ? (
            <div className="flex flex-col gap-2 rounded-lg border border-slate-200 bg-slate-50 px-3 py-2 text-xs text-slate-600 sm:flex-row sm:items-center sm:justify-between sm:text-sm">
              <div className="flex items-center gap-2">
                <span>
                  Pagina {leadsPage} de {leadsTotalPages}
                </span>
                <span className="text-slate-400">
                  ({leadsTotal} leads no total)
                </span>
              </div>
              <div className="flex items-center gap-2">
                <button
                  type="button"
                  onClick={() => handleLeadPageChange(-1)}
                  disabled={leadsPage <= 1 || leadsLoading}
                  className="rounded-lg border border-slate-200 bg-white px-3 py-1 text-sm font-semibold text-slate-700 transition enabled:hover:border-slate-300 enabled:hover:text-slate-900 disabled:opacity-50"
                >
                  Anterior
                </button>
                <button
                  type="button"
                  onClick={() => handleLeadPageChange(1)}
                  disabled={leadsPage >= leadsTotalPages || leadsLoading}
                  className="rounded-lg border border-slate-200 bg-white px-3 py-1 text-sm font-semibold text-slate-700 transition enabled:hover:border-slate-300 enabled:hover:text-slate-900 disabled:opacity-50"
                >
                  Proxima
                </button>
                {leadsLoading && (
                  <span className="text-xs text-slate-500">Atualizando...</span>
                )}
              </div>
            </div>
          ) : (
            <div className="flex flex-col gap-2 rounded-lg border border-slate-200 bg-slate-50 px-3 py-2 text-xs text-slate-600 sm:flex-row sm:items-center sm:justify-between sm:text-sm">
              <div className="flex items-center gap-2">
                <span>Mostrando {mapLeads.length} leads no mapa</span>
              </div>
              {mapLeadsLoading ? (
                <span className="text-xs text-slate-500">Atualizando...</span>
              ) : null}
            </div>
          )}


          {selectedLead ? (
            <LeadDetailsAside
              lead={selectedLead}
              open={leadDetailsOpen}
              onClose={() => setLeadDetailsOpen(false)}
              currentUserName={currentUserName}
              onLeadAssigned={handleLeadAssigned}
            />
          ) : null}
        </div>
      );
    }

    if (activeTab === "os") {
      return (
        <div className="space-y-3">
          <LeadServiceOrdersList
            orders={serviceOrders}
            filters={serviceOrderFilters}
            onFiltersChange={handleServiceOrderFiltersChange}
            onOrderUpdated={handleServiceOrderUpdated}
            loading={serviceOrdersLoading}
            pageSize={serviceOrdersPageSize}
            onLeadSelect={(lead) => {
              setSelectedLead(lead);
              setLeadDetailsOpen(true);
            }}
          />
          <div className="flex flex-col gap-2 rounded-lg border border-slate-200 bg-slate-50 px-3 py-2 text-xs text-slate-600 sm:flex-row sm:items-center sm:justify-between sm:text-sm">
            <div className="flex items-center gap-2">
              <span>
                Pagina {serviceOrdersPage} de {serviceOrdersTotalPages}
              </span>
              <span className="text-slate-400">
                ({serviceOrdersTotal} OS no total)
              </span>
            </div>
            <div className="flex items-center gap-2">
              <button
                type="button"
                onClick={() => handleServiceOrdersPageChange(-1)}
                disabled={serviceOrdersPage <= 1 || serviceOrdersLoading}
                className="rounded-lg border border-slate-200 bg-white px-3 py-1 text-sm font-semibold text-slate-700 transition enabled:hover:border-slate-300 enabled:hover:text-slate-900 disabled:opacity-50"
              >
                Anterior
              </button>
              <button
                type="button"
                onClick={() => handleServiceOrdersPageChange(1)}
                disabled={
                  serviceOrdersPage >= serviceOrdersTotalPages ||
                  serviceOrdersLoading
                }
                className="rounded-lg border border-slate-200 bg-white px-3 py-1 text-sm font-semibold text-slate-700 transition enabled:hover:border-slate-300 enabled:hover:text-slate-900 disabled:opacity-50"
              >
                Proxima
              </button>
              {serviceOrdersLoading && (
                <span className="text-xs text-slate-500">Atualizando...</span>
              )}
            </div>
          </div>

          {selectedLead ? (
            <LeadDetailsAside
              lead={selectedLead}
              open={leadDetailsOpen}
              onClose={() => setLeadDetailsOpen(false)}
              currentUserName={currentUserName}
              onLeadAssigned={handleLeadAssigned}
            />
          ) : null}
        </div>
      );
    }

    return (
      <>
        <TicketsList
          tickets={tickets}
          total={ticketsTotal}
          page={ticketsPage}
          pageSize={ticketsPageSize}
          filters={ticketFilters}
          loading={ticketsLoading}
          onFiltersChange={handleTicketFiltersChange}
          onPageChange={handleTicketPageChange}
          options={ticketOptions ?? undefined}
          onTicketSelect={(ticket: Ticket) => {
            setSelectedTicketId(ticket.id);
            setTicketDetailsOpen(true);
          }}
        />

        {selectedTicketId ? (
          <TicketDetailsAside
            ticketId={selectedTicketId}
            open={ticketDetailsOpen}
            onClose={() => setTicketDetailsOpen(false)}
          />
        ) : null}
      </>
    );
  };

  return (
    <PageShell
      title="Dashboard"
      subtitle="Leads, OS e tickets servidos direto do Supabase."
    >
      <div className="flex flex-col gap-4 rounded-xl border border-slate-200 bg-white p-4 shadow-sm">
        <div className="flex flex-col gap-3 md:flex-row md:items-center md:justify-between">
          <Tabs
            tabs={[
              { id: "leads", label: "LEADS" },
              { id: "os", label: "OS" },
              { id: "tickets", label: "TICKETS" },
            ]}
            activeTabId={activeTab}
            onTabChange={(id) => setActiveTab(id as DashboardTab)}
          />
          <div className="flex flex-col gap-2 text-xs font-semibold uppercase tracking-wide text-slate-500 sm:flex-row sm:items-center sm:gap-4">
            <span>Fonte: Supabase (leads, OS e tickets)</span>
            <form action="/auth/logout" method="post">
              <button
                type="submit"
                className="inline-flex items-center justify-center rounded-lg border border-slate-200 bg-white px-3 py-2 text-xs font-semibold text-slate-700 transition hover:border-slate-300 hover:text-slate-900"
              >
                Sair
              </button>
            </form>
          </div>
        </div>

        {renderContent()}
      </div>
    </PageShell>
  );
}



================================================
FILE: src/app/globals.css
================================================
@import "tailwindcss";
@import "leaflet/dist/leaflet.css";
@import "leaflet-routing-machine/dist/leaflet-routing-machine.css";
@import "leaflet.markercluster/dist/MarkerCluster.css";
@import "leaflet.markercluster/dist/MarkerCluster.Default.css";

:root {
  --background: #f8fafc;
  --foreground: #0f172a;
}

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
}

body {
  background: var(--background);
  color: var(--foreground);
  font-family: var(--font-geist-sans), system-ui, -apple-system, sans-serif;
}

.hide-scrollbar {
  scrollbar-width: none;
  -ms-overflow-style: none;
}

.hide-scrollbar::-webkit-scrollbar {
  display: none;
}



================================================
FILE: src/app/layout.tsx
================================================
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import Link from "next/link";
import { ToastProvider } from "@/components/ToastProvider";
import { AuthProvider } from "@/contexts/AuthContext";
import "./globals.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Leads & Tickets Middleware",
  description: "Painel mockado para leads e tickets",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="pt-BR">
      <body
        className={`${geistSans.variable} ${geistMono.variable} bg-slate-100 text-slate-900 antialiased`}
      >
        <AuthProvider>
          <ToastProvider>
          <div className="min-h-screen bg-slate-100">
            <header className="border-b border-slate-200 bg-white/90 backdrop-blur">
              <div className="mx-auto flex items-center justify-between px-6 py-4">
                <div className="flex items-center gap-3">
                  <div className="flex h-11 w-11 items-center justify-center rounded-full bg-sky-100 text-sm font-bold text-sky-700">
                    LT
                  </div>
                  <div>
                    <p className="text-sm font-semibold text-slate-900">
                      Leads & Tickets
                    </p>
                    <p className="text-xs text-slate-500">
                      Middleware dashboard
                    </p>
                  </div>
                </div>

                <nav className="flex items-center gap-2 text-sm font-semibold">
                  <Link
                    href="/home"
                    className="rounded-lg px-3 py-2 text-slate-600 transition hover:bg-slate-100 hover:text-slate-900"
                  >
                    Home
                  </Link>
                  <Link
                    href="/"
                    className="rounded-lg px-3 py-2 text-slate-600 transition hover:bg-slate-100 hover:text-slate-900"
                  >
                    Dashboard
                  </Link>
                  <Link
                    href="/cronograma"
                    className="rounded-lg px-3 py-2 text-slate-600 transition hover:bg-slate-100 hover:text-slate-900"
                  >
                    Cronograma
                  </Link>
                  <Link
                    href="/leads/import"
                    className="rounded-lg px-3 py-2 text-slate-600 transition hover:bg-slate-100 hover:text-slate-900"
                  >
                    Importar
                  </Link>
                  <Link
                    href="/metrics"
                    className="rounded-lg px-3 py-2 text-slate-600 transition hover:bg-slate-100 hover:text-slate-900"
                  >
                    Métricas
                  </Link>
                </nav>
              </div>
            </header>
            <main>{children}</main>
          </div>
          </ToastProvider>
        </AuthProvider>
      </body>
    </html>
  );
}



================================================
FILE: src/app/not-found.tsx
================================================
import { redirect } from "next/navigation";

export default function NotFound() {
  redirect("/");
}




================================================
FILE: src/app/page.tsx
================================================
import { RequireAuth } from "@/components/RequireAuth";
import DashboardClient from "./dashboard-client";

export default function DashboardPage() {
  return (
    <RequireAuth>
      <DashboardClient />
    </RequireAuth>
  );
}



================================================
FILE: src/app/api/events/lead/route.ts
================================================
import { NextResponse } from "next/server";
import { requireCurrentUser } from "@/lib/currentUser";
import { validateLeadEventInput } from "@/lib/events";
import { getSupabaseUserClient } from "@/lib/supabaseUserClient";

export const dynamic = "force-dynamic";

export async function POST(request: Request) {
  try {
    const user = await requireCurrentUser();
    const body = await request.json();
    const parsed = validateLeadEventInput(body);

    if (!parsed.ok) {
      return NextResponse.json(
        {
          success: false,
          message: parsed.error,
          details: parsed.details ?? null,
        },
        { status: 400 }
      );
    }

    const supabase = await getSupabaseUserClient();
    const { data: leadRow, error: leadError } = await supabase
      .from("leads")
      .select("consultor")
      .eq("id", parsed.value.leadId)
      .single();

    if (leadError) {
      console.error("Supabase lead fetch error", leadError);
      return NextResponse.json(
        { success: false, message: "Erro ao carregar lead." },
        { status: 500 }
      );
    }

    const leadConsultor = (leadRow?.consultor ?? "").trim().toLowerCase();
    const currentUserName = (user.name ?? "").trim().toLowerCase();

    if (parsed.value.action === "register_contact") {
      if (!leadConsultor || leadConsultor !== currentUserName) {
        return NextResponse.json(
          {
            success: false,
            message:
              "Voce so pode registrar contato em leads atribuidos a voce.",
          },
          { status: 403 }
        );
      }
    }

    const updatePayload: Record<string, string> = {
      updated_at: new Date().toISOString(),
    };

    if (parsed.value.action === "assign" && parsed.value.payload.assignee) {
      updatePayload.consultor = parsed.value.payload.assignee;
      updatePayload.status = "atribuido";
    }

    if (parsed.value.action === "discard") {
      updatePayload.status = "descartado";
    }

    if (parsed.value.action === "register_contact") {
      updatePayload.status = "em contato";
    }

    if (parsed.value.action === "close_without_os") {
      updatePayload.status = "fechado_sem_os";
    }

    if (parsed.value.action === "close_with_os") {
      updatePayload.status = "fechado_com_os";
    }

    let eventPayload = parsed.value.payload;

    if (parsed.value.action === "close_with_os") {
      const {
        os,
        parts_value: partsValueRaw,
        labor_value: laborValueRaw,
        note: noteRaw,
        ...restPayload
      } = parsed.value.payload;
      const osNumber = typeof os === "string" ? os.trim() : "";
      const partsValue =
        typeof partsValueRaw === "number" ? partsValueRaw : Number(partsValueRaw);
      const laborValue =
        typeof laborValueRaw === "number" ? laborValueRaw : Number(laborValueRaw);
      const note =
        typeof noteRaw === "string" && noteRaw.trim() ? noteRaw.trim() : null;

      if (
        !Number.isFinite(partsValue) ||
        !Number.isFinite(laborValue) ||
        partsValue < 0 ||
        laborValue < 0
      ) {
        return NextResponse.json(
          { success: false, message: "Valores da OS invalidos." },
          { status: 400 }
        );
      }

      const { data: serviceOrder, error: serviceOrderError } = await supabase
        .from("lead_service_orders")
        .insert({
          lead_id: parsed.value.leadId,
          os_number: osNumber,
          parts_value: partsValue,
          labor_value: laborValue,
          note,
        })
        .select("id")
        .single();

      if (serviceOrderError) {
        console.error("Supabase lead_service_orders insert error", serviceOrderError);
        return NextResponse.json(
          { success: false, message: "Erro ao registrar OS do lead." },
          { status: 500 }
        );
      }

      eventPayload = {
        ...restPayload,
        service_order_id: serviceOrder.id,
      };
    }

    const { error: updateError } = await supabase
      .from("leads")
      .update(updatePayload)
      .eq("id", parsed.value.leadId);
    if (updateError) {
      console.error("Supabase lead update error", updateError);
      return NextResponse.json(
        { success: false, message: "Erro ao atualizar lead." },
        { status: 500 }
      );
    }

    const { data, error } = await supabase
      .from("lead_events")
      .insert({
        lead_id: parsed.value.leadId,
        actor_user_id: user.id,
        actor_email: user.email,
        actor_name: user.name,
        action: parsed.value.action,
        source: "middleware",
        payload: eventPayload,
      })
      .select("*")
      .single();

    if (error) {
      console.error("Supabase lead_events insert error", error);
      return NextResponse.json(
        {
          success: false,
          message: "Erro ao registrar aǧǜo no lead.",
          details: error.message,
        },
        { status: 500 }
      );
    }

    return NextResponse.json({ success: true, event: data });
  } catch (err: any) {
    const status = typeof err?.status === "number" ? err.status : 500;
    if (status !== 500) {
      return NextResponse.json(
        { success: false, message: "Nǜo autenticado." },
        { status }
      );
    }
    console.error("Unexpected lead event error", err);
    return NextResponse.json(
      { success: false, message: "Erro inesperado ao registrar aǧǜo." },
      { status: 500 }
    );
  }
}



================================================
FILE: src/app/api/events/ticket/route.ts
================================================
import { NextResponse } from "next/server";
import { requireCurrentUser } from "@/lib/currentUser";
import { validateTicketEventInput } from "@/lib/events";
import { getSupabaseUserClient } from "@/lib/supabaseUserClient";

export const dynamic = "force-dynamic";

export async function POST(request: Request) {
  try {
    const user = await requireCurrentUser();
    const body = await request.json();
    const parsed = validateTicketEventInput(body);

    if (!parsed.ok) {
      return NextResponse.json(
        { success: false, message: parsed.error, details: parsed.details ?? null },
        { status: 400 },
      );
    }

    const supabase = await getSupabaseUserClient();
    const { data, error } = await supabase
      .from("ticket_events")
      .insert({
        ticket_id: parsed.value.ticketId,
        actor_user_id: user.id,
        actor_email: user.email,
        actor_name: user.name,
        action: parsed.value.action,
        source: "middleware",
        payload: parsed.value.payload,
      })
      .select("*")
      .single();

    if (error) {
      console.error("Supabase ticket_events insert error", error);
      return NextResponse.json(
        { success: false, message: "Erro ao registrar aǧǜo no ticket.", details: error.message },
        { status: 500 },
      );
    }

    return NextResponse.json({ success: true, event: data });
  } catch (err: any) {
    const status = typeof err?.status === "number" ? err.status : 500;
    if (status !== 500) {
      return NextResponse.json(
        { success: false, message: "Nǜo autenticado." },
        { status },
      );
    }
    console.error("Unexpected ticket event error", err);
    return NextResponse.json(
      { success: false, message: "Erro inesperado ao registrar aǧǜo." },
      { status: 500 },
    );
  }
}




================================================
FILE: src/app/api/lead-service-orders/route.ts
================================================
import { NextResponse } from "next/server";
import { LeadCategory, LeadServiceOrder } from "@/lib/domain";
import { ESTADOS, REGIOES, SortOrder } from "@/lib/filters";
import {
  LEAD_SELECT_COLUMNS,
  LeadRow,
  leadTypeOrder,
  mapLeadRow,
} from "@/lib/leadData";
import { getSupabaseServerClient } from "@/lib/supabaseServer";

type LeadServiceOrderRow = {
  id: number;
  lead_id: number | null;
  os_number: string | null;
  parts_value: number | string | null;
  labor_value: number | string | null;
  note: string | null;
  created_at: string | null;
  updated_at: string | null;
  lead: LeadRow | null;
};

const normalizeNumber = (value: unknown): number => {
  if (typeof value === "number") return Number.isFinite(value) ? value : 0;
  if (typeof value === "string") {
    const trimmed = value.trim();
    if (!trimmed) return 0;
    const parsed = Number(trimmed);
    return Number.isFinite(parsed) ? parsed : 0;
  }
  return 0;
};

const normalizeText = (value: unknown): string => {
  if (typeof value !== "string") return "";
  const trimmed = value.trim();
  return trimmed || "";
};

const mapServiceOrderRow = (row: LeadServiceOrderRow): LeadServiceOrder => {
  const leadRow = row.lead as LeadRow;
  return {
    id: row.id,
    leadId: row.lead_id ?? leadRow.id,
    osNumber: normalizeText(row.os_number) || "Sem OS",
    partsValue: normalizeNumber(row.parts_value),
    laborValue: normalizeNumber(row.labor_value),
    note: row.note ?? null,
    createdAt: row.created_at ?? row.updated_at ?? new Date().toISOString(),
    updatedAt: row.updated_at ?? row.created_at ?? new Date().toISOString(),
    lead: mapLeadRow(leadRow),
  };
};

export async function GET(request: Request) {
  try {
    const { searchParams } = new URL(request.url);
    const page = Math.max(Number(searchParams.get("page") ?? "1"), 1);
    const pageSize = Math.min(
      Math.max(Number(searchParams.get("pageSize") ?? "10"), 1),
      100,
    );
    const search = (searchParams.get("search") ?? "").trim();
    const regiaoParam = searchParams.get("regiao");
    const estadoParam = searchParams.get("estado");
    const consultorParam = (searchParams.get("consultor") ?? "").trim();
    const tipoLeadParam = searchParams.get("tipoLead") as LeadCategory | null;
    const sortParam = searchParams.get("sort") as SortOrder | null;
    const sort: SortOrder = sortParam === "antigos" ? "antigos" : "recentes";
    const groupByRaw = (searchParams.get("groupBy") ?? "")
      .split(",")
      .map((item) => item.trim().toLowerCase())
      .filter(Boolean);
    const groupByEmpresa = groupByRaw.includes("empresa");
    const groupByChassi = groupByRaw.includes("chassi");

    const from = (page - 1) * pageSize;
    const to = from + pageSize - 1;

    const supabase = await getSupabaseServerClient();
    const {
      data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ message: "Nao autenticado" }, { status: 401 });
    }

    const regiao =
      regiaoParam && REGIOES.includes(regiaoParam as (typeof REGIOES)[number])
        ? (regiaoParam as (typeof REGIOES)[number])
        : null;
    const estado =
      estadoParam && ESTADOS.includes(estadoParam as (typeof ESTADOS)[number])
        ? (estadoParam as (typeof ESTADOS)[number])
        : null;

    const applyFilters = (baseQuery: any) => {
      let filtered = baseQuery;

      if (groupByChassi) {
        filtered = filtered
          .not("leads.chassi", "is", null)
          .neq("leads.chassi", "");
      }

      if (groupByEmpresa) {
        filtered = filtered
          .not("leads.cliente_base_enriquecida", "is", null)
          .neq("leads.cliente_base_enriquecida", "");
      }

      if (regiao) {
        filtered = filtered.eq("leads.regional", regiao);
      }

      if (estado) {
        filtered = filtered.eq("leads.estado", estado);
      }

      if (consultorParam) {
        const safe = consultorParam.replace(/,/g, "\\,");
        filtered = filtered.ilike("leads.consultor", `%${safe}%`);
      }

      if (tipoLeadParam) {
        const tipoLeadDef = leadTypeOrder.find(
          (entry) => entry.category === tipoLeadParam,
        );
        if (tipoLeadDef) {
          filtered = filtered.ilike(`leads.${tipoLeadDef.key}`, "%sim%");
        }
      }

      if (search) {
        const safeTerm = search.replace(/,/g, "\\,");
        const pattern = `%${safeTerm}%`;
        filtered = filtered.or(
          [
            `os_number.ilike.${pattern}`,
            `note.ilike.${pattern}`,
            `leads.chassi.ilike.${pattern}`,
            `leads.model_name.ilike.${pattern}`,
            `leads.city.ilike.${pattern}`,
            `leads.consultor.ilike.${pattern}`,
            `leads.regional.ilike.${pattern}`,
            `leads.estado.ilike.${pattern}`,
            `leads.last_called_group.ilike.${pattern}`,
          ].join(","),
        );
      }

      return filtered;
    };

    let query = supabase
      .from("lead_service_orders")
      .select(
        [
          "id",
          "lead_id",
          "os_number",
          "parts_value",
          "labor_value",
          "note",
          "created_at",
          "updated_at",
          `lead:leads!inner(${LEAD_SELECT_COLUMNS})`,
        ].join(","),
        { count: "exact" },
      )
      .not("leads.regional", "ilike", "filtros aplicados:%");

    query = applyFilters(query);

    const orders: { column: string; ascending: boolean; foreignTable?: string }[] =
      [];
    if (groupByEmpresa) {
      orders.push({
        column: "cliente_base_enriquecida",
        ascending: true,
        foreignTable: "leads",
      });
    }
    if (groupByChassi) {
      orders.push({ column: "chassi", ascending: true, foreignTable: "leads" });
    }
    orders.push({ column: "updated_at", ascending: sort === "antigos" });

    orders.forEach((orderDef) => {
      query = query.order(orderDef.column, {
        ascending: orderDef.ascending,
        nullsFirst: true,
        foreignTable: orderDef.foreignTable,
      });
    });

    query = query.range(from, to);

    const { data, error, count } = await query;

    if (error) {
      console.error("Supabase lead_service_orders error", error);
      return NextResponse.json(
        { message: "Erro ao buscar OS", details: error.message },
        { status: 500 },
      );
    }

    const items = ((data ?? []) as unknown as LeadServiceOrderRow[])
      .filter((row) => row.lead)
      .map(mapServiceOrderRow);

    return NextResponse.json({
      items,
      total: count ?? items.length,
      page,
      pageSize,
    });
  } catch (err) {
    console.error("Unexpected error fetching OS", err);
    return NextResponse.json(
      { message: "Erro inesperado ao buscar OS" },
      { status: 500 },
    );
  }
}



================================================
FILE: src/app/api/lead-service-orders/[id]/route.ts
================================================
import { NextResponse } from "next/server";
import { getSupabaseServerClient } from "@/lib/supabaseServer";

const parseMoney = (value: unknown): number | null => {
  if (typeof value === "number") {
    return Number.isFinite(value) ? value : null;
  }
  if (typeof value !== "string") return null;
  const trimmed = value.trim();
  if (!trimmed) return null;
  const normalized = trimmed.replace(/[^\d,.-]/g, "");
  if (!normalized) return null;
  let numeric = normalized;
  if (numeric.includes(",") && numeric.includes(".")) {
    numeric = numeric.replace(/\./g, "").replace(",", ".");
  } else if (numeric.includes(",")) {
    numeric = numeric.replace(",", ".");
  }
  const parsed = Number.parseFloat(numeric);
  return Number.isFinite(parsed) ? parsed : null;
};

const parseId = (value: string | undefined) => {
  if (!value) return null;
  const parsed = Number.parseInt(value, 10);
  if (!Number.isFinite(parsed) || !Number.isInteger(parsed) || parsed <= 0) {
    return null;
  }
  return parsed;
};

export async function PATCH(
  request: Request,
  context: { params: Promise<{ id: string }> },
) {
  try {
    const supabase = await getSupabaseServerClient();
    const {
      data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ message: "Nao autenticado" }, { status: 401 });
    }

    const { id } = await context.params;
    const safeId = parseId(id);
    if (!safeId) {
      return NextResponse.json({ message: "OS invalida." }, { status: 400 });
    }

    const raw = await request.json().catch(() => null);
    if (!raw || typeof raw !== "object") {
      return NextResponse.json(
        { message: "Body invalido (esperado JSON)." },
        { status: 400 },
      );
    }

    const partsValue = parseMoney((raw as any).parts_value);
    const laborValue = parseMoney((raw as any).labor_value);
    const noteRaw = (raw as any).note;
    const note =
      typeof noteRaw === "string" && noteRaw.trim() ? noteRaw.trim() : null;

    if (partsValue === null || laborValue === null) {
      return NextResponse.json(
        { message: "Valores invalidos para OS." },
        { status: 400 },
      );
    }

    if (partsValue < 0 || laborValue < 0) {
      return NextResponse.json(
        { message: "Valores da OS devem ser >= 0." },
        { status: 400 },
      );
    }

    const updatedAt = new Date().toISOString();
    const { data, error } = await supabase
      .from("lead_service_orders")
      .update({
        parts_value: partsValue,
        labor_value: laborValue,
        note,
        updated_at: updatedAt,
      })
      .eq("id", safeId)
      .select("id,lead_id,parts_value,labor_value,note,updated_at")
      .single();

    if (error) {
      console.error("Supabase lead_service_orders update error", error);
      return NextResponse.json(
        { message: "Erro ao atualizar OS.", details: error.message },
        { status: 500 },
      );
    }

    return NextResponse.json({
      item: {
        id: data.id,
        leadId: data.lead_id,
        partsValue: Number(data.parts_value),
        laborValue: Number(data.labor_value),
        note: data.note ?? null,
        updatedAt: data.updated_at ?? updatedAt,
      },
    });
  } catch (err) {
    console.error("Unexpected OS update error", err);
    return NextResponse.json(
      { message: "Erro inesperado ao atualizar OS." },
      { status: 500 },
    );
  }
}



================================================
FILE: src/app/api/leads/route.ts
================================================
﻿import { NextResponse } from "next/server";
import { LeadCategory } from "@/lib/domain";
import { ESTADOS, REGIOES, SortOrder } from "@/lib/filters";
import {
  LEAD_SELECT_COLUMNS,
  LeadRow,
  leadTypeOrder,
  mapLeadRow,
  isLeadCategory,
} from "@/lib/leadData";
import { getSupabaseServerClient } from "@/lib/supabaseServer";

type LeadInsertRow = Omit<LeadRow, "id">;

type CreateLeadBody = {
  status?: unknown;
  regional?: unknown;
  estado?: unknown;
  city?: unknown;
  consultor?: unknown;
  nomeContato?: unknown;
  telefone?: unknown;
  chassi?: unknown;
  modelName?: unknown;
  clienteBaseEnriquecida?: unknown;
  horimetroAtualMachineList?: unknown;
  tipoLead?: unknown;
};

const isPlainObject = (value: unknown): value is Record<string, unknown> => {
  if (!value || typeof value !== "object") return false;
  return Object.getPrototypeOf(value) === Object.prototype;
};

const normalizeText = (value: unknown): string | null => {
  if (typeof value !== "string") return null;
  const trimmed = value.trim();
  return trimmed ? trimmed : null;
};

const normalizeNumber = (value: unknown): number | null => {
  if (typeof value === "number") return Number.isFinite(value) ? value : null;
  if (typeof value === "string") {
    const trimmed = value.trim();
    if (!trimmed) return null;
    const parsed = Number(trimmed);
    return Number.isFinite(parsed) ? parsed : null;
  }
  return null;
};

const normalizeWhitespace = (value: string) =>
  value.replace(/\s+/g, " ").trim();

const expandStatusFilters = (items: string[]) => {
  const expanded: string[] = [];
  items.forEach((status) => {
    const trimmed = normalizeWhitespace(status);
    if (!trimmed) return;
    expanded.push(trimmed);
    const withoutParens = normalizeWhitespace(trimmed.replace(/[()]/g, ""));
    if (withoutParens && withoutParens !== trimmed) {
      expanded.push(withoutParens);
    }
  });
  return Array.from(new Set(expanded));
};

export async function GET(request: Request) {
  try {
    const { searchParams } = new URL(request.url);
    const page = Math.max(Number(searchParams.get("page") ?? "1"), 1);
    const pageSize = Math.min(
      Math.max(Number(searchParams.get("pageSize") ?? "10"), 1),
      100,
    );
    const search = (searchParams.get("search") ?? "").trim();
    const regiaoParam = searchParams.get("regiao");
    const estadoParam = searchParams.get("estado");
    const consultorParam = (searchParams.get("consultor") ?? "").trim();
    const tipoLeadParam = searchParams.get("tipoLead") as LeadCategory | null;
    const statusParam = (searchParams.get("status") ?? "").trim();
    const statusFilters = statusParam
      ? statusParam
          .split(",")
          .map((item) => item.trim())
          .filter(Boolean)
      : [];
    const expandedStatusFilters = expandStatusFilters(statusFilters);
    const sortParam = searchParams.get("sort") as SortOrder | null;
    const sort: SortOrder = sortParam === "antigos" ? "antigos" : "recentes";
    const groupByRaw = (searchParams.get("groupBy") ?? "")
      .split(",")
      .map((item) => item.trim().toLowerCase())
      .filter(Boolean);
    const groupByEmpresa = groupByRaw.includes("empresa");
    const groupByChassi = groupByRaw.includes("chassi");

    const from = (page - 1) * pageSize;
    const to = from + pageSize - 1;

    const supabase = await getSupabaseServerClient();
    const {
      data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json(
        { message: "Não autenticado" },
        { status: 401 },
      );
    }

    const regiao =
      regiaoParam && REGIOES.includes(regiaoParam as (typeof REGIOES)[number])
        ? (regiaoParam as (typeof REGIOES)[number])
        : null;
    const estado =
      estadoParam && ESTADOS.includes(estadoParam as (typeof ESTADOS)[number])
        ? (estadoParam as (typeof ESTADOS)[number])
        : null;

    const applyFilters = (
      baseQuery: any,
      options: { includeStatus?: boolean } = {},
    ) => {
      let filtered = baseQuery;
      if (groupByChassi) {
        filtered = filtered.not("chassi", "is", null).neq("chassi", "");
      }

      if (groupByEmpresa) {
        filtered = filtered
          .not("cliente_base_enriquecida", "is", null)
          .neq("cliente_base_enriquecida", "");
      }

      if (regiao) {
        filtered = filtered.eq("regional", regiao);
      }

      if (estado) {
        filtered = filtered.eq("estado", estado);
      }

      if (consultorParam) {
        const safe = consultorParam.replace(/,/g, "\\,");
        filtered = filtered.ilike("consultor", `%${safe}%`);
      }

      if (tipoLeadParam) {
        const tipoLeadDef = leadTypeOrder.find(
          (entry) => entry.category === tipoLeadParam,
        );
        if (tipoLeadDef) {
          filtered = filtered.ilike(tipoLeadDef.key, "%sim%");
        }
      }

      if (options.includeStatus !== false && expandedStatusFilters.length) {
        const filters = expandedStatusFilters.map((status) => {
          const safe = status.replace(/,/g, "\\,");
          return `status.ilike.%${safe}%`;
        });
        filtered = filtered.or(filters.join(","));
      }

      if (search) {
        const safeTerm = search.replace(/,/g, "\\,");
        const pattern = `%${safeTerm}%`;
        filtered = filtered.or(
          [
            `chassi.ilike.${pattern}`,
            `model_name.ilike.${pattern}`,
            `city.ilike.${pattern}`,
            `consultor.ilike.${pattern}`,
            `regional.ilike.${pattern}`,
            `estado.ilike.${pattern}`,
            `last_called_group.ilike.${pattern}`,
          ].join(","),
        );
      }

      return filtered;
    };

    let query = supabase
      .from("leads")
      .select(
        LEAD_SELECT_COLUMNS,
        { count: "exact" },
      )
      .not("regional", "ilike", "filtros aplicados:%");

    query = applyFilters(query);

    const ascending = sort === "antigos";

    const orders: { column: string; ascending: boolean }[] = [];
    if (groupByEmpresa) orders.push({ column: "cliente_base_enriquecida", ascending: true });
    if (groupByChassi) orders.push({ column: "chassi", ascending: true });
    orders.push({ column: "updated_at", ascending });

    orders.forEach((orderDef) => {
      query = query.order(orderDef.column, { ascending: orderDef.ascending, nullsFirst: true });
    });

    const [listResult, statusResult] = await Promise.all([
      query.range(from, to),
      applyFilters(
        supabase
          .from("leads")
          .select("status")
          .not("regional", "ilike", "filtros aplicados:%"),
        { includeStatus: false },
      ),
    ]);

    const { data, error, count } = listResult;
    const { data: statusRows, error: statusError } = statusResult;

    if (error || statusError) {
      console.error("Supabase leads error", error ?? statusError);
      return NextResponse.json(
        {
          message: "Erro ao buscar leads",
          details: (error ?? statusError)?.message,
        },
        { status: 500 },
      );
    }

    const cleanedRows = ((data ?? []) as unknown as LeadRow[]).filter((row) => {
      const regionalNormalized = row.regional?.trim().toLowerCase() ?? "";
      return !regionalNormalized.startsWith("filtros aplicados:");
    });

    const leads = cleanedRows.map(mapLeadRow);
    const statusList = (statusRows ?? []) as Array<{ status: string | null }>;
    const statusOptions = Array.from(
      new Set(
        statusList
          .map((row) => row.status?.trim())
          .filter((status): status is string => Boolean(status)),
      ),
    ).sort((a, b) => a.localeCompare(b, "pt-BR"));

    return NextResponse.json({
      items: leads,
      total: count ?? leads.length,
      page,
      pageSize,
      statusOptions,
    });
  } catch (err) {
    console.error("Unexpected error", err);
    return NextResponse.json(
      { message: "Erro inesperado ao buscar leads" },
      { status: 500 },
    );
  }
}

export async function POST(request: Request) {
  try {
    const supabase = await getSupabaseServerClient();
    const {
      data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ message: "Nao autenticado" }, { status: 401 });
    }

    const raw = (await request.json().catch(() => null)) as unknown;
    if (!isPlainObject(raw)) {
      return NextResponse.json(
        { message: "Body invalido (esperado JSON object)" },
        { status: 400 },
      );
    }

    const body = raw as CreateLeadBody;

    const regional = normalizeText(body.regional);
    const estado = normalizeText(body.estado);
    const city = normalizeText(body.city);
    const consultor = normalizeText(body.consultor);
    const nomeContato = normalizeText(body.nomeContato);
    const telefone = normalizeText(body.telefone);
    const chassi = normalizeText(body.chassi);
    const modelName = normalizeText(body.modelName);
    const clienteBaseEnriquecida = normalizeText(body.clienteBaseEnriquecida);
    const status = normalizeText(body.status);
    const horimetro = normalizeNumber(body.horimetroAtualMachineList);
    const tipoLead = isLeadCategory(body.tipoLead) ? body.tipoLead : null;

    if (regional && !REGIOES.includes(regional as (typeof REGIOES)[number])) {
      return NextResponse.json(
        { message: "Regional invalida" },
        { status: 400 },
      );
    }

    if (estado && !ESTADOS.includes(estado as (typeof ESTADOS)[number])) {
      return NextResponse.json({ message: "Estado invalido" }, { status: 400 });
    }

    const insertRow: LeadInsertRow = {
      status,
      regional,
      estado,
      city,
      consultor,
      nome_contato: nomeContato,
      telefone,
      chassi,
      model_name: modelName,
      cliente_base_enriquecida: clienteBaseEnriquecida,
      horimetro_atual_machine_list: horimetro,
      last_called_group: null,
      lead_preventiva: null,
      lead_garantia_basica: null,
      lead_garantia_estendida: null,
      lead_reforma_de_componentes: null,
      lead_lamina: null,
      lead_dentes: null,
      lead_rodante: null,
      lead_disponibilidade: null,
      lead_reconexao: null,
      lead_transferencia_de_aor: null,
      lead_pops: null,
      lead_outros: null,
      imported_at: new Date().toISOString(),
      updated_at: new Date().toISOString(),
    };

    if (tipoLead && tipoLead !== "indefinido") {
      const tipoDef = leadTypeOrder.find((entry) => entry.category === tipoLead);
      if (tipoDef) {
        insertRow[tipoDef.key] = "SIM";
      }
    }

    const { data, error } = await supabase
      .from("leads")
      .insert(insertRow)
      .select(LEAD_SELECT_COLUMNS)
      .single();

    if (error) {
      console.error("Supabase lead insert error", error);
      return NextResponse.json(
        { message: "Erro ao criar lead", details: error.message },
        { status: 500 },
      );
    }

    const lead = mapLeadRow(data as unknown as LeadRow);
    return NextResponse.json({ item: lead });
  } catch (err) {
    console.error("Unexpected lead insert error", err);
    return NextResponse.json(
      { message: "Erro inesperado ao criar lead" },
      { status: 500 },
    );
  }
}





================================================
FILE: src/app/api/leads/[leadId]/route.ts
================================================
import { NextResponse } from "next/server";
import { requireCurrentUser } from "@/lib/currentUser";
import { getSupabaseServerClient } from "@/lib/supabaseServer";
import { LEAD_SELECT_COLUMNS, mapLeadRow, type LeadRow } from "@/lib/leadData";

export const dynamic = "force-dynamic";

export async function GET(
  _request: Request,
  context: { params: Promise<{ leadId: string }> },
) {
  try {
    await requireCurrentUser();

    const { leadId } = await context.params;
    const safeLeadId = Number((leadId ?? "").trim());

    if (!Number.isFinite(safeLeadId) || !Number.isInteger(safeLeadId) || safeLeadId <= 0) {
      return NextResponse.json(
        { success: false, message: "leadId invalido." },
        { status: 400 },
      );
    }

    const supabase = await getSupabaseServerClient();
    const { data, error } = await supabase
      .from("leads")
      .select(LEAD_SELECT_COLUMNS)
      .eq("id", safeLeadId)
      .single();

    if (error) {
      console.error("Supabase lead fetch error", error);
      return NextResponse.json(
        { success: false, message: "Erro ao carregar lead." },
        { status: 500 },
      );
    }

    if (!data) {
      return NextResponse.json(
        { success: false, message: "Lead não encontrado." },
        { status: 404 },
      );
    }

    return NextResponse.json({
      success: true,
      item: mapLeadRow(data as unknown as LeadRow),
    });
  } catch (err: any) {
    const status = typeof err?.status === "number" ? err.status : 500;
    if (status !== 500) {
      return NextResponse.json(
        { success: false, message: "Nao autenticado." },
        { status },
      );
    }
    console.error("Unexpected lead fetch error", err);
    return NextResponse.json(
      { success: false, message: "Erro inesperado ao carregar lead." },
      { status: 500 },
    );
  }
}



================================================
FILE: src/app/api/leads/[leadId]/events/route.ts
================================================
import { NextResponse } from "next/server";
import { requireCurrentUser } from "@/lib/currentUser";
import { getSupabaseUserClient } from "@/lib/supabaseUserClient";

export const dynamic = "force-dynamic";

type LeadEventRow = {
  lead_id: number | null;
  actor_user_id: string | null;
  actor_email: string | null;
  actor_name: string | null;
  action: string | null;
  source: string | null;
  occurred_at: string | null;
  payload: Record<string, unknown> | null;
};

const parseServiceOrderId = (value: unknown): number | null => {
  if (typeof value === "number") {
    return Number.isFinite(value) && Number.isInteger(value) ? value : null;
  }
  if (typeof value !== "string") return null;
  const trimmed = value.trim();
  if (!trimmed) return null;
  const parsed = Number.parseInt(trimmed, 10);
  if (!Number.isFinite(parsed) || !Number.isInteger(parsed)) return null;
  return parsed;
};

export async function GET(
  _request: Request,
  context: { params: Promise<{ leadId: string }> },
) {
  try {
    await requireCurrentUser();

    const { leadId } = await context.params;
    const safeLeadId = Number((leadId ?? "").trim());

    if (!Number.isFinite(safeLeadId) || !Number.isInteger(safeLeadId) || safeLeadId <= 0) {
      return NextResponse.json(
        { success: false, message: "leadId invalido." },
        { status: 400 },
      );
    }

    const supabase = await getSupabaseUserClient();
    const { data, error } = await supabase
      .from("lead_events")
      .select(
        "lead_id,actor_user_id,actor_email,actor_name,action,source,occurred_at,payload",
      )
      .eq("lead_id", safeLeadId)
      .order("occurred_at", { ascending: false })
      .limit(50);

    if (error) {
      console.error("Supabase lead events error", error);
      return NextResponse.json(
        { success: false, message: "Erro ao buscar eventos do lead." },
        { status: 500 },
      );
    }

    const serviceOrderIds = (data ?? [])
      .map((row: LeadEventRow) =>
        parseServiceOrderId(row.payload?.service_order_id),
      )
      .filter((id): id is number => Boolean(id));

    const serviceOrderMap = new Map<
      number,
      { os_number: string; parts_value: unknown; labor_value: unknown; note: unknown }
    >();

    if (serviceOrderIds.length) {
      const { data: serviceOrders, error: serviceOrdersError } = await supabase
        .from("lead_service_orders")
        .select("id,os_number,parts_value,labor_value,note")
        .in("id", Array.from(new Set(serviceOrderIds)));

      if (serviceOrdersError) {
        console.error("Supabase lead_service_orders fetch error", serviceOrdersError);
        return NextResponse.json(
          { success: false, message: "Erro ao carregar OS do lead." },
          { status: 500 },
        );
      }

      (serviceOrders ?? []).forEach((order: any) => {
        if (!order?.id) return;
        serviceOrderMap.set(order.id, {
          os_number: String(order.os_number ?? ""),
          parts_value: order.parts_value,
          labor_value: order.labor_value,
          note: order.note,
        });
      });
    }

    const items = (data ?? []).map((row: LeadEventRow) => {
      const serviceOrderId = parseServiceOrderId(row.payload?.service_order_id);
      const serviceOrder = serviceOrderId
        ? serviceOrderMap.get(serviceOrderId)
        : null;
      const payload = row.payload ?? null;

      const enrichedPayload =
        payload && serviceOrder
          ? {
              ...payload,
              os: serviceOrder.os_number,
              parts_value: serviceOrder.parts_value,
              labor_value: serviceOrder.labor_value,
              note:
                typeof serviceOrder.note === "string" &&
                serviceOrder.note.trim()
                  ? serviceOrder.note
                  : payload.note,
            }
          : payload;

      return {
        leadId: row.lead_id,
        actorUserId: row.actor_user_id,
        actorEmail: row.actor_email,
        actorName: row.actor_name,
        action: row.action,
        source: row.source,
        occurredAt: row.occurred_at,
        payload: enrichedPayload,
      };
    });

    return NextResponse.json({ success: true, items });
  } catch (err: any) {
    const status = typeof err?.status === "number" ? err.status : 500;
    if (status !== 500) {
      return NextResponse.json(
        { success: false, message: "Nao autenticado." },
        { status },
      );
    }
    console.error("Unexpected lead events error", err);
    return NextResponse.json(
      { success: false, message: "Erro inesperado ao buscar eventos." },
      { status: 500 },
    );
  }
}



================================================
FILE: src/app/api/leads/import/route.ts
================================================
import { NextResponse } from "next/server";
import { getSupabaseServerClient } from "@/lib/supabaseServer";

export const dynamic = "force-dynamic";

type LeadImportItem = {
  status?: unknown;
  regional?: unknown;
  estado?: unknown;
  city?: unknown;
  consultor?: unknown;
  nomeContato?: unknown;
  telefone?: unknown;
  chassi?: unknown;
  clienteBaseEnriquecida?: unknown;
  horimetroAtualMachineList?: unknown;
  leadTipos?: unknown;
};

type LeadInsertRow = {
  status: string | null;
  regional: string | null;
  estado: string | null;
  city: string | null;
  consultor: string | null;
  nome_contato: string | null;
  telefone: string | null;
  created_by: string | null;
  chassi: string | null;
  cliente_base_enriquecida: string | null;
  horimetro_atual_machine_list: number | null;
  last_called_group: string | null;
  lead_preventiva: string | null;
  lead_garantia_basica: string | null;
  lead_garantia_estendida: string | null;
  lead_reforma_de_componentes: string | null;
  lead_lamina: string | null;
  lead_dentes: string | null;
  lead_rodante: string | null;
  lead_disponibilidade: string | null;
  lead_reconexao: string | null;
  lead_transferencia_de_aor: string | null;
  lead_pops: string | null;
  lead_outros: string | null;
  // imported_at: string;
};

const isPlainObject = (value: unknown): value is Record<string, unknown> => {
  if (!value || typeof value !== "object") return false;
  return Object.getPrototypeOf(value) === Object.prototype;
};

const normalizeText = (value: unknown): string | null => {
  if (typeof value !== "string") return null;
  const trimmed = value.trim();
  return trimmed ? trimmed : null;
};

const normalizeNumber = (value: unknown): number | null => {
  if (typeof value === "number") return Number.isFinite(value) ? value : null;
  if (typeof value === "string") {
    const trimmed = value.trim();
    if (!trimmed) return null;
    const parsed = Number(trimmed);
    return Number.isFinite(parsed) ? parsed : null;
  }
  return null;
};

const normalizeFlag = (value: unknown): string | null => {
  if (typeof value === "boolean") return value ? "SIM" : "NAO";
  if (typeof value !== "string") return null;
  const trimmed = value.trim();
  return trimmed ? trimmed.toUpperCase() : null;
};

const leadTypeFlagMap = {
  preventiva: "lead_preventiva",
  garantia_basica: "lead_garantia_basica",
  garantia_estendida: "lead_garantia_estendida",
  reforma_componentes: "lead_reforma_de_componentes",
  lamina: "lead_lamina",
  dentes: "lead_dentes",
  rodante: "lead_rodante",
  disponibilidade: "lead_disponibilidade",
  reconexao: "lead_reconexao",
  transferencia_aor: "lead_transferencia_de_aor",
  pops: "lead_pops",
  outros: "lead_outros",
} as const;

const parseLeadTipos = (value: unknown): string[] => {
  if (Array.isArray(value)) {
    return value
      .map((item) => (typeof item === "string" ? item.trim() : String(item)))
      .filter((item) => item);
  }
  if (typeof value === "string") {
    return value
      .split(/[;,|]/)
      .map((item) => item.trim())
      .filter((item) => item);
  }
  return [];
};

const buildLeadFlags = (item: LeadImportItem) => {
  const tipos = parseLeadTipos(item.leadTipos);
  if (tipos.length) {
    const selected = new Set(tipos);
    return Object.fromEntries(
      Object.entries(leadTypeFlagMap).map(([key, column]) => [
        column,
        selected.has(key) ? "SIM" : "NAO",
      ])
    ) as Pick<
      LeadInsertRow,
      | "lead_preventiva"
      | "lead_garantia_basica"
      | "lead_garantia_estendida"
      | "lead_reforma_de_componentes"
      | "lead_lamina"
      | "lead_dentes"
      | "lead_rodante"
      | "lead_disponibilidade"
      | "lead_reconexao"
      | "lead_transferencia_de_aor"
      | "lead_pops"
      | "lead_outros"
    >;
  }

  const flags = {
    lead_preventiva: normalizeFlag((item as any).leadPreventiva),
    lead_garantia_basica: normalizeFlag((item as any).leadGarantiaBasica),
    lead_garantia_estendida: normalizeFlag((item as any).leadGarantiaEstendida),
    lead_reforma_de_componentes: normalizeFlag(
      (item as any).leadReformaDeComponentes
    ),
    lead_lamina: normalizeFlag((item as any).leadLamina),
    lead_dentes: normalizeFlag((item as any).leadDentes),
    lead_rodante: normalizeFlag((item as any).leadRodante),
    lead_disponibilidade: normalizeFlag((item as any).leadDisponibilidade),
    lead_reconexao: normalizeFlag((item as any).leadReconexao),
    lead_transferencia_de_aor: normalizeFlag(
      (item as any).leadTransferenciaDeAor
    ),
    lead_pops: normalizeFlag((item as any).leadPops),
    lead_outros: normalizeFlag((item as any).leadOutros),
  };

  return flags;
};

const hasAnyValue = (item: LeadImportItem) => {
  return Object.values(item).some((value) => {
    if (value === null || value === undefined) return false;
    if (typeof value === "string") return value.trim().length > 0;
    if (typeof value === "number") return Number.isFinite(value);
    if (Array.isArray(value)) return value.length > 0;
    if (typeof value === "boolean") return true;
    return true;
  });
};

const mapImportItem = (
  item: LeadImportItem,
  createdBy: string | null
): LeadInsertRow => ({
  status: "novo",
  regional: normalizeText(item.regional),
  estado: normalizeText(item.estado),
  city: normalizeText(item.city),
  consultor: normalizeText(item.consultor),
  nome_contato: normalizeText(item.nomeContato),
  telefone: normalizeText(item.telefone),
  created_by: createdBy,
  chassi: normalizeText(item.chassi),
  cliente_base_enriquecida: normalizeText(item.clienteBaseEnriquecida),
  horimetro_atual_machine_list: normalizeNumber(item.horimetroAtualMachineList),
  last_called_group: null,
  ...buildLeadFlags(item),
  // imported_at: new Date().toISOString(),
});

export async function POST(request: Request) {
  try {
    const supabase = await getSupabaseServerClient();
    const {
      data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ message: "Nao autenticado" }, { status: 401 });
    }

    const raw = (await request.json().catch(() => null)) as unknown;
    if (!isPlainObject(raw)) {
      return NextResponse.json(
        { message: "Body invalido (esperado JSON object)" },
        { status: 400 }
      );
    }

    const items = (raw as { items?: unknown }).items;
    if (!Array.isArray(items)) {
      return NextResponse.json(
        { message: "items invalido (esperado array)" },
        { status: 400 }
      );
    }

    const createdBy = user.email ?? user.id ?? null;

    const mapped = items
      .filter(
        (item) => isPlainObject(item) && hasAnyValue(item as LeadImportItem)
      )
      .map((item) => mapImportItem(item as LeadImportItem, createdBy));

    if (!mapped.length) {
      return NextResponse.json(
        { message: "Nenhuma linha valida para importar." },
        { status: 400 }
      );
    }

    const { data, error } = await supabase
      .from("leads")
      .insert(mapped)
      .select("id");

    if (error) {
      console.error("Supabase lead import error", error);
      return NextResponse.json(
        { message: "Erro ao importar leads", details: error.message },
        { status: 500 }
      );
    }

    return NextResponse.json({
      success: true,
      inserted: data?.length ?? mapped.length,
    });
  } catch (err) {
    console.error("Unexpected lead import error", err);
    return NextResponse.json(
      { message: "Erro inesperado ao importar leads" },
      { status: 500 }
    );
  }
}



================================================
FILE: src/app/api/metrics/leads/route.ts
================================================
import { NextResponse } from "next/server";
import { requireCurrentUser } from "@/lib/currentUser";
import { getSupabaseUserClient } from "@/lib/supabaseUserClient";
import {
  aggregateDailyMetrics,
  aggregateUserMetrics,
  rangeToStart,
} from "@/lib/metricsAggregation";
import { isMetricsRange, type MetricsRange } from "@/lib/metrics";

export const dynamic = "force-dynamic";

const parseServiceOrderId = (value: unknown): number | null => {
  if (typeof value === "number") {
    return Number.isFinite(value) && Number.isInteger(value) ? value : null;
  }
  if (typeof value !== "string") return null;
  const trimmed = value.trim();
  if (!trimmed) return null;
  const parsed = Number.parseInt(trimmed, 10);
  if (!Number.isFinite(parsed) || !Number.isInteger(parsed)) return null;
  return parsed;
};

export async function GET(request: Request) {
  try {
    await requireCurrentUser();

    const { searchParams } = new URL(request.url);
    const rangeParam = (searchParams.get("range") ?? "week").trim();
    const includeUsersParam = (searchParams.get("includeUsers") ?? "1").trim();
    const range: MetricsRange = isMetricsRange(rangeParam) ? rangeParam : "week";
    const start = rangeToStart(range);

    const supabase = await getSupabaseUserClient();
    let query = supabase
      .from("lead_events")
      .select("lead_id,actor_user_id,actor_email,actor_name,action,occurred_at,payload");

    query = query.gte("occurred_at", start.toISOString());

    const { data, error } = await query;

    if (error) {
      console.error("Supabase lead metrics error", error);
      return NextResponse.json(
        { success: false, message: "Erro ao buscar mǸtricas de leads.", details: error.message },
        { status: 500 },
      );
    }

    const rows = (data ?? []).map((row: any) => ({
      actor_user_id: row.actor_user_id as string | null,
      actor_email: row.actor_email as string | null,
      actor_name: row.actor_name as string | null,
      action: row.action as string | null,
      item_id: row.lead_id as number | null,
      occurred_at: row.occurred_at as string | null,
      payload: row.payload as Record<string, unknown> | null,
    }));

    const serviceOrderIds = rows
      .map((row) => parseServiceOrderId(row.payload?.service_order_id))
      .filter((id): id is number => Boolean(id));
    const serviceOrderMap = new Map<
      number,
      { os_number: string; parts_value: unknown; labor_value: unknown; note: unknown }
    >();
    if (serviceOrderIds.length) {
      const { data: serviceOrders, error: serviceOrdersError } = await supabase
        .from("lead_service_orders")
        .select("id,os_number,parts_value,labor_value,note")
        .in("id", Array.from(new Set(serviceOrderIds)));

      if (serviceOrdersError) {
        console.error("Supabase lead_service_orders metrics error", serviceOrdersError);
        return NextResponse.json(
          { success: false, message: "Erro ao buscar OS de leads.", details: serviceOrdersError.message },
          { status: 500 },
        );
      }

      (serviceOrders ?? []).forEach((order: any) => {
        if (!order?.id) return;
        serviceOrderMap.set(order.id, {
          os_number: String(order.os_number ?? ""),
          parts_value: order.parts_value,
          labor_value: order.labor_value,
          note: order.note,
        });
      });
    }

    const enrichedRows = rows.map((row) => {
      const serviceOrderId = parseServiceOrderId(row.payload?.service_order_id);
      const serviceOrder = serviceOrderId
        ? serviceOrderMap.get(serviceOrderId)
        : null;
      if (!serviceOrder || !row.payload) return row;
      return {
        ...row,
        payload: {
          ...row.payload,
          os: serviceOrder.os_number,
          parts_value: serviceOrder.parts_value,
          labor_value: serviceOrder.labor_value,
          note:
            typeof serviceOrder.note === "string" && serviceOrder.note.trim()
              ? serviceOrder.note
              : row.payload.note,
        },
      };
    });

    const usersMap = new Map<string, { id: string; name?: string; email?: string }>();
    const includeUsers = includeUsersParam !== "0";
    if (includeUsers) {
      const { data: userData, error: userError } = await supabase
        .from("lead_events")
        .select("actor_user_id,actor_email,actor_name");

      if (userError) {
        console.error("Supabase lead users error", userError);
        return NextResponse.json(
          { success: false, message: "Erro ao buscar usuarios de leads.", details: userError.message },
          { status: 500 },
        );
      }

      (userData ?? []).forEach((row: any) => {
        const id = (row.actor_user_id as string | null)?.trim();
        if (!id) return;
        const existing = usersMap.get(id);
        usersMap.set(id, {
          id,
          name: (row.actor_name as string | null)?.trim() || existing?.name,
          email: (row.actor_email as string | null)?.trim() || existing?.email,
        });
      });
    }

    const metrics = aggregateUserMetrics(enrichedRows);
    const daily = aggregateDailyMetrics(enrichedRows);
    return NextResponse.json({
      success: true,
      range,
      items: metrics,
      daily,
      users: Array.from(usersMap.values()),
      events: enrichedRows
        .filter(
          (row) => row.actor_user_id && row.action && row.item_id && row.occurred_at
        )
        .map((row) => ({
          actor_user_id: row.actor_user_id as string,
          action: row.action as string,
          item_id: String(row.item_id as number),
          occurred_at: row.occurred_at as string,
          payload: (row.payload as Record<string, unknown> | null) ?? null,
        })),
    });
  } catch (err: any) {
    const status = typeof err?.status === "number" ? err.status : 500;
    if (status !== 500) {
      return NextResponse.json({ success: false, message: "Nǜo autenticado." }, { status });
    }
    console.error("Unexpected leads metrics error", err);
    return NextResponse.json(
      { success: false, message: "Erro inesperado ao buscar mǸtricas." },
      { status: 500 },
    );
  }
}



================================================
FILE: src/app/api/metrics/tickets/route.ts
================================================
import { NextResponse } from "next/server";
import { requireCurrentUser } from "@/lib/currentUser";
import { getSupabaseUserClient } from "@/lib/supabaseUserClient";
import {
  aggregateDailyMetrics,
  aggregateUserMetrics,
  rangeToStart,
} from "@/lib/metricsAggregation";
import { isMetricsRange, type MetricsRange } from "@/lib/metrics";

export const dynamic = "force-dynamic";

export async function GET(request: Request) {
  try {
    await requireCurrentUser();

    const { searchParams } = new URL(request.url);
    const rangeParam = (searchParams.get("range") ?? "week").trim();
    const includeUsersParam = (searchParams.get("includeUsers") ?? "1").trim();
    const range: MetricsRange = isMetricsRange(rangeParam) ? rangeParam : "week";
    const start = rangeToStart(range);

    const supabase = await getSupabaseUserClient();
    let query = supabase
      .from("ticket_events")
      .select("ticket_id,actor_user_id,actor_email,actor_name,action,occurred_at,payload");

    query = query.gte("occurred_at", start.toISOString());

    const { data, error } = await query;

    if (error) {
      console.error("Supabase ticket metrics error", error);
      return NextResponse.json(
        { success: false, message: "Erro ao buscar mǸtricas de tickets.", details: error.message },
        { status: 500 },
      );
    }

    const rows = (data ?? []).map((row: any) => ({
      actor_user_id: row.actor_user_id as string | null,
      actor_email: row.actor_email as string | null,
      actor_name: row.actor_name as string | null,
      action: row.action as string | null,
      item_id: row.ticket_id as string | null,
      occurred_at: row.occurred_at as string | null,
      payload: row.payload as Record<string, unknown> | null,
    }));

    const events = rows
      .filter((row) => row.actor_user_id && row.action && row.item_id && row.occurred_at)
      .map((row) => ({
        actor_user_id: row.actor_user_id as string,
        action: row.action as string,
        item_id: String(row.item_id as string),
        occurred_at: row.occurred_at as string,
        payload: (row.payload as Record<string, unknown> | null) ?? null,
      }));

    const usersMap = new Map<string, { id: string; name?: string; email?: string }>();
    const includeUsers = includeUsersParam !== "0";
    if (includeUsers) {
      const { data: userData, error: userError } = await supabase
        .from("ticket_events")
        .select("actor_user_id,actor_email,actor_name");

      if (userError) {
        console.error("Supabase ticket users error", userError);
        return NextResponse.json(
          { success: false, message: "Erro ao buscar usuarios de tickets.", details: userError.message },
          { status: 500 },
        );
      }

      (userData ?? []).forEach((row: any) => {
        const id = (row.actor_user_id as string | null)?.trim();
        if (!id) return;
        const existing = usersMap.get(id);
        usersMap.set(id, {
          id,
          name: (row.actor_name as string | null)?.trim() || existing?.name,
          email: (row.actor_email as string | null)?.trim() || existing?.email,
        });
      });
    }

    const metrics = aggregateUserMetrics(rows);
    const daily = aggregateDailyMetrics(rows);
    return NextResponse.json({
      success: true,
      range,
      items: metrics,
      daily,
      users: Array.from(usersMap.values()),
      events,
    });
  } catch (err: any) {
    const status = typeof err?.status === "number" ? err.status : 500;
    if (status !== 500) {
      return NextResponse.json({ success: false, message: "Nǜo autenticado." }, { status });
    }
    console.error("Unexpected tickets metrics error", err);
    return NextResponse.json(
      { success: false, message: "Erro inesperado ao buscar mǸtricas." },
      { status: 500 },
    );
  }
}



================================================
FILE: src/app/api/tickets/route.ts
================================================
import { NextResponse } from "next/server";
import { Ticket, TicketStatus } from "@/lib/domain";
import { SortOrder } from "@/lib/filters";
import { getSupabaseServerClient } from "@/lib/supabaseServer";

type TicketRow = {
  ticket_id: string | null;
  number: string | null;
  title: string | null;
  status: number | null;
  serial_number: string | null;
  advisor_first_name: string | null;
  advisor_last_name: string | null;
  advisor_email: string | null;
  advisor_racfid: string | null;
  customer_first_name: string | null;
  customer_last_name: string | null;
  customer_organization: string | null;
  customer_account: string | null;
  team_name: string | null;
  updated_date: string | null;
  created_date: string | null;
  url: string | null;
};

const clean = (value: string | null) => value?.trim() || null;

const buildName = (first: string | null, last: string | null) => {
  const firstClean = clean(first);
  const lastClean = clean(last);
  if (firstClean && lastClean) {
    return `${firstClean} ${lastClean}`;
  }
  return firstClean ?? lastClean;
};

const mapStatus = (code: number | null): TicketStatus => {
  if (code === 1) return "aberto";
  if (code === 2) return "fechado";
  return "desconhecido";
};

const mapTicketRow = (row: TicketRow): Ticket => {
  const statusCode =
    typeof row.status === "number"
      ? row.status
      : row.status === null
      ? null
      : Number(row.status);

  const number = clean(row.number) ?? "Sem número";
  const title = clean(row.title) ?? "Sem título";
  const updatedAt = row.updated_date ?? row.created_date ?? null;
  const createdAt = row.created_date ?? row.updated_date ?? null;
  const customerPersonName = buildName(
    row.customer_first_name,
    row.customer_last_name,
  );
  const customerOrganization = clean(row.customer_organization);
  const customerAccount = clean(row.customer_account);

  return {
    id: clean(row.ticket_id) ?? number,
    number,
    title,
    status: mapStatus(statusCode),
    statusCode,
    serialNumber: clean(row.serial_number),
    advisorName:
      buildName(row.advisor_first_name, row.advisor_last_name) ??
      clean(row.advisor_email) ??
      clean(row.advisor_racfid),
    customerName: customerPersonName ?? customerOrganization ?? customerAccount,
    customerOrganization: customerOrganization ?? customerAccount,
    teamName: clean(row.team_name),
    updatedAt,
    createdAt,
    url: clean(row.url),
  };
};

const statusToCode: Record<TicketStatus, number | null> = {
  aberto: 1,
  fechado: 2,
  desconhecido: null,
};

export async function GET(request: Request) {
  try {
    const { searchParams } = new URL(request.url);
    const page = Math.max(Number(searchParams.get("page") ?? "1"), 1);
    const pageSize = Math.min(
      Math.max(Number(searchParams.get("pageSize") ?? "10"), 1),
      200
    );
    const search = (searchParams.get("search") ?? "").trim();
    const statusParam = searchParams.get("status") as TicketStatus | "" | null;
    const sortParam = searchParams.get("sort") as SortOrder | null;
    const sort: SortOrder = sortParam === "antigos" ? "antigos" : "recentes";
    const groupByRaw = (searchParams.get("groupBy") ?? "")
      .split(",")
      .map((item) => item.trim().toLowerCase())
      .filter(Boolean);
    const groupByEmpresa = groupByRaw.includes("empresa");
    const groupByChassi = groupByRaw.includes("chassi");
    const consultorParam = (searchParams.get("consultor") ?? "").trim();
    const clienteParam = (searchParams.get("cliente") ?? "").trim();
    const equipeParam = (searchParams.get("equipe") ?? "").trim();

    const from = (page - 1) * pageSize;
    const to = from + pageSize - 1;

    const supabase = await getSupabaseServerClient();
    const {
      data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json(
        { message: "Não autenticado" },
        { status: 401 }
      );
    }

    let query = supabase
      .from("tickets")
      .select(
        [
          "ticket_id",
          "number",
          "title",
          "status",
          "serial_number",
          "advisor_first_name",
          "advisor_last_name",
          "advisor_email",
          "advisor_racfid",
          "customer_first_name",
          "customer_last_name",
          "customer_organization",
          "customer_account",
          "team_name",
          "updated_date",
          "created_date",
          "url",
        ].join(","),
        { count: "exact" }
      );

    if (groupByChassi) {
      query = query.not("serial_number", "is", null).neq("serial_number", "");
    }

    if (groupByEmpresa) {
      query = query
        .not("customer_organization", "is", null)
        .neq("customer_organization", "");
    }

    // Order respecting grouping -> empresa -> chassi -> updated_date
    const orders: { column: string; ascending: boolean }[] = [];
    if (groupByEmpresa) {
      orders.push({ column: "customer_organization", ascending: true });
    }
    if (groupByChassi) {
      orders.push({ column: "serial_number", ascending: true });
    }
    orders.push({ column: "updated_date", ascending: sort === "antigos" });

    orders.forEach((orderDef) => {
      query = query.order(orderDef.column, {
        ascending: orderDef.ascending,
        nullsFirst: true,
      });
    });

    query = query.range(from, to);

    if (statusParam) {
      const statusCode = statusToCode[statusParam];
      if (statusCode !== null) {
        query = query.eq("status", statusCode);
      }
    }

    if (search) {
      const safe = search.replace(/,/g, "\\,");
      const pattern = `%${safe}%`;
      query = query.or(
        [
          `number.ilike.${pattern}`,
          `title.ilike.${pattern}`,
          `serial_number.ilike.${pattern}`,
          `customer_organization.ilike.${pattern}`,
          `advisor_first_name.ilike.${pattern}`,
          `advisor_last_name.ilike.${pattern}`,
          `team_name.ilike.${pattern}`,
        ].join(",")
      );
    }

    if (consultorParam) {
      const parts = consultorParam.split(/\s+/).filter(Boolean);
      if (parts.length >= 2) {
        const first = `%${parts[0].replace(/,/g, "\\,")}%`;
        const last = `%${parts.slice(1).join(" ").replace(/,/g, "\\,")}%`;
        query = query
          .ilike("advisor_first_name", first)
          .ilike("advisor_last_name", last);
      } else {
        const token = `%${parts[0].replace(/,/g, "\\,")}%`;
        query = query.or(
          [
            `advisor_first_name.ilike.${token}`,
            `advisor_last_name.ilike.${token}`,
          ].join(",")
        );
      }
    }

    if (clienteParam) {
      const pattern = `%${clienteParam.replace(/,/g, "\\,")}%`;
      query = query.ilike("customer_organization", pattern);
    }

    if (equipeParam) {
      query = query.ilike("team_name", `%${equipeParam.replace(/,/g, "\\,")}%`);
    }

    const { data, error, count } = await query;

    if (error) {
      console.error("Supabase tickets error", error);
      return NextResponse.json(
        { message: "Erro ao buscar tickets", details: error.message },
        { status: 500 }
      );
    }

    const tickets = ((data ?? []) as unknown as TicketRow[]).map(mapTicketRow);

    return NextResponse.json({
      items: tickets,
      total: count ?? tickets.length,
      page,
      pageSize,
    });
  } catch (err) {
    console.error("Unexpected error fetching tickets", err);
    return NextResponse.json(
      { message: "Erro inesperado ao buscar tickets" },
      { status: 500 }
    );
  }
}



================================================
FILE: src/app/api/tickets/[ticketId]/route.ts
================================================
import { NextResponse } from "next/server";
import { getSupabaseServerClient } from "@/lib/supabaseServer";
import { fetchExpertConnectTicketById } from "@/lib/expertconnect";

export const runtime = "nodejs";
export const dynamic = "force-dynamic";

type NormalizedError = {
  message: string;
  code:
    | "unauthenticated"
    | "invalid_ticket_id"
    | "not_found"
    | "upstream_auth_failed"
    | "upstream_error"
    | "server_error";
  details?: unknown;
};

const jsonError = (status: number, body: NormalizedError) =>
  NextResponse.json(body, { status });

const pickUpstreamMessage = (payload: unknown): string | null => {
  if (!payload || typeof payload !== "object") return null;
  const maybeMessage =
    (payload as any).message ??
    (payload as any).error?.message ??
    (payload as any).error_description ??
    (payload as any).title;
  if (typeof maybeMessage === "string" && maybeMessage.trim()) {
    return maybeMessage.trim().slice(0, 300);
  }
  return null;
};

export async function GET(
  _request: Request,
  context: { params: Promise<{ ticketId: string }> },
) {
  try {
    const { ticketId } = await context.params;
    const safeTicketId = (ticketId ?? "").trim();

    if (!safeTicketId) {
      return jsonError(400, {
        code: "invalid_ticket_id",
        message: "ticketId é obrigatório",
      });
    }

    const supabase = await getSupabaseServerClient();
    const {
      data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
      return jsonError(401, {
        code: "unauthenticated",
        message: "Não autenticado",
      });
    }

    const data = await fetchExpertConnectTicketById(safeTicketId);
    return NextResponse.json(data);
  } catch (err) {
    const status = typeof (err as any)?.status === "number" ? (err as any).status : null;
    const payload = (err as any)?.payload;
    const upstreamMessage = pickUpstreamMessage(payload);

    if (status === 404) {
      return jsonError(404, {
        code: "not_found",
        message: "Ticket não encontrado",
      });
    }

    if (status === 400) {
      return jsonError(400, {
        code: "invalid_ticket_id",
        message: upstreamMessage ?? "Parâmetros inválidos",
      });
    }

    if (status === 401 || status === 403) {
      return jsonError(502, {
        code: "upstream_auth_failed",
        message: "Falha ao autenticar na Partner API",
      });
    }

    if (status && status >= 400 && status < 600) {
      return jsonError(502, {
        code: "upstream_error",
        message: upstreamMessage ?? "Erro ao buscar ticket na Partner API",
        details: { upstreamStatus: status },
      });
    }

    console.error("Unexpected error in GET /api/tickets/[ticketId]", err);
    return jsonError(500, {
      code: "server_error",
      message: "Erro inesperado ao buscar ticket",
    });
  }
}



================================================
FILE: src/app/api/tickets/options/route.ts
================================================
import { NextResponse } from "next/server";
import { getSupabaseServerClient } from "@/lib/supabaseServer";

const normalize = (value: string | null) => value?.trim() ?? "";

const dedupe = (items: (string | null)[]) => {
  const seen = new Set<string>();
  const result: string[] = [];
  for (const raw of items) {
    const val = normalize(raw);
    if (!val) continue;
    if (seen.has(val)) continue;
    seen.add(val);
    result.push(val);
  }
  return result;
};

export async function GET() {
  try {
    const supabase = await getSupabaseServerClient();
    const {
      data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json(
        { message: "Não autenticado" },
        { status: 401 },
      );
    }

    const [advisorsResp, customersResp, teamsResp] = await Promise.all([
      supabase
        .from("tickets")
        .select("advisor_first_name, advisor_last_name, advisor_email, advisor_racfid"),
      supabase
        .from("tickets")
        .select("customer_organization"),
      supabase.from("tickets").select("team_name"),
    ]);

    if (advisorsResp.error || customersResp.error || teamsResp.error) {
      const error = advisorsResp.error ?? customersResp.error ?? teamsResp.error;
      console.error("Supabase ticket options error", error);
      return NextResponse.json(
        { message: "Erro ao buscar opções de filtro", details: error?.message },
        { status: 500 },
      );
    }

    const consultores = dedupe(
      (advisorsResp.data ?? []).map((row) => {
        const first = normalize(row.advisor_first_name);
        const last = normalize(row.advisor_last_name);
        if (first && last) return `${first} ${last}`;
        return first || last || normalize(row.advisor_email) || normalize(row.advisor_racfid);
      }),
    ).sort((a, b) => a.localeCompare(b, "pt-BR"));

    const clientes = dedupe(
      (customersResp.data ?? []).map((row) => normalize(row.customer_organization)),
    ).sort((a, b) => a.localeCompare(b, "pt-BR"));

    const equipes = dedupe(
      (teamsResp.data ?? []).map((row) => normalize(row.team_name)),
    ).sort((a, b) => a.localeCompare(b, "pt-BR"));

    return NextResponse.json({ consultores, clientes, equipes });
  } catch (err) {
    console.error("Unexpected error fetching ticket options", err);
    return NextResponse.json(
      { message: "Erro inesperado ao buscar opções de filtro" },
      { status: 500 },
    );
  }
}



================================================
FILE: src/app/auth/logout/route.ts
================================================
import { NextResponse } from "next/server";
import { createSupabaseServerClient } from "@/lib/supabase/server";

export async function POST(request: Request) {
  const supabase = await createSupabaseServerClient();
  const { error } = await supabase.auth.signOut();

  const redirectUrl = new URL("/login", request.url);

  if (error) {
    redirectUrl.searchParams.set(
      "error",
      "Não foi possível encerrar a sessão. Tente novamente."
    );
    return NextResponse.redirect(redirectUrl, { status: 303 });
  }

  redirectUrl.searchParams.set("message", "Você saiu da sua conta com segurança.");
  return NextResponse.redirect(redirectUrl, { status: 303 });
}



================================================
FILE: src/app/cronograma/cronograma-client.tsx
================================================
"use client";

import { useEffect, useMemo, useRef, useState } from "react";
import type { LatLngExpression, Map as LeafletMap } from "leaflet";
import { Badge } from "@/components/Badge";
import { ActionModal } from "@/components/ActionModal";
import { PageShell } from "@/components/PageShell";
import type { ActionDefinition, EventPayload } from "@/lib/events";

type ScheduleType =
  | "Inspecao"
  | "Revisao"
  | "Manutencao"
  | "Entrega"
  | "Treinamento"
  | "Visita"
  | "Instalacao";

type ScheduleStatus = "Confirmado" | "Pendente" | "Critico";

type ScheduleItem = {
  id: string;
  time: string;
  duration: string;
  title: string;
  client: string;
  location: string;
  lat: number;
  lng: number;
  consultant: string;
  type: ScheduleType;
  status: ScheduleStatus;
};

type BadgeTone = NonNullable<Parameters<typeof Badge>[0]["tone"]>;
type ScheduleAction = "mark_done";
type FortalezaStop = Pick<ScheduleItem, "location" | "lat" | "lng">;

type ScheduleDay = {
  id: string;
  label: string;
  dateLabel: string;
  tone: BadgeTone;
  items: ScheduleItem[];
};

const typeTone: Record<ScheduleType, BadgeTone> = {
  Inspecao: "sky",
  Revisao: "amber",
  Manutencao: "violet",
  Entrega: "emerald",
  Treinamento: "slate",
  Visita: "stone",
  Instalacao: "sky",
};

const statusTone: Record<ScheduleStatus, BadgeTone> = {
  Confirmado: "emerald",
  Pendente: "amber",
  Critico: "rose",
};

const weekDayIds = ["dom", "seg", "ter", "qua", "qui", "sex", "sab"] as const;

const FORTALEZA_CENTER: [number, number] = [-3.7319, -38.5267];
const FORTALEZA_ZOOM = 12;
const FORTALEZA_STOPS: FortalezaStop[] = [
  { location: "Meireles / Fortaleza - CE", lat: -3.7298, lng: -38.4977 },
  { location: "Aldeota / Fortaleza - CE", lat: -3.7463, lng: -38.4998 },
  { location: "Varjota / Fortaleza - CE", lat: -3.7386, lng: -38.4868 },
  { location: "Praia de Iracema / Fortaleza - CE", lat: -3.7196, lng: -38.5176 },
  { location: "Benfica / Fortaleza - CE", lat: -3.7409, lng: -38.5326 },
  { location: "Papicu / Fortaleza - CE", lat: -3.7368, lng: -38.4737 },
  { location: "Montese / Fortaleza - CE", lat: -3.7711, lng: -38.5311 },
  { location: "Centro / Fortaleza - CE", lat: -3.7295, lng: -38.5273 },
  { location: "Coco / Fortaleza - CE", lat: -3.7551, lng: -38.4732 },
  { location: "Dionisio Torres / Fortaleza - CE", lat: -3.7482, lng: -38.5001 },
  { location: "Edson Queiroz / Fortaleza - CE", lat: -3.7852, lng: -38.4753 },
  { location: "Cidade 2000 / Fortaleza - CE", lat: -3.7472, lng: -38.4562 },
  { location: "Messejana / Fortaleza - CE", lat: -3.8222, lng: -38.4925 },
  { location: "Maraponga / Fortaleza - CE", lat: -3.7769, lng: -38.5628 },
  { location: "Barra do Ceara / Fortaleza - CE", lat: -3.7081, lng: -38.5907 },
  { location: "Passare / Fortaleza - CE", lat: -3.8112, lng: -38.5173 },
];

const SCHEDULE_ACTIONS: ActionDefinition<ScheduleAction>[] = [
  {
    id: "mark_done",
    label: "Marcar como feito",
    description: "Marca o agendamento como feito.",
    hideNote: true,
  },
];

const weekSchedule: ScheduleDay[] = [
  {
    id: "seg",
    label: "Segunda",
    dateLabel: "15 Jan",
    tone: "sky",
    items: [
      {
        id: "seg-1",
        time: "08:00",
        duration: "1h30",
        title: "Inspecao preventiva - D8T",
        client: "Construtora Vale",
        consultant: "Carlos Lima",
        type: "Inspecao",
        status: "Confirmado",
        ...FORTALEZA_STOPS[0],
      },
      {
        id: "seg-2",
        time: "10:30",
        duration: "1h",
        title: "Revisao de garantia - 320GX",
        client: "Mineradora Azul",
        consultant: "Marina Souza",
        type: "Revisao",
        status: "Pendente",
        ...FORTALEZA_STOPS[1],
      },
      {
        id: "seg-3",
        time: "14:00",
        duration: "2h",
        title: "Entrega de laudo - 140K",
        client: "Logistica Norte",
        consultant: "Carlos Lima",
        type: "Entrega",
        status: "Confirmado",
        ...FORTALEZA_STOPS[2],
      },
    ],
  },
  {
    id: "ter",
    label: "Terca",
    dateLabel: "16 Jan",
    tone: "sky",
    items: [
      {
        id: "ter-1",
        time: "09:00",
        duration: "2h",
        title: "Manutencao programada - 938K",
        client: "Construtora Delta",
        consultant: "Paulo Reis",
        type: "Manutencao",
        status: "Confirmado",
        ...FORTALEZA_STOPS[3],
      },
      {
        id: "ter-2",
        time: "13:30",
        duration: "1h",
        title: "Visita comercial - Frota CAT",
        client: "Transporte Sol",
        consultant: "Ana Cruz",
        type: "Visita",
        status: "Pendente",
        ...FORTALEZA_STOPS[4],
      },
    ],
  },
  {
    id: "qua",
    label: "Quarta",
    dateLabel: "17 Jan",
    tone: "sky",
    items: [
      {
        id: "qua-1",
        time: "07:30",
        duration: "1h",
        title: "Checklist de entrega - 320",
        client: "Terraplenagem Lima",
        consultant: "Juliana Prado",
        type: "Entrega",
        status: "Confirmado",
        ...FORTALEZA_STOPS[5],
      },
      {
        id: "qua-2",
        time: "09:30",
        duration: "1h30",
        title: "Treinamento operador - 950L",
        client: "Mina Serra",
        consultant: "Rafael Dias",
        type: "Treinamento",
        status: "Confirmado",
        ...FORTALEZA_STOPS[6],
      },
      {
        id: "qua-3",
        time: "13:00",
        duration: "2h",
        title: "Inspecao de seguranca - 336",
        client: "Pedreira Oeste",
        consultant: "Juliana Prado",
        type: "Inspecao",
        status: "Critico",
        ...FORTALEZA_STOPS[7],
      },
      {
        id: "qua-4",
        time: "16:00",
        duration: "1h",
        title: "Revisao pos-venda - 416F",
        client: "Agro Campo",
        consultant: "Rafael Dias",
        type: "Revisao",
        status: "Pendente",
        ...FORTALEZA_STOPS[8],
      },
    ],
  },
  {
    id: "qui",
    label: "Quinta",
    dateLabel: "18 Jan",
    tone: "sky",
    items: [
      {
        id: "qui-1",
        time: "08:30",
        duration: "1h",
        title: "Instalacao telemetria - D6R",
        client: "Construtora Horizonte",
        consultant: "Carlos Lima",
        type: "Instalacao",
        status: "Confirmado",
        ...FORTALEZA_STOPS[9],
      },
      {
        id: "qui-2",
        time: "15:30",
        duration: "1h30",
        title: "Manutencao emergencia - 988H",
        client: "Porto Seco",
        consultant: "Paulo Reis",
        type: "Manutencao",
        status: "Critico",
        ...FORTALEZA_STOPS[10],
      },
    ],
  },
  {
    id: "sex",
    label: "Sexta",
    dateLabel: "19 Jan",
    tone: "sky",
    items: [
      {
        id: "sex-1",
        time: "08:00",
        duration: "1h",
        title: "Revisao trimestral - 140M",
        client: "Prefeitura Sul",
        consultant: "Marina Souza",
        type: "Revisao",
        status: "Confirmado",
        ...FORTALEZA_STOPS[11],
      },
      {
        id: "sex-2",
        time: "11:00",
        duration: "2h",
        title: "Inspecao preventiva - 950H",
        client: "Rodovias Minas",
        consultant: "Ana Cruz",
        type: "Inspecao",
        status: "Confirmado",
        ...FORTALEZA_STOPS[12],
      },
      {
        id: "sex-3",
        time: "15:00",
        duration: "1h",
        title: "Visita de follow-up - 312D",
        client: "Rural Terra",
        consultant: "Ana Cruz",
        type: "Visita",
        status: "Pendente",
        ...FORTALEZA_STOPS[13],
      },
    ],
  },
  {
    id: "sab",
    label: "Sabado",
    dateLabel: "20 Jan",
    tone: "sky",
    items: [
      {
        id: "sab-1",
        time: "09:00",
        duration: "1h30",
        title: "Manutencao leve - 420F",
        client: "Cia Estradas",
        consultant: "Paulo Reis",
        type: "Manutencao",
        status: "Confirmado",
        ...FORTALEZA_STOPS[14],
      },
      {
        id: "sab-2",
        time: "11:30",
        duration: "1h",
        title: "Entrega de checklist - 320",
        client: "Construtora Vale",
        consultant: "Carlos Lima",
        type: "Entrega",
        status: "Confirmado",
        ...FORTALEZA_STOPS[15],
      },
    ],
  },
  {
    id: "dom",
    label: "Domingo",
    dateLabel: "21 Jan",
    tone: "sky",
    items: [],
  },
];

const totalAppointments = weekSchedule.reduce(
  (total, day) => total + day.items.length,
  0
);

function ScheduleCard({
  item,
  order,
  onSelect,
}: {
  item: ScheduleItem;
  order: number;
  onSelect: (item: ScheduleItem) => void;
}) {
  return (
    <div
      role="button"
      tabIndex={0}
      onClick={() => onSelect(item)}
      onKeyDown={(event) => {
        if (event.key === "Enter" || event.key === " ") {
          event.preventDefault();
          onSelect(item);
        }
      }}
      aria-label={`Abrir acoes do agendamento ${item.title}`}
      className="cursor-pointer rounded-xl border border-slate-200 bg-white p-2 text-left shadow-sm transition hover:border-slate-300 hover:shadow"
    >
      <div className="flex items-start justify-between gap-1.5">
        <div className="flex items-start gap-1.5">
          <input
            type="checkbox"
            defaultChecked={item.status === "Confirmado"}
            aria-label={`Marcar agendamento ${item.title}`}
            onClick={(event) => event.stopPropagation()}
            onKeyDown={(event) => event.stopPropagation()}
            className="mt-0.5 h-3 w-3 rounded border-slate-300 text-sky-600 focus:ring-sky-500"
          />
          <Badge tone="slate">#{order}</Badge>
        </div>
        <div className="text-right text-[10px] text-slate-400">
          <div className="font-semibold text-slate-600">{item.time}</div>
          <div>{item.duration}</div>
        </div>
      </div>

      <div className="mt-2 min-w-0">
        <div className="text-xs font-semibold text-slate-900 line-clamp-2">
          {item.title}
        </div>
        <div className="mt-0.5 text-[11px] text-slate-500 line-clamp-2">
          {item.client}
        </div>
      </div>

      <div className="mt-2 flex flex-wrap gap-1">
        <Badge tone={typeTone[item.type]}>{item.type}</Badge>
        <Badge tone={statusTone[item.status]}>{item.status}</Badge>
      </div>

      <div className="mt-2 space-y-0.5 text-[11px] text-slate-600">
        <div>{item.location}</div>
        <div>Consultor: {item.consultant}</div>
      </div>
    </div>
  );
}

type RoutingControlOptions = {
  waypoints: LatLngExpression[];
  show: boolean;
  addWaypoints: boolean;
  routeWhileDragging: boolean;
  draggableWaypoints: boolean;
  fitSelectedRoutes: boolean;
  lineOptions?: {
    styles: Array<{ color: string; weight: number; opacity: number }>;
  };
};

type RoutingControl = {
  addTo: (map: LeafletMap) => RoutingControl;
  setWaypoints: (waypoints: LatLngExpression[]) => void;
  remove: () => void;
};

type LeafletWithRouting = typeof import("leaflet") & {
  Routing?: {
    control: (options: RoutingControlOptions) => RoutingControl;
  };
};

type ScheduleMapViewProps = {
  points: ScheduleItem[];
  visible: boolean;
};

function ScheduleMapView({ points, visible }: ScheduleMapViewProps) {
  const containerRef = useRef<HTMLDivElement | null>(null);
  const mapRef = useRef<LeafletMap | null>(null);
  const routingRef = useRef<RoutingControl | null>(null);
  const leafletRef = useRef<LeafletWithRouting | null>(null);

  useEffect(() => {
    let mounted = true;

    const initMap = async () => {
      if (!containerRef.current || mapRef.current) return;

      await import("leaflet/dist/leaflet-src.js");
      await import("leaflet-routing-machine/dist/leaflet-routing-machine.js");

      const L = (globalThis as typeof globalThis & {
        L?: LeafletWithRouting;
      }).L;

      if (!L?.Routing?.control) {
        throw new Error("Leaflet Routing Machine not available.");
      }

      if (!mounted || !containerRef.current) return;

      L.Icon.Default.mergeOptions({
        iconRetinaUrl: "/leaflet/marker-icon-2x.png",
        iconUrl: "/leaflet/marker-icon.png",
        shadowUrl: "/leaflet/marker-shadow.png",
      });

      const map = L.map(containerRef.current, {
        center: FORTALEZA_CENTER,
        zoom: FORTALEZA_ZOOM,
        scrollWheelZoom: true,
      });

      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        attribution: "&copy; OpenStreetMap contributors",
      }).addTo(map);

      const routing = L.Routing.control({
        waypoints: [],
        show: false,
        addWaypoints: false,
        routeWhileDragging: false,
        draggableWaypoints: false,
        fitSelectedRoutes: true,
        lineOptions: {
          styles: [{ color: "#0ea5e9", weight: 4, opacity: 0.85 }],
        },
      }).addTo(map);

      mapRef.current = map;
      routingRef.current = routing;
      leafletRef.current = L;
    };

    void initMap();

    return () => {
      mounted = false;
      if (mapRef.current) {
        mapRef.current.remove();
        mapRef.current = null;
      }
      if (routingRef.current) {
        routingRef.current.remove();
        routingRef.current = null;
      }
      leafletRef.current = null;
    };
  }, []);

  useEffect(() => {
    const map = mapRef.current;
    const routing = routingRef.current;
    if (!map || !routing) return;

    if (!points.length) {
      routing.setWaypoints([]);
      map.setView(FORTALEZA_CENTER, FORTALEZA_ZOOM);
      return;
    }

    const waypoints = points.map(
      (point) => [point.lat, point.lng] as LatLngExpression
    );
    routing.setWaypoints(waypoints);
  }, [points]);

  useEffect(() => {
    if (!visible) return;
    const map = mapRef.current;
    if (!map) return;
    const timeoutId = window.setTimeout(() => {
      map.invalidateSize();
    }, 0);
    return () => window.clearTimeout(timeoutId);
  }, [visible]);

  const overlayMessage =
    points.length === 0
      ? "Nenhum agendamento para esse dia."
      : points.length === 1
        ? "Somente um agendamento para esse dia."
        : null;

  return (
    <div className="relative overflow-hidden rounded-xl border border-slate-200 bg-white shadow-sm">
      <div ref={containerRef} className="h-[520px] w-full bg-slate-100" />
      {overlayMessage ? (
        <div className="pointer-events-none absolute inset-0 flex items-center justify-center">
          <div className="rounded-lg border border-slate-200 bg-white/90 px-4 py-2 text-xs font-semibold text-slate-600 shadow-sm">
            {overlayMessage}
          </div>
        </div>
      ) : null}
    </div>
  );
}

export default function CronogramaClient() {
  const todayId = weekDayIds[new Date().getDay()];
  const [selectedItem, setSelectedItem] = useState<ScheduleItem | null>(null);
  const [actionOpen, setActionOpen] = useState(false);
  const [actionLoading, setActionLoading] = useState(false);
  const [actionError, setActionError] = useState<string | null>(null);
  const [viewMode, setViewMode] = useState<"board" | "map">("board");
  const [selectedDayId, setSelectedDayId] =
    useState<ScheduleDay["id"]>(todayId);

  const selectedDay = useMemo(
    () => weekSchedule.find((day) => day.id === selectedDayId) ?? weekSchedule[0],
    [selectedDayId]
  );

  const handleSelectItem = (item: ScheduleItem) => {
    setSelectedItem(item);
    setActionOpen(true);
  };

  const handleCloseAction = () => {
    setActionOpen(false);
    setActionError(null);
    setSelectedItem(null);
  };

  const handleConfirmAction = async (
    action: ScheduleAction,
    _payload: EventPayload
  ) => {
    if (!selectedItem) return;

    setActionLoading(true);
    setActionError(null);
    try {
      if (action === "mark_done") {
        setActionOpen(false);
        setSelectedItem(null);
      }
    } catch (error) {
      console.error(error);
      setActionError("Nao foi possivel registrar a acao.");
    } finally {
      setActionLoading(false);
    }
  };

  return (
    <PageShell
      title="Cronograma semanal"
      subtitle="Agendamentos mockados por dia, em ordem de execucao."
    >
      <div className="rounded-xl border border-slate-200 bg-slate-50 p-3 shadow-sm">
        <div className="flex flex-col gap-2">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <div className="flex items-center gap-2 text-[11px] font-semibold uppercase tracking-wide text-slate-500">
              <span>Semana atual</span>
              <span>{totalAppointments} agendamentos</span>
            </div>
            <div className="inline-flex items-center gap-1 rounded-lg border border-slate-200 bg-white p-0.5 text-[11px] font-semibold">
              {[
                { id: "board", label: "Quadro" },
                { id: "map", label: "Mapa" },
              ].map((tab) => {
                const isActive = viewMode === tab.id;
                return (
                  <button
                    key={tab.id}
                    type="button"
                    onClick={() =>
                      setViewMode(tab.id as "board" | "map")
                    }
                    className={`rounded-md px-2 py-1 transition ${
                      isActive
                        ? "bg-sky-100 text-sky-800"
                        : "bg-transparent text-slate-600 hover:bg-slate-50 hover:text-slate-900"
                    }`}
                  >
                    {tab.label}
                  </button>
                );
              })}
            </div>
          </div>

          <div className="flex flex-wrap gap-1">
            {weekSchedule.map((day) => {
              const isActive = day.id === selectedDayId;
              const isToday = day.id === todayId;
              return (
                <button
                  key={day.id}
                  type="button"
                  onClick={() => setSelectedDayId(day.id)}
                  className={`rounded-lg border px-2 py-1 text-[11px] font-semibold transition ${
                    isActive
                      ? "border-sky-300 bg-sky-100 text-sky-800"
                      : "border-slate-200 bg-white text-slate-600 hover:bg-slate-50 hover:text-slate-900"
                  } ${isToday ? "ring-1 ring-emerald-200" : ""}`}
                >
                  <span>{day.label}</span>
                  <span className="ml-1 text-[10px] text-slate-400">
                    {day.items.length}
                  </span>
                </button>
              );
            })}
          </div>
        </div>

        {viewMode === "board" ? (
          <div className="mt-3 overflow-x-auto pb-1">
            <div className="flex min-w-full gap-1">
              {weekSchedule.map((day) => {
                const isToday = day.id === todayId;

                return (
                  <div
                    key={day.id}
                    className={`min-w-[170px] max-w-[220px] flex-1 rounded-xl border p-1 ${
                      isToday
                        ? "border-sky-200 bg-sky-100/80"
                        : "border-transparent"
                    }`}
                  >
                    <div
                      className={`flex items-center justify-between rounded-lg border px-2 py-1.5 shadow-sm ${
                        isToday
                          ? "border-sky-200 bg-sky-50 ring-2 ring-sky-200"
                          : "border-slate-200 bg-white"
                      }`}
                    >
                      <div className="space-y-0.5">
                        <div className="flex flex-wrap items-center gap-1">
                          <Badge tone={day.tone}>{day.label}</Badge>
                          {isToday ? <Badge tone="emerald">Hoje</Badge> : null}
                        </div>
                        <div className="text-[11px] text-slate-500">
                          {day.dateLabel}
                        </div>
                      </div>
                      <span className="text-[11px] font-semibold text-slate-500">
                        {day.items.length}
                      </span>
                    </div>

                    <div className="mt-2 space-y-2">
                      {day.items.length ? (
                        day.items.map((item, index) => (
                          <ScheduleCard
                            key={item.id}
                            item={item}
                            order={index + 1}
                            onSelect={handleSelectItem}
                          />
                        ))
                      ) : (
                        <div className="rounded-lg border border-dashed border-slate-200 bg-white px-2 py-4 text-center text-[11px] text-slate-400">
                          Sem agendamentos.
                        </div>
                      )}
                    </div>
                  </div>
                );
              })}
            </div>
          </div>
        ) : (
          <div className="mt-3">
            <ScheduleMapView
              points={selectedDay?.items ?? []}
              visible={viewMode === "map"}
            />
          </div>
        )}
      </div>

      <ActionModal<ScheduleAction>
        open={actionOpen}
        entity="lead"
        actions={SCHEDULE_ACTIONS}
        defaultAction="mark_done"
        onClose={handleCloseAction}
        onConfirm={handleConfirmAction}
        loading={actionLoading}
        error={actionError}
      />
    </PageShell>
  );
}



================================================
FILE: src/app/cronograma/page.tsx
================================================
import { RequireAuth } from "@/components/RequireAuth";
import CronogramaClient from "./cronograma-client";

export default function CronogramaPage() {
  return (
    <RequireAuth>
      <CronogramaClient />
    </RequireAuth>
  );
}



================================================
FILE: src/app/home/home-client.tsx
================================================
"use client";

import { useEffect, useMemo, useState, useCallback } from "react";
import { LeadDetailsAside } from "@/components/LeadDetailsAside";
import { LeadsKanban } from "@/components/LeadsKanban";
import { MetricCard } from "@/components/MetricCard";
import { PageShell } from "@/components/PageShell";
import { getUserDisplayName, useAuth } from "@/contexts/AuthContext";
import { fetchLeads } from "@/lib/api";
import type { Lead } from "@/lib/domain";
import {
  FiltersState,
  INITIAL_FILTERS,
  LEAD_STATUS_OPTIONS,
} from "@/lib/filters";
import {
  FILTER_STORAGE_KEYS,
  loadLeadFilters,
  saveFilters,
} from "@/lib/filterStorage";

const PAGE_SIZE = 20;
const HOME_STATUS_OPTIONS = LEAD_STATUS_OPTIONS.filter(
  (option) => option.value !== "novo"
);
const HOME_DEFAULT_STATUS = [
  "atribuido",
  "em contato",
  "fechado_com_os",
  "fechado_sem_os",
];
const HOME_INITIAL_FILTERS: FiltersState = {
  ...INITIAL_FILTERS,
  status: HOME_DEFAULT_STATUS,
};

const areStatusListsEqual = (a: string[], b: string[]) => {
  if (a.length !== b.length) return false;
  return a.every((value, index) => value === b[index]);
};

const sanitizeHomeFilters = (stored: FiltersState): FiltersState => {
  const allowedStatuses = new Set<string>(
    HOME_STATUS_OPTIONS.map((option) => option.value)
  );
  const cleanedStatus = (stored.status ?? []).filter((status) =>
    allowedStatuses.has(status)
  );
  const shouldUpgradeDefaults = areStatusListsEqual(
    stored.status ?? [],
    INITIAL_FILTERS.status
  );
  const nextStatus = shouldUpgradeDefaults ? HOME_DEFAULT_STATUS : cleanedStatus;

  return {
    ...stored,
    status: nextStatus,
  };
};

export default function HomeClient() {
  const { user } = useAuth();
  const consultor = useMemo(() => getUserDisplayName(user), [user]);
  const [filters, setFilters] =
    useState<FiltersState>(HOME_INITIAL_FILTERS);
  const [filtersReady, setFiltersReady] = useState(false);
  const [leads, setLeads] = useState<Lead[]>([]);
  const [leadsTotal, setLeadsTotal] = useState(0);
  const [leadMetrics, setLeadMetrics] = useState({
    assigned: 0,
    emContato: 0,
  });
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [selectedLead, setSelectedLead] = useState<Lead | null>(null);
  const [leadDetailsOpen, setLeadDetailsOpen] = useState(false);

  const consultorFilter = consultor?.trim() ?? "";

  useEffect(() => {
    const stored = loadLeadFilters(
      FILTER_STORAGE_KEYS.home,
      HOME_INITIAL_FILTERS
    );
    setFilters(sanitizeHomeFilters(stored));
    setFiltersReady(true);
  }, []);

  useEffect(() => {
    if (!filtersReady) {
      return;
    }
    saveFilters(FILTER_STORAGE_KEYS.home, filters);
  }, [filters, filtersReady]);

  const loadLeads = useCallback(
    async (nextFilters: FiltersState) => {
      setLoading(true);
      setError(null);
      try {
        const baseParams = {
          page: 1,
          pageSize: PAGE_SIZE,
          consultor: consultorFilter,
          ...nextFilters,
        };
        const [response, assignedResp, emContatoResp] = await Promise.all([
          fetchLeads(baseParams),
          fetchLeads({
            ...baseParams,
            pageSize: 1,
            status: ["atribuido"],
          }),
          fetchLeads({
            ...baseParams,
            pageSize: 1,
            status: ["em contato"],
          }),
        ]);
        setLeads(response.items);
        setLeadsTotal(response.total);
        setLeadMetrics({
          assigned: assignedResp.total,
          emContato: emContatoResp.total,
        });
      } catch (err) {
        console.error(err);
        setError("Nao foi possivel carregar os leads.");
      } finally {
        setLoading(false);
      }
    },
    [consultorFilter]
  );

  useEffect(() => {
    if (!filtersReady) {
      return;
    }
    const timeoutId = window.setTimeout(() => {
      void loadLeads(filters);
    }, 400);
    return () => window.clearTimeout(timeoutId);
  }, [filters, loadLeads, filtersReady]);

  const handleLeadAssigned = useCallback((leadId: number, assignee: string) => {
    const updatedAt = new Date().toISOString();
    setLeads((prev) =>
      prev.map((lead) =>
        lead.id === leadId
          ? { ...lead, consultor: assignee, status: "atribuido", updatedAt }
          : lead
      )
    );
    setSelectedLead((prev) =>
      prev && prev.id === leadId
        ? { ...prev, consultor: assignee, status: "atribuido", updatedAt }
        : prev
    );
  }, []);

  return (
    <PageShell
      title="Home"
      subtitle="Resumo rapido dos seus leads e atividade recente."
    >
      {/* <div className="grid gap-4 md:grid-cols-3">
        <MetricCard
          label="Total de leads"
          value={leadsTotal}
          subtitle={
            consultorFilter ? `Consultor: ${consultorFilter}` : undefined
          }
        />
        <MetricCard
          label="Leads atribuidos"
          value={leadMetrics.assigned}
          subtitle="no total do consultor"
        />
        <MetricCard
          label="Leads em contato"
          value={leadMetrics.emContato}
          subtitle="no total do consultor"
        />
      </div> */}

      <div className="rounded-xl border border-slate-200 bg-white p-4 shadow-sm">
        <div className="flex items-center justify-between">
          <div className="text-sm font-semibold text-slate-900">
            {consultorFilter ? "Leads do consultor" : "Leads"}
          </div>
          <span className="text-xs text-slate-500">
            {leadsTotal} leads encontrados
          </span>
        </div>

        <div className="mt-4 space-y-3">
          {error ? (
            <div className="flex flex-col gap-3 rounded-lg border border-rose-200 bg-rose-50 p-4 text-sm text-rose-900">
              <span>{error}</span>
              <button
                type="button"
                onClick={() => loadLeads(filters)}
                className="inline-flex w-fit items-center gap-2 rounded-lg border border-rose-300 px-3 py-2 text-xs font-semibold text-rose-700 transition hover:border-rose-400 hover:text-rose-900"
              >
                Tentar novamente
              </button>
            </div>
          ) : null}

          <LeadsKanban
            leads={leads}
            filters={filters}
            onFiltersChange={setFilters}
            statusOptions={HOME_STATUS_OPTIONS}
            loading={loading}
            pageSize={PAGE_SIZE}
            onLeadSelect={(lead) => {
              setSelectedLead(lead);
              setLeadDetailsOpen(true);
            }}
          />
        </div>
      </div>

      {selectedLead ? (
        <LeadDetailsAside
          lead={selectedLead}
          open={leadDetailsOpen}
          onClose={() => setLeadDetailsOpen(false)}
          currentUserName={consultor}
          onLeadAssigned={handleLeadAssigned}
        />
      ) : null}
    </PageShell>
  );
}



================================================
FILE: src/app/home/page.tsx
================================================
import { RequireAuth } from "@/components/RequireAuth";
import HomeClient from "./home-client";

export default function HomePage() {
  return (
    <RequireAuth>
      <HomeClient />
    </RequireAuth>
  );
}



================================================
FILE: src/app/leads/import/leads-import-client.tsx
================================================
"use client";

import { useCallback, useMemo, useState, type ChangeEvent } from "react";
import { importLeads, type LeadImportItem } from "@/lib/api";
import { LeadTypesMultiSelect } from "@/components/LeadTypesMultiSelect";
import { PageShell } from "@/components/PageShell";
import { useToast } from "@/components/ToastProvider";

type LeadImportRow = {
  id: string;
  regional: string;
  estado: string;
  city: string;
  consultor: string;
  nomeContato: string;
  telefone: string;
  clienteBaseEnriquecida: string;
  chassi: string;
  horimetroAtualMachineList: string;
  leadTipos: string[];
};

type ColumnKey = Exclude<keyof LeadImportRow, "id">;
type LeadImportCellValue = LeadImportRow[ColumnKey];

type ColumnDef = {
  key: ColumnKey;
  label: string;
  widthClass: string;
  type: "text" | "number" | "datetime" | "multi";
};

const LEAD_TYPE_OPTIONS = [
  "preventiva",
  "garantia_basica",
  "garantia_estendida",
  "reforma_componentes",
  "lamina",
  "dentes",
  "rodante",
  "disponibilidade",
  "reconexao",
  "transferencia_aor",
  "pops",
  "outros",
];

const COLUMNS: ColumnDef[] = [
  { key: "regional", label: "Regional", widthClass: "w-[6%]", type: "text" },
  { key: "estado", label: "Estado", widthClass: "w-[5%]", type: "text" },
  { key: "city", label: "Cidade", widthClass: "w-[8%]", type: "text" },
  { key: "consultor", label: "Consultor", widthClass: "w-[10%]", type: "text" },
  { key: "clienteBaseEnriquecida", label: "Cliente", widthClass: "w-[14%]", type: "text" },
  { key: "nomeContato", label: "Contato", widthClass: "w-[10%]", type: "text" },
  { key: "telefone", label: "Telefone", widthClass: "w-[10%]", type: "text" },
  { key: "chassi", label: "Chassi", widthClass: "w-[7%]", type: "text" },
  { key: "horimetroAtualMachineList", label: "Horimetro", widthClass: "w-[7%]", type: "number" },
  { key: "leadTipos", label: "Tipos do lead", widthClass: "w-[15%]", type: "multi" },
];

const makeId = () => {
  if (typeof crypto !== "undefined" && "randomUUID" in crypto) {
    return crypto.randomUUID();
  }
  return `${Date.now()}-${Math.random().toString(16).slice(2)}`;
};

const createEmptyRow = (): LeadImportRow => ({
  id: makeId(),
  regional: "",
  estado: "",
  city: "",
  consultor: "",
  nomeContato: "",
  telefone: "",
  clienteBaseEnriquecida: "",
  chassi: "",
  horimetroAtualMachineList: "",
  leadTipos: [],
});

const isRowEmpty = (row: LeadImportRow) => {
  return COLUMNS.every((col) => {
    const value = row[col.key];
    if (Array.isArray(value)) return value.length === 0;
    return value.trim() === "";
  });
};

const toPayloadItem = (row: LeadImportRow): LeadImportItem => ({
  regional: row.regional.trim() || null,
  estado: row.estado.trim() || null,
  city: row.city.trim() || null,
  consultor: row.consultor.trim() || null,
  nomeContato: row.nomeContato.trim() || null,
  telefone: row.telefone.trim() || null,
  clienteBaseEnriquecida: row.clienteBaseEnriquecida.trim() || null,
  chassi: row.chassi.trim() || null,
  horimetroAtualMachineList: row.horimetroAtualMachineList.trim() || null,
  leadTipos: row.leadTipos.length ? row.leadTipos : null,
});

export default function LeadsImportClient() {
  const toast = useToast();
  const [rows, setRows] = useState<LeadImportRow[]>([
    createEmptyRow(),
    createEmptyRow(),
    createEmptyRow(),
    createEmptyRow(),
    createEmptyRow(),
  ]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const filledRowsCount = useMemo(
    () => rows.filter((row) => !isRowEmpty(row)).length,
    [rows],
  );

  const handleCellChange = useCallback(
    (rowId: string, key: ColumnKey, value: LeadImportCellValue) => {
      setRows((prev) =>
        prev.map((row) => (row.id === rowId ? { ...row, [key]: value } : row)),
      );
    },
    [],
  );

  const addRows = (count: number) => {
    setRows((prev) => [
      ...prev,
      ...Array.from({ length: count }, () => createEmptyRow()),
    ]);
  };

  const removeRow = (rowId: string) => {
    setRows((prev) => prev.filter((row) => row.id !== rowId));
  };

  const removeEmptyRows = () => {
    setRows((prev) => prev.filter((row) => !isRowEmpty(row)));
  };

  const handleImport = async () => {
    setError(null);
    setLoading(true);
    try {
      const payload = rows
        .filter((row) => !isRowEmpty(row))
        .map(toPayloadItem);

      if (!payload.length) {
        setError("Nenhuma linha preenchida para importar.");
        setLoading(false);
        return;
      }

      const response = await importLeads(payload);
      toast.push({
        variant: "success",
        message: `Importacao concluida. Leads inseridos: ${response.inserted}.`,
      });
      setRows([
        createEmptyRow(),
        createEmptyRow(),
        createEmptyRow(),
        createEmptyRow(),
        createEmptyRow(),
      ]);
    } catch (err) {
      const message =
        err instanceof Error && err.message
          ? err.message
          : "Nao foi possivel importar os leads.";
      setError(message);
      toast.push({ variant: "error", message });
    } finally {
      setLoading(false);
    }
  };

  return (
    <PageShell
      title="Insercao de leads"
      subtitle="Preencha as colunas do lead e importe como em uma planilha."
    >
      <div className="rounded-xl border border-slate-200 bg-white p-4 shadow-sm">
        <div className="flex flex-col gap-3 md:flex-row md:items-center md:justify-between">
          <div>
            <h2 className="text-sm font-semibold text-slate-900">
              Planilha de leads
            </h2>
            <p className="text-xs text-slate-500">
              {filledRowsCount} linhas preenchidas
            </p>
          </div>

          <div className="flex flex-wrap items-center gap-2">
            <button
              type="button"
              onClick={() => addRows(1)}
              className="rounded-lg border border-slate-200 bg-white px-3 py-2 text-xs font-semibold text-slate-700 transition hover:border-slate-300 hover:text-slate-900"
            >
              Adicionar linha
            </button>
            <button
              type="button"
              onClick={() => addRows(5)}
              className="rounded-lg border border-slate-200 bg-white px-3 py-2 text-xs font-semibold text-slate-700 transition hover:border-slate-300 hover:text-slate-900"
            >
              Adicionar 5 linhas
            </button>
            <button
              type="button"
              onClick={removeEmptyRows}
              className="rounded-lg border border-slate-200 bg-white px-3 py-2 text-xs font-semibold text-slate-700 transition hover:border-slate-300 hover:text-slate-900"
            >
              Remover vazias
            </button>
            <button
              type="button"
              onClick={handleImport}
              disabled={loading}
              className="rounded-lg bg-slate-900 px-4 py-2 text-xs font-semibold uppercase tracking-wide text-white transition hover:bg-slate-800 disabled:cursor-not-allowed disabled:opacity-60"
            >
              {loading ? "Importando..." : "Importar leads"}
            </button>
          </div>
        </div>

        {error ? (
          <div className="mt-3 rounded-lg border border-rose-200 bg-rose-50 px-4 py-3 text-sm text-rose-900">
            {error}
          </div>
        ) : null}

        <div className="mt-4 overflow-visible">
          <table className="w-full table-fixed border-separate border-spacing-0 text-xs">
            <thead>
              <tr>
                {COLUMNS.map((col) => (
                  <th
                    key={col.key}
                    className={`sticky top-0 min-w-0 border-b border-slate-200 bg-slate-50 px-2 py-2 text-left font-semibold text-slate-600 ${col.widthClass}`}
                  >
                    {col.label}
                  </th>
                ))}
                <th className="sticky top-0 min-w-0 w-[10%] border-b border-slate-200 bg-slate-50 px-2 py-2 text-left font-semibold text-slate-600">
                  Acoes
                </th>
              </tr>
            </thead>
            <tbody>
              {rows.map((row) => (
                <tr key={row.id} className="border-b border-slate-100">
                  {COLUMNS.map((col) => {
                    const value = row[col.key];
                    const inputValue = Array.isArray(value) ? "" : value;
                    const commonProps = {
                      value: inputValue,
                      onChange: (event: ChangeEvent<HTMLInputElement | HTMLSelectElement>) =>
                        handleCellChange(row.id, col.key, event.target.value),
                      className:
                        "w-full rounded-md border border-slate-200 bg-white px-2 py-1 text-[11px] text-slate-900 outline-none focus:border-sky-400 focus:ring-2 focus:ring-sky-100",
                    };

                    return (
                      <td key={col.key} className="min-w-0 px-2 py-2 align-top">
                        {col.type === "multi" ? (
                          <LeadTypesMultiSelect
                            value={Array.isArray(value) ? value : []}
                            options={LEAD_TYPE_OPTIONS}
                            onChange={(next) =>
                              handleCellChange(row.id, col.key, next)
                            }
                            placeholder="Selecionar tipos"
                          />
                        ) : col.type === "datetime" ? (
                          <input {...commonProps} type="datetime-local" />
                        ) : (
                          <input {...commonProps} type={col.type} />
                        )}
                      </td>
                    );
                  })}
                  <td className="px-2 py-2 align-top">
                    <button
                      type="button"
                      onClick={() => removeRow(row.id)}
                      className="rounded-md border border-slate-200 bg-white px-2 py-1 text-[11px] font-semibold text-slate-600 transition hover:border-slate-300 hover:text-slate-900"
                    >
                      Remover
                    </button>
                  </td>
                </tr>
              ))}
              {rows.length === 0 ? (
                <tr>
                  <td
                    colSpan={COLUMNS.length + 1}
                    className="px-3 py-6 text-center text-sm text-slate-500"
                  >
                    Nenhuma linha adicionada. Clique em "Adicionar linha".
                  </td>
                </tr>
              ) : null}
            </tbody>
          </table>
        </div>
      </div>
    </PageShell>
  );
}



================================================
FILE: src/app/leads/import/page.tsx
================================================
import { RequireAuth } from "@/components/RequireAuth";
import LeadsImportClient from "./leads-import-client";

export default function LeadsImportPage() {
  return (
    <RequireAuth>
      <LeadsImportClient />
    </RequireAuth>
  );
}



================================================
FILE: src/app/login/login-client.tsx
================================================
"use client";

import { useMemo, useState, type FormEvent } from "react";
import { useRouter, useSearchParams } from "next/navigation";
import { createSupabaseBrowserClient } from "@/lib/supabaseClient";

type BannerState =
  | { variant: "error"; message: string }
  | { variant: "success"; message: string }
  | null;

export default function LoginClient() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const supabase = useMemo(() => createSupabaseBrowserClient(), []);

  const queryBanner = useMemo<BannerState | null>(() => {
    const error = searchParams.get("error");
    const message = searchParams.get("message");
    if (error) return { variant: "error", message: error };
    if (message) return { variant: "success", message };
    return null;
  }, [searchParams]);

  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [banner, setBanner] = useState<BannerState | null | undefined>();
  const [loading, setLoading] = useState(false);

  const activeBanner = banner === undefined ? queryBanner : banner;

  const handlePasswordSignIn = async (event: FormEvent<HTMLFormElement>) => {
    event.preventDefault();
    setBanner(null);
    setLoading(true);

    const { error } = await supabase.auth.signInWithPassword({
      email,
      password,
    });

    setLoading(false);

    if (error) {
      setBanner({
        variant: "error",
        message:
          error.message ||
          "Não foi possível entrar com email e senha. Verifique os dados e tente novamente.",
      });
      return;
    }

    router.replace("/");
    router.refresh();
  };

  return (
    <div className="flex min-h-[calc(100vh-120px)] items-center justify-center bg-gradient-to-br from-slate-100 via-white to-slate-100 px-4 py-10">
      <div className="w-full max-w-xl overflow-hidden rounded-3xl border border-slate-200 bg-white shadow-2xl shadow-slate-200">
        <div className="grid gap-6 bg-gradient-to-br from-sky-600 to-indigo-700 px-8 py-10 text-white md:grid-cols-[1.1fr_1fr] md:gap-0">
          <div className="flex flex-col justify-between gap-6">
            <div className="space-y-3">
              <p className="text-sm font-semibold uppercase tracking-[0.2em] text-white/70">
                Leads & Tickets
              </p>
              <h1 className="text-3xl font-semibold leading-tight">
                Acesse o painel seguro
              </h1>
              <p className="text-sm text-white/80">
                Entre para visualizar dashboards e métricas privadas sem
                flicker.
              </p>
            </div>
            <div className="rounded-2xl bg-white/10 p-4 text-sm text-white/90 shadow-inner">
              Sessões são preservadas com cookies seguros. Faça login para
              acessar o dashboard.
            </div>
          </div>

          <div className="rounded-2xl border border-white/30 bg-white p-6 text-slate-900 shadow-lg shadow-indigo-100/50">
            <div className="space-y-4">
              <div>
                <p className="text-sm font-semibold text-slate-900">
                  Faça login
                </p>
                <p className="text-xs text-slate-500">Entre com email e senha.</p>
              </div>

              {activeBanner && (
                <div
                  className={`rounded-2xl border px-4 py-3 text-sm ${
                    activeBanner.variant === "error"
                      ? "border-rose-200 bg-rose-50 text-rose-800"
                      : "border-emerald-200 bg-emerald-50 text-emerald-800"
                  }`}
                >
                  {activeBanner.message}
                </div>
              )}

              <form className="space-y-4" onSubmit={handlePasswordSignIn}>
                <label className="space-y-2 text-sm font-medium text-slate-700">
                  <span>Email</span>
                  <input
                    type="email"
                    value={email}
                    onChange={(event) => setEmail(event.target.value)}
                    className="w-full rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm font-normal text-slate-900 shadow-inner shadow-slate-50 outline-none transition focus:border-sky-400 focus:ring-4 focus:ring-sky-100"
                    placeholder="seu@email.com"
                    required
                  />
                </label>

                <label className="space-y-2 text-sm font-medium text-slate-700">
                  <span>Senha</span>
                  <input
                    type="password"
                    value={password}
                    onChange={(event) => setPassword(event.target.value)}
                    className="w-full rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm font-normal text-slate-900 shadow-inner shadow-slate-50 outline-none transition focus:border-sky-400 focus:ring-4 focus:ring-sky-100"
                    placeholder="********"
                    required
                  />
                </label>

                <button
                  type="submit"
                  disabled={loading}
                  className="flex w-full items-center justify-center gap-2 rounded-xl bg-slate-900 px-4 py-2 text-sm font-semibold text-white shadow-lg shadow-slate-300 transition hover:bg-slate-800 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-slate-900 disabled:cursor-not-allowed disabled:opacity-70"
                >
                  {loading ? "Entrando..." : "Entrar"}
                </button>
              </form>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}




================================================
FILE: src/app/login/page.tsx
================================================
import { Suspense } from "react";
import LoginClient from "./login-client";

export default function LoginPage() {
  return (
    <Suspense
      fallback={
        <div className="flex min-h-[calc(100vh-120px)] items-center justify-center px-4 py-10 text-sm text-slate-500">
          Carregando...
        </div>
      }
    >
      <LoginClient />
    </Suspense>
  );
}



================================================
FILE: src/app/metrics/metrics-client.tsx
================================================
"use client";

import { useCallback, useEffect, useMemo, useRef, useState } from "react";
import { PageShell } from "@/components/PageShell";
import { Tabs } from "@/components/Tabs";
import { MetricsTabs } from "@/components/MetricsTabs";
import { TimeRangeSelector } from "@/components/TimeRangeSelector";
import { LeadStatusMetricsView } from "@/components/LeadStatusMetricsView";
import {
  UserActionMetricsHeader,
  UserActionMetricsView,
} from "@/components/UserActionMetricsView";
import { LeadDetailsAside } from "@/components/LeadDetailsAside";
import {
  fetchLeadById,
  fetchLeadMetrics,
  fetchLeads,
  fetchTicketMetrics,
} from "@/lib/api";
import { Lead, TimeRange } from "@/lib/domain";
import { INITIAL_FILTERS } from "@/lib/filters";
import type {
  DailyActionMetricsRow,
  UserActionEventRow,
  UserActionMetricsRow,
  UserIdentity,
} from "@/lib/metrics";

type MetricsTab = "leads" | "tickets";
type MetricsViewMode = "actions" | "billing";
type MetricsScope = "general" | "individual";

const AGGREGATE_USER_ID = "__all__";

const aggregateMetrics = (
  rows: UserActionMetricsRow[],
  daily: DailyActionMetricsRow[],
  events: UserActionEventRow[],
) => {
  const actionsBreakdown: Record<string, number> = {};
  let totalActions = 0;
  let uniqueItems = 0;

  rows.forEach((row) => {
    totalActions += row.total_actions ?? 0;
    uniqueItems += row.unique_items ?? 0;
    Object.entries(row.actions_breakdown ?? {}).forEach(([action, count]) => {
      actionsBreakdown[action] = (actionsBreakdown[action] ?? 0) + count;
    });
  });

  const aggregatedRows = rows.length
    ? [
        {
          actor_user_id: AGGREGATE_USER_ID,
          actor_email: "",
          actor_name: "Geral",
          total_actions: totalActions,
          unique_items: uniqueItems,
          actions_breakdown: actionsBreakdown,
        },
      ]
    : [];

  const byDate = new Map<string, number>();
  daily.forEach((row) => {
    byDate.set(row.date, (byDate.get(row.date) ?? 0) + row.total_actions);
  });
  const aggregatedDaily = Array.from(byDate.entries())
    .sort(([dateA], [dateB]) => dateA.localeCompare(dateB))
    .map(([date, total]) => ({
      actor_user_id: AGGREGATE_USER_ID,
      date,
      total_actions: total,
    }));

  const aggregatedEvents = events.map((event) => ({
    ...event,
    actor_user_id: AGGREGATE_USER_ID,
  }));

  return {
    rows: aggregatedRows,
    daily: aggregatedDaily,
    events: aggregatedEvents,
  };
};

export default function MetricsClient() {
  const [scope, setScope] = useState<MetricsScope>("general");
  const [activeTab, setActiveTab] = useState<MetricsTab>("leads");
  const [timeRange, setTimeRange] = useState<TimeRange>("week");
  const [viewMode, setViewMode] = useState<MetricsViewMode>("actions");
  const [rows, setRows] = useState<UserActionMetricsRow[]>([]);
  const [daily, setDaily] = useState<DailyActionMetricsRow[]>([]);
  const [events, setEvents] = useState<UserActionEventRow[]>([]);
  const [generalLeads, setGeneralLeads] = useState<Lead[]>([]);
  const [generalStatusOptions, setGeneralStatusOptions] = useState<string[]>([]);
  const [generalSelectedStatuses, setGeneralSelectedStatuses] = useState<string[]>(
    () => [...INITIAL_FILTERS.status],
  );
  const [generalLeadsLoading, setGeneralLeadsLoading] = useState(false);
  const [generalLeadsError, setGeneralLeadsError] = useState<string | null>(null);
  const [selectedLead, setSelectedLead] = useState<Lead | null>(null);
  const [leadDetailsOpen, setLeadDetailsOpen] = useState(false);
  const [usersByTab, setUsersByTab] = useState<Record<MetricsTab, UserIdentity[]>>({
    leads: [],
    tickets: [],
  });
  const usersByTabRef = useRef(usersByTab);
  const generalLeadsRequestedRef = useRef(false);
  const [selectedUserByTab, setSelectedUserByTab] = useState<
    Record<MetricsTab, string | null>
  >({
    leads: null,
    tickets: null,
  });
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    usersByTabRef.current = usersByTab;
  }, [usersByTab]);

  const loadData = useCallback(async (includeUsers: boolean) => {
    setLoading(true);
    setError(null);
    try {
      const response =
        activeTab === "leads"
          ? await fetchLeadMetrics(timeRange, { includeUsers })
          : await fetchTicketMetrics(timeRange, { includeUsers });
      setRows(response.items);
      setDaily(response.daily);
      setEvents(response.events);
      if (includeUsers) {
        setUsersByTab((prev) => ({
          ...prev,
          [activeTab]: response.users,
        }));
      }
    } catch (err) {
      console.error(err);
      setError("Não foi possível carregar as métricas.");
    } finally {
      setLoading(false);
    }
  }, [activeTab, timeRange]);

  const loadGeneralLeads = useCallback(async () => {
    generalLeadsRequestedRef.current = true;
    setGeneralLeadsLoading(true);
    setGeneralLeadsError(null);
    try {
      const pageSize = 100;
      const first = await fetchLeads({ page: 1, pageSize, status: [] });
      const total = first.total ?? first.items.length;
      const totalPages = Math.max(1, Math.ceil(total / pageSize));
      const allItems = [...first.items];

      if (totalPages > 1) {
        const responses = await Promise.all(
          Array.from({ length: totalPages - 1 }, (_, index) =>
            fetchLeads({
              page: index + 2,
              pageSize,
              status: [],
            }),
          ),
        );
        responses.forEach((resp) => allItems.push(...resp.items));
      }

      setGeneralLeads(allItems);
      setGeneralStatusOptions(first.statusOptions ?? []);
    } catch (err) {
      console.error(err);
      setGeneralLeadsError("Nao foi possivel carregar os leads gerais.");
    } finally {
      setGeneralLeadsLoading(false);
    }
  }, []);

  useEffect(() => {
    const includeUsers =
      (usersByTabRef.current[activeTab] ?? []).length === 0;
    void loadData(includeUsers);
  }, [activeTab, loadData, timeRange]);

  useEffect(() => {
    if (scope !== "general" || activeTab !== "leads") return;
    if (generalLeadsRequestedRef.current) return;
    void loadGeneralLeads();
  }, [activeTab, loadGeneralLeads, scope]);

  const handleSelectedUserChange = useCallback(
    (id: string | null) => {
      setSelectedUserByTab((prev) => ({
        ...prev,
        [activeTab]: id,
      }));
    },
    [activeTab],
  );

  const handleLeadAssigned = useCallback((leadId: number, assignee: string) => {
    setSelectedLead((prev) =>
      prev && prev.id === leadId
        ? { ...prev, consultor: assignee, status: "atribuido" }
        : prev,
    );
  }, []);

  const handleActionEventClick = useCallback(
    async (event: UserActionEventRow) => {
      if (activeTab !== "leads") return;
      const leadId = Number(event.item_id);
      if (!Number.isFinite(leadId) || leadId <= 0) return;

      if (selectedLead?.id === leadId) {
        setLeadDetailsOpen(true);
        return;
      }

      try {
        const lead = await fetchLeadById(leadId);
        setSelectedLead(lead);
        setLeadDetailsOpen(true);
      } catch (err) {
        console.error(err);
      } finally {
      }
    },
    [activeTab, selectedLead?.id],
  );

  const aggregatedMetrics = useMemo(
    () => aggregateMetrics(rows, daily, events),
    [rows, daily, events],
  );

  const renderContent = () => {
    if (scope === "general" && activeTab === "leads" && viewMode === "actions") {
      return (
        <LeadStatusMetricsView
          leads={generalLeads}
          timeRange={timeRange}
          statusOptions={generalStatusOptions}
          selectedStatuses={generalSelectedStatuses}
          onSelectedStatusesChange={(next) => setGeneralSelectedStatuses(next)}
          loading={generalLeadsLoading}
          error={generalLeadsError}
          onRetry={loadGeneralLeads}
          onLeadSelect={(lead) => {
            setSelectedLead(lead);
            setLeadDetailsOpen(true);
          }}
        />
      );
    }

    if (loading) {
      return (
        <div className="rounded-xl border border-slate-200 bg-white p-6 text-sm text-slate-600 shadow-sm">
          Carregando métricas...
        </div>
      );
    }

    if (error) {
      return (
        <div className="flex flex-col gap-3 rounded-xl border border-rose-200 bg-rose-50 p-6 text-sm text-rose-900 shadow-sm">
          <span>{error}</span>
          <button
            type="button"
            onClick={() => {
              const includeUsers =
                (usersByTabRef.current[activeTab] ?? []).length === 0;
              void loadData(includeUsers);
            }}
            className="inline-flex w-fit items-center gap-2 rounded-lg border border-rose-300 px-3 py-2 text-xs font-semibold text-rose-700 transition hover:border-rose-400 hover:text-rose-900"
          >
            Tentar novamente
          </button>
        </div>
      );
    }

    const viewRows = scope === "general" ? aggregatedMetrics.rows : rows;
    const viewDaily = scope === "general" ? aggregatedMetrics.daily : daily;
    const viewEvents = scope === "general" ? aggregatedMetrics.events : events;
    const viewUsers = scope === "general" ? [] : usersByTab[activeTab] ?? [];
    const selectedUserId =
      scope === "general"
        ? AGGREGATE_USER_ID
        : selectedUserByTab[activeTab] ?? null;

    return (
      <UserActionMetricsView
        entity={activeTab}
        rows={viewRows}
        daily={viewDaily}
        events={viewEvents}
        users={viewUsers}
        selectedUserId={selectedUserId}
        range={timeRange}
        viewMode={viewMode}
        onActionEventClick={activeTab === "leads" ? handleActionEventClick : undefined}
      />
    );
  };

  return (
    <PageShell
      title="Métricas"
      subtitle="Visão rápida das volumetrias por período."
    >
      <div className="flex flex-col gap-4 rounded-xl border border-slate-200 bg-white p-4 shadow-sm">
        <div className="flex flex-col gap-3 md:flex-row md:items-center md:justify-between">
          <Tabs
            tabs={[
              { id: "general", label: "GERAL" },
              { id: "individual", label: "INDIVIDUAL" },
            ]}
            activeTabId={scope}
            onTabChange={(id) => setScope(id as MetricsScope)}
          />
          <form action="/auth/logout" method="post">
            <button
              type="submit"
              className="inline-flex items-center justify-center rounded-lg border border-slate-200 bg-white px-3 py-2 text-xs font-semibold uppercase tracking-wide text-slate-700 transition hover:border-slate-300 hover:text-slate-900"
            >
              Sair
            </button>
          </form>
        </div>
        <div className="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
          <MetricsTabs activeTabId={activeTab} onChange={setActiveTab} />
          <TimeRangeSelector activeRange={timeRange} onChange={setTimeRange} />
        </div>
        <p className="text-xs text-slate-500">
          Filtrando dados do período selecionado.
        </p>
        {scope === "individual" ? (
          <UserActionMetricsHeader
            rows={rows}
            users={usersByTab[activeTab] ?? []}
            selectedUserId={selectedUserByTab[activeTab] ?? null}
            onSelectedUserIdChange={handleSelectedUserChange}
          />
        ) : null}
        <div className="flex w-full items-center divide-x divide-slate-200 rounded-lg border border-slate-200 bg-white">
          {[
            { id: "actions", label: "Acoes" },
            { id: "billing", label: "Faturamento" },
          ].map((tab) => {
            const isActive = tab.id === viewMode;
            return (
              <button
                key={tab.id}
                type="button"
                onClick={() => setViewMode(tab.id as MetricsViewMode)}
                className={`flex-1 px-4 py-2 text-center text-sm font-semibold transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-300/80 focus-visible:z-10 first:rounded-l-lg last:rounded-r-lg ${
                  isActive
                    ? "bg-sky-100 text-sky-800"
                    : "bg-transparent text-slate-600 hover:bg-slate-50 hover:text-slate-900"
                }`}
              >
                {tab.label}
              </button>
            );
          })}
        </div>
        {renderContent()}
      </div>

      {selectedLead ? (
        <LeadDetailsAside
          lead={selectedLead}
          open={leadDetailsOpen}
          onClose={() => setLeadDetailsOpen(false)}
          onLeadAssigned={handleLeadAssigned}
        />
      ) : null}
    </PageShell>
  );
}



================================================
FILE: src/app/metrics/page.tsx
================================================
import { RequireAuth } from "@/components/RequireAuth";
import MetricsClient from "./metrics-client";

export default function MetricsPage() {
  return (
    <RequireAuth>
      <MetricsClient />
    </RequireAuth>
  );
}



================================================
FILE: src/components/ActionButtonCell.tsx
================================================
"use client";

import React, { useMemo, useState } from "react";
import type {
  ActionDefinition,
  ActionRole,
  EventPayload,
  LeadEventAction,
  TicketEventAction,
} from "@/lib/events";
import {
  LEAD_ACTION_DEFINITIONS,
  TICKET_ACTION_DEFINITIONS,
  isUuid,
} from "@/lib/events";
import { useCreateEvent } from "@/hooks/useCreateEvent";
import { ActionModal } from "@/components/ActionModal";
import { useToast } from "@/components/ToastProvider";

type LeadProps = {
  entity: "lead";
  leadId: number;
  leadStatus?: string | null;
  currentUserRole?: ActionRole;
  onLeadStatusChange?: (leadId: number, status: string) => void;
};

type TicketProps = {
  entity: "ticket";
  ticketId: string | null;
  ticketStatus?: string | null;
  currentUserRole?: ActionRole;
};

type ActionButtonCellProps = LeadProps | TicketProps;

const normalizeStatus = (value?: string | null) =>
  value?.trim().toLowerCase() ?? "";

const isRoleAllowed = (def: ActionDefinition<string>, role: ActionRole) => {
  if (!def.allowedRoles) return true;
  return def.allowedRoles.includes(role);
};

const isStatusAllowed = (
  def: ActionDefinition<string>,
  status?: string | null
) => {
  if (!def.allowedStatuses) return true;
  if (def.allowedStatuses.length === 0) return false;
  if (def.allowedStatuses.includes("*")) return true;
  const normalized = normalizeStatus(status);
  if (!normalized) return false;
  return def.allowedStatuses.some(
    (item) => item.trim().toLowerCase() === normalized
  );
};

export function ActionButtonCell(props: ActionButtonCellProps) {
  const toast = useToast();
  const { createLeadEvent, createTicketEvent, loading } = useCreateEvent();
  const [open, setOpen] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const currentRole: ActionRole = props.currentUserRole ?? "user";
  const currentStatus =
    props.entity === "lead" ? props.leadStatus : props.ticketStatus;

  const actions = useMemo(() => {
    const base =
      props.entity === "lead"
        ? LEAD_ACTION_DEFINITIONS
        : TICKET_ACTION_DEFINITIONS;
    return base.map((item) => {
      const roleAllowed = isRoleAllowed(item, currentRole);
      const statusAllowed = isStatusAllowed(item, currentStatus);
      return {
        ...item,
        disabled: Boolean(item.disabled) || !roleAllowed || !statusAllowed,
      };
    });
  }, [currentRole, currentStatus, props.entity]);

  const disabledReason =
    props.entity === "ticket" && (!props.ticketId || !isUuid(props.ticketId))
      ? "Ticket sem UUID válido"
      : null;

  const buttonLabel = "Ações";

  const onConfirm = async (
    action: LeadEventAction | TicketEventAction,
    payload: EventPayload
  ) => {
    setError(null);
    try {
      if (props.entity === "lead") {
        await createLeadEvent({
          leadId: props.leadId,
          action: action as LeadEventAction,
          payload,
        });
        const statusByAction: Partial<Record<LeadEventAction, string>> = {
          assign: "atribuido",
          register_contact: "em contato",
          discard: "descartado",
          close_without_os: "fechado_sem_os",
          close_with_os: "fechado_com_os",
        };
        const nextStatus = statusByAction[action as LeadEventAction];
        if (nextStatus) {
          props.onLeadStatusChange?.(props.leadId, nextStatus);
        }
      } else {
        if (!props.ticketId) {
          throw new Error("Ticket sem id vǭlido.");
        }
        await createTicketEvent({
          ticketId: props.ticketId,
          action: action as TicketEventAction,
          payload,
        });
      }

      toast.push({
        variant: "success",
        message: "Aǧǜo registrada com sucesso.",
      });
      setOpen(false);
    } catch (err: any) {
      const message =
        typeof err?.message === "string" && err.message
          ? err.message
          : "Nǜo foi possǭvel registrar aǧǜo.";
      setError(message);
      toast.push({ variant: "error", message });
    }
  };

  return (
    <>
      <button
        type="button"
        disabled={Boolean(disabledReason)}
        onClick={(e) => {
          e.stopPropagation();
          setError(null);
          setOpen(true);
        }}
        onMouseDown={(e) => e.stopPropagation()}
        className="inline-flex items-center gap-2 rounded-lg border border-slate-200 bg-white px-3 py-1.5 text-xs font-semibold text-slate-700 transition enabled:hover:border-slate-300 enabled:hover:text-slate-900 disabled:cursor-not-allowed disabled:opacity-60"
        title={disabledReason ?? "Registrar aǧǜo"}
      >
        {buttonLabel}
      </button>

      <ActionModal
        open={open}
        entity={props.entity}
        actions={actions as any}
        loading={loading}
        error={error}
        onClose={() => setOpen(false)}
        onConfirm={onConfirm as any}
      />
    </>
  );
}



================================================
FILE: src/components/ActionModal.tsx
================================================
﻿"use client";

import React, { useEffect, useMemo, useRef, useState } from "react";
import { createPortal } from "react-dom";
import {
  type ActionDefinition,
  type EventPayload,
  MAX_NOTE_CHARS,
  LEAD_ACTION_DEFINITIONS,
  TICKET_ACTION_DEFINITIONS,
} from "@/lib/events";

type EntityKind = "lead" | "ticket";

type ActionModalProps<Action extends string> = {
  open: boolean;
  entity: EntityKind;
  actions: ActionDefinition<Action>[];
  defaultAction?: Action;
  initialPayload?: EventPayload;
  onClose: () => void;
  onConfirm: (action: Action, payload: EventPayload) => Promise<void>;
  loading?: boolean;
  error?: string | null;
};

type ChangedFieldRow = { key: string; value: string };

const parseTags = (value: string): string[] =>
  value
    .split(",")
    .map((part) => part.trim())
    .filter(Boolean);

const CLOSE_WITHOUT_OS_REASONS = [
  "Preço da peça",
  "Preço da mão de obra",
  "Preço do deslocamento",
  "Indisponibilidade técnica",
  "Indisponibilidade de peça",
  "Experiência anterior negativa",
  "Mão de obra própria",
  "Mão de obra terceirizada",
  "Postergou o serviço",
  "Pendência financeira",
  "Falta de flexibilidade comercial",
] as const;

const LEAD_ACTION_MODAL_DESCRIPTIONS: Record<string, string> = {
  register_contact: "Registra o contato realizado.",
  assign: "Atribui o lead a um responsavel.",
  discard: "Descarta o lead (exige motivo).",
  close_without_os: "Fecha o lead sem OS (exige motivo).",
  close_with_os: "Fecha o lead com OS e valor.",
  convert_to_ticket: "Converte esse lead em ticket.",
};

const TICKET_ACTION_MODAL_DESCRIPTIONS: Record<string, string> = {
  view: "Marca que voce visualizou o ticket.",
  add_note: "Registra uma observacao interna.",
  add_tags: "Adiciona tags ao ticket.",
  remove_tags: "Remove tags do ticket.",
  close: "Registra fechamento do ticket.",
  reopen: "Registra reabertura do ticket.",
  assign: "Atribui esse ticket.",
  external_update_detected: "Marca que houve mudanca fora do middleware.",
};

export function ActionModal<Action extends string>({
  open,
  entity,
  actions,
  defaultAction,
  initialPayload,
  onClose,
  onConfirm,
  loading = false,
  error = null,
}: ActionModalProps<Action>) {
  const [action, setAction] = useState<Action | undefined>(undefined);
  const [note, setNote] = useState("");
  const [reason, setReason] = useState("");
  const [assignee, setAssignee] = useState("");
  const [os, setOs] = useState("");
  const [partsValue, setPartsValue] = useState("");
  const [laborValue, setLaborValue] = useState("");
  const [tags, setTags] = useState("");
  const [method, setMethod] = useState("manual");
  const [changedFields, setChangedFields] = useState<ChangedFieldRow[]>([
    { key: "", value: "" },
  ]);

  const closeButtonRef = useRef<HTMLButtonElement | null>(null);

  const activeDef = useMemo(
    () => actions.find((item) => item.id === action) ?? null,
    [action, actions]
  );

  useEffect(() => {
    if (!open) return;

    setAction(defaultAction);
    setNote(typeof initialPayload?.note === "string" ? initialPayload.note : "");
    setReason(
      typeof initialPayload?.reason === "string" ? initialPayload.reason : "",
    );
    setAssignee(
      typeof initialPayload?.assignee === "string"
        ? initialPayload.assignee
        : "",
    );
    setOs(typeof initialPayload?.os === "string" ? initialPayload.os : "");
    setPartsValue(
      initialPayload?.parts_value !== undefined &&
        initialPayload?.parts_value !== null
        ? String(initialPayload.parts_value)
        : "",
    );
    setLaborValue(
      initialPayload?.labor_value !== undefined &&
        initialPayload?.labor_value !== null
        ? String(initialPayload.labor_value)
        : "",
    );
    setTags(
      Array.isArray(initialPayload?.tags)
        ? initialPayload?.tags.join(", ")
        : "",
    );
    setMethod(
      typeof initialPayload?.method === "string"
        ? initialPayload.method
        : "manual",
    );
    setChangedFields(() => {
      const entries = initialPayload?.changed_fields;
      if (!entries || typeof entries !== "object") {
        return [{ key: "", value: "" }];
      }
      const rows = Object.entries(entries as Record<string, unknown>)
        .map(([key, value]) => ({
          key,
          value: typeof value === "string" ? value : String(value),
        }))
        .filter((row) => row.key.trim() || row.value.trim());
      return rows.length ? rows : [{ key: "", value: "" }];
    });

    const id = window.setTimeout(() => closeButtonRef.current?.focus(), 0);
    return () => window.clearTimeout(id);
  }, [defaultAction, initialPayload, open]);

  useEffect(() => {
    if (!open) return;
    const onKeyDown = (event: KeyboardEvent) => {
      if (event.key === "Escape") {
        event.preventDefault();
        onClose();
      }
    };
    window.addEventListener("keydown", onKeyDown);
    return () => window.removeEventListener("keydown", onKeyDown);
  }, [onClose, open]);

  const canConfirm = useMemo(() => {
    if (!activeDef || !action) return false;
    if (loading) return false;
    if (activeDef.disabled) return false;
    if (activeDef.requiresNote && !note.trim()) return false;
    if (activeDef.requiresReason && !reason.trim()) return false;
    if (activeDef.requiresAssignee && !assignee.trim()) return false;
    if (activeDef.requiresOs && !os.trim()) return false;
    if (activeDef.requiresPartsValue && !partsValue.trim()) return false;
    if (activeDef.requiresLaborValue && !laborValue.trim()) return false;
    if (activeDef.requiresTags && parseTags(tags).length === 0) return false;
    if (activeDef.requiresChangedFields) {
      const hasOne = changedFields.some(
        (row) => row.key.trim() && row.value.trim()
      );
      if (!hasOne) return false;
    }
    return true;
  }, [
    action,
    activeDef,
    assignee,
    changedFields,
    laborValue,
    loading,
    note,
    os,
    partsValue,
    reason,
    tags,
  ]);

  const handleConfirm = async () => {
    if (!action || !activeDef) return;

    const payload: EventPayload = {};

    const normalizedNote = note.trim().slice(0, MAX_NOTE_CHARS);
    if (normalizedNote) payload.note = normalizedNote;

    if (activeDef.requiresReason || reason.trim()) {
      const normalizedReason = reason.trim();
      if (normalizedReason) payload.reason = normalizedReason;
    }

    if (activeDef.requiresAssignee) {
      payload.assignee = assignee.trim();
    } else if (assignee.trim()) {
      payload.assignee = assignee.trim();
    }

    if (activeDef.requiresOs) {
      payload.os = os.trim();
    } else if (os.trim()) {
      payload.os = os.trim();
    }

    if (activeDef.requiresPartsValue) {
      payload.parts_value = partsValue.trim();
    } else if (partsValue.trim()) {
      payload.parts_value = partsValue.trim();
    }

    if (activeDef.requiresLaborValue) {
      payload.labor_value = laborValue.trim();
    } else if (laborValue.trim()) {
      payload.labor_value = laborValue.trim();
    }

    if (activeDef.requiresTags || tags.trim()) {
      const list = parseTags(tags);
      if (list.length) payload.tags = list;
    }

    if (entity === "lead" && action === ("convert_to_ticket" as Action)) {
      payload.method = method.trim() || "manual";
    }

    if (entity === "lead" && action === ("update_field" as Action)) {
      const entries = changedFields
        .map((row) => [row.key.trim(), row.value.trim()] as const)
        .filter(([k, v]) => Boolean(k) && Boolean(v));
      if (entries.length) {
        payload.changed_fields = Object.fromEntries(entries);
      }
    }

    await onConfirm(action, payload);
  };

  const showMethod =
    entity === "lead" && action === ("convert_to_ticket" as Action);
  const showChangedFields =
    entity === "lead" && action === ("update_field" as Action);
  const showTags =
    entity === "ticket" &&
    (action === ("add_tags" as Action) || action === ("remove_tags" as Action));
  const showAssignee = Boolean(activeDef?.requiresAssignee);
  const showOs = Boolean(activeDef?.requiresOs);
  const showPartsValue = Boolean(activeDef?.requiresPartsValue);
  const showLaborValue = Boolean(activeDef?.requiresLaborValue);
  const showReasonSelect =
    entity === "lead" && action === ("close_without_os" as Action);
  const noteRequired = Boolean(activeDef?.requiresNote);
  const showNote = Boolean(activeDef && !activeDef.hideNote);
  const noteLabel = noteRequired
    ? "Descricao do contato"
    : "Observacao (opcional)";
  const notePlaceholder = noteRequired
    ? "Descreva o contato realizado"
    : "Adicione contexto (ate 2000 caracteres)";

  if (!open) return null;
  if (typeof document === "undefined") return null;

  return createPortal(
    <div
      className="fixed inset-0 z-50 flex items-center justify-center bg-slate-900/40 p-4 backdrop-blur-sm"
      onMouseDown={(e) => {
        e.stopPropagation();
        if (e.target === e.currentTarget) onClose();
      }}
      onKeyDown={(e) => {
        e.stopPropagation();
      }}
      onClick={(e) => e.stopPropagation()}
      role="dialog"
      aria-modal="true"
      aria-label="Registrar ação"
    >
      <div className="w-full max-w-2xl overflow-hidden rounded-2xl border border-slate-200 bg-white shadow-2xl">
        <div className="flex items-start justify-between gap-4 border-b border-slate-200 bg-slate-50 px-5 py-4">
          <div className="space-y-1">
            <h2 className="text-base font-semibold text-slate-900">
              Registrar ação
            </h2>
            <p className="text-xs text-slate-500">
              Escolha a ação e preencha detalhes (se necessário).
            </p>
          </div>
          <button
            ref={closeButtonRef}
            type="button"
            onClick={onClose}
            className="rounded-lg border border-slate-200 bg-white px-3 py-1.5 text-xs font-semibold text-slate-700 transition hover:border-slate-300 hover:text-slate-900"
          >
            Fechar
          </button>
        </div>

        <div className="grid gap-4 p-5 md:grid-cols-[1.1fr_1fr]">
          <div className="space-y-3">
            <p className="text-xs font-semibold uppercase tracking-wide text-slate-500">
              Ação
            </p>
            <div className="space-y-2">
              {actions.map((item) => {
                const active = item.id === action;
                const isDisabled = Boolean(item.disabled);
                const description =
                  (entity === "lead"
                    ? LEAD_ACTION_MODAL_DESCRIPTIONS[item.id]
                    : TICKET_ACTION_MODAL_DESCRIPTIONS[item.id]) ??
                  item.description;
                return (
                  <button
                    key={item.id}
                    type="button"
                    onClick={() => {
                      if (!isDisabled) setAction(item.id);
                    }}
                    disabled={isDisabled}
                    className={`w-full rounded-xl border p-3 text-left transition ${
                      active
                        ? "border-sky-300 bg-sky-50"
                        : "border-slate-200 bg-white hover:border-slate-300"
                    } ${isDisabled ? "cursor-not-allowed opacity-50" : ""}`}
                  >
                    <div className="flex items-center justify-between gap-3">
                      <div>
                        <div className="text-sm font-semibold text-slate-900">
                          {item.label}
                        </div>
                        <div className="text-xs text-slate-500">
                          {description}
                        </div>
                      </div>
                      <div
                        className={`h-3 w-3 rounded-full border ${
                          active
                            ? "border-sky-400 bg-sky-500"
                            : "border-slate-300 bg-white"
                        }`}
                        aria-hidden="true"
                      />
                    </div>
                  </button>
                );
              })}
            </div>
          </div>

          <div className="space-y-3">
            <p className="text-xs font-semibold uppercase tracking-wide text-slate-500">
              Detalhes
            </p>

            {error && (
              <div className="rounded-xl border border-rose-200 bg-rose-50 px-4 py-3 text-sm text-rose-900">
                {error}
              </div>
            )}

            {activeDef?.requiresReason && showReasonSelect && (
              <label className="space-y-1 text-sm font-medium text-slate-700">
                <span>
                  Motivo <span className="text-rose-600">*</span>
                </span>
                <select
                  value={reason}
                  onChange={(e) => setReason(e.target.value)}
                  className="w-full rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm font-normal text-slate-900 outline-none transition focus:border-sky-400 focus:ring-4 focus:ring-sky-100"
                  required
                >
                  <option value="">Selecione o motivo</option>
                  {CLOSE_WITHOUT_OS_REASONS.map((option) => (
                    <option key={option} value={option}>
                      {option}
                    </option>
                  ))}
                </select>
              </label>
            )}

            {activeDef?.requiresReason && !showReasonSelect && (
              <label className="space-y-1 text-sm font-medium text-slate-700">
                <span>
                  Motivo <span className="text-rose-600">*</span>
                </span>
                <input
                  value={reason}
                  onChange={(e) => setReason(e.target.value)}
                  className="w-full rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm font-normal text-slate-900 outline-none transition focus:border-sky-400 focus:ring-4 focus:ring-sky-100"
                  placeholder="Explique o motivo"
                  required
                />
              </label>
            )}

            {showAssignee && (
              <label className="space-y-1 text-sm font-medium text-slate-700">
                <span>
                  Responsável <span className="text-rose-600">*</span>
                </span>
                <input
                  value={assignee}
                  onChange={(e) => setAssignee(e.target.value)}
                  className="w-full rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm font-normal text-slate-900 outline-none transition focus:border-sky-400 focus:ring-4 focus:ring-sky-100"
                  placeholder="Email ou nome"
                />
              </label>
            )}

            {showOs && (
              <label className="space-y-1 text-sm font-medium text-slate-700">
                <span>
                  OS <span className="text-rose-600">*</span>
                </span>
                <input
                  value={os}
                  onChange={(e) => setOs(e.target.value)}
                  className="w-full rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm font-normal text-slate-900 outline-none transition focus:border-sky-400 focus:ring-4 focus:ring-sky-100"
                  placeholder="Numero da OS"
                />
              </label>
            )}

            {showPartsValue && (
              <label className="space-y-1 text-sm font-medium text-slate-700">
                <span>
                  Pecas <span className="text-rose-600">*</span>
                </span>
                <input
                  value={partsValue}
                  onChange={(e) => setPartsValue(e.target.value)}
                  className="w-full rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm font-normal text-slate-900 outline-none transition focus:border-sky-400 focus:ring-4 focus:ring-sky-100"
                  placeholder="Ex.: 2500"
                />
              </label>
            )}

            {showLaborValue && (
              <label className="space-y-1 text-sm font-medium text-slate-700">
                <span>
                  Mao de obra <span className="text-rose-600">*</span>
                </span>
                <input
                  value={laborValue}
                  onChange={(e) => setLaborValue(e.target.value)}
                  className="w-full rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm font-normal text-slate-900 outline-none transition focus:border-sky-400 focus:ring-4 focus:ring-sky-100"
                  placeholder="Ex.: 500"
                />
              </label>
            )}

            {showTags && (
              <label className="space-y-1 text-sm font-medium text-slate-700">
                <span>
                  Tags <span className="text-rose-600">*</span>
                </span>
                <input
                  value={tags}
                  onChange={(e) => setTags(e.target.value)}
                  className="w-full rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm font-normal text-slate-900 outline-none transition focus:border-sky-400 focus:ring-4 focus:ring-sky-100"
                  placeholder="Ex.: urgente, callback, vip"
                />
                <p className="text-xs text-slate-500">Separe por vírgula.</p>
              </label>
            )}

            {showMethod && (
              <label className="space-y-1 text-sm font-medium text-slate-700">
                <span>Método</span>
                <select
                  value={method}
                  onChange={(e) => setMethod(e.target.value)}
                  className="w-full rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm font-normal text-slate-900 outline-none transition focus:border-sky-400 focus:ring-4 focus:ring-sky-100"
                >
                  <option value="manual">Manual</option>
                </select>
              </label>
            )}

            {showChangedFields && (
              <div className="space-y-2">
                <div className="flex items-center justify-between">
                  <p className="text-sm font-medium text-slate-700">
                    Campos alterados <span className="text-rose-600">*</span>
                  </p>
                  <button
                    type="button"
                    onClick={() =>
                      setChangedFields((prev) => [
                        ...prev,
                        { key: "", value: "" },
                      ])
                    }
                    className="rounded-lg border border-slate-200 bg-white px-2 py-1 text-xs font-semibold text-slate-700 transition hover:border-slate-300 hover:text-slate-900"
                  >
                    Adicionar
                  </button>
                </div>
                {changedFields.map((row, idx) => (
                  <div key={idx} className="grid grid-cols-2 gap-2">
                    <input
                      value={row.key}
                      onChange={(e) =>
                        setChangedFields((prev) =>
                          prev.map((item, i) =>
                            i === idx ? { ...item, key: e.target.value } : item
                          )
                        )
                      }
                      className="w-full rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm text-slate-900 outline-none transition focus:border-sky-400 focus:ring-4 focus:ring-sky-100"
                      placeholder="Campo"
                    />
                    <input
                      value={row.value}
                      onChange={(e) =>
                        setChangedFields((prev) =>
                          prev.map((item, i) =>
                            i === idx
                              ? { ...item, value: e.target.value }
                              : item
                          )
                        )
                      }
                      className="w-full rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm text-slate-900 outline-none transition focus:border-sky-400 focus:ring-4 focus:ring-sky-100"
                      placeholder="Novo valor"
                    />
                  </div>
                ))}
              </div>
            )}

            {showNote && (
              <label className="space-y-1 text-sm font-medium text-slate-700">
                <span>
                  {noteLabel}{" "}
                  {noteRequired ? (
                    <span className="text-rose-600">*</span>
                  ) : null}
                </span>
                <textarea
                  value={note}
                  onChange={(e) => setNote(e.target.value)}
                  maxLength={MAX_NOTE_CHARS}
                  rows={4}
                  required={noteRequired}
                  className="w-full resize-none rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm font-normal text-slate-900 outline-none transition focus:border-sky-400 focus:ring-4 focus:ring-sky-100"
                  placeholder={notePlaceholder}
                />
                <div className="flex justify-end text-xs text-slate-400">
                  {note.length}/{MAX_NOTE_CHARS}
                </div>
              </label>
            )}
          </div>
        </div>

        <div className="flex items-center justify-end gap-2 border-t border-slate-200 bg-white px-5 py-4">
          <button
            type="button"
            onClick={onClose}
            disabled={loading}
            className="rounded-xl border border-slate-200 bg-white px-4 py-2 text-sm font-semibold text-slate-700 transition hover:border-slate-300 hover:text-slate-900 disabled:opacity-60"
          >
            Cancelar
          </button>
          <button
            type="button"
            onClick={handleConfirm}
            disabled={!canConfirm}
            className="rounded-xl bg-slate-900 px-4 py-2 text-sm font-semibold text-white shadow-lg shadow-slate-200 transition hover:bg-slate-800 disabled:cursor-not-allowed disabled:opacity-60"
          >
            {loading ? "Registrando..." : "Confirmar"}
          </button>
        </div>
      </div>
    </div>,
    document.body
  );
}

export const LEAD_ACTIONS_FOR_UI = LEAD_ACTION_DEFINITIONS;
export const TICKET_ACTIONS_FOR_UI = TICKET_ACTION_DEFINITIONS;



================================================
FILE: src/components/AssignLeadButton.tsx
================================================
"use client";

import { useMemo, type MouseEvent } from "react";
import { useCreateEvent } from "@/hooks/useCreateEvent";
import { useToast } from "@/components/ToastProvider";

type AssignLeadButtonProps = {
  leadId: number;
  assigneeName?: string | null;
  onAssigned?: (assignee: string) => void;
  className?: string;
};

export function AssignLeadButton({
  leadId,
  assigneeName,
  onAssigned,
  className,
}: AssignLeadButtonProps) {
  const toast = useToast();
  const { createLeadEvent, loading } = useCreateEvent();

  const cleanedAssignee = useMemo(
    () => (assigneeName ?? "").trim(),
    [assigneeName],
  );

  const disabledReason = !cleanedAssignee
    ? "Usuario nao identificado."
    : null;

  const handleClick = async (event: MouseEvent<HTMLButtonElement>) => {
    event.stopPropagation();
    if (disabledReason) return;
    try {
      await createLeadEvent({
        leadId,
        action: "assign",
        payload: { assignee: cleanedAssignee },
      });
      toast.push({
        variant: "success",
        message: "Lead atribuido a voce.",
      });
      onAssigned?.(cleanedAssignee);
    } catch (err: any) {
      const message =
        typeof err?.message === "string" && err.message
          ? err.message
          : "Nao foi possivel atribuir o lead.";
      toast.push({ variant: "error", message });
    }
  };

  return (
    <button
      type="button"
      disabled={Boolean(disabledReason) || loading}
      onClick={handleClick}
      onMouseDown={(event) => event.stopPropagation()}
      title={disabledReason ?? "Atribuir lead a voce"}
      className={
        className ??
        "inline-flex items-center justify-center rounded-lg border border-slate-200 bg-white px-3 py-1.5 text-xs font-semibold text-slate-700 transition enabled:hover:border-slate-300 enabled:hover:text-slate-900 disabled:cursor-not-allowed disabled:opacity-60"
      }
    >
      {loading ? "Atribuindo..." : "Atribuir a mim"}
    </button>
  );
}



================================================
FILE: src/components/Badge.tsx
================================================
"use client";

type BadgeTone =
  | "sky"
  | "emerald"
  | "amber"
  | "rose"
  | "slate"
  | "violet"
  | "stone";

type BadgeProps = {
  tone?: BadgeTone;
  children: React.ReactNode;
  className?: string;
};

const toneClasses: Record<BadgeTone, string> = {
  sky: "bg-sky-100 text-sky-800 border-sky-200",
  emerald: "bg-emerald-100 text-emerald-800 border-emerald-200",
  amber: "bg-amber-100 text-amber-800 border-amber-200",
  rose: "bg-rose-100 text-rose-800 border-rose-200",
  slate: "bg-slate-100 text-slate-800 border-slate-200",
  violet: "bg-violet-100 text-violet-800 border-violet-200",
  stone: "bg-stone-100 text-stone-800 border-stone-200",
};

export function Badge({ tone = "slate", children, className }: BadgeProps) {
  const classes = [
    "inline-flex items-center rounded-full border px-2 py-0.5 text-[11px] font-semibold uppercase tracking-wide",
    toneClasses[tone],
  ];

  if (className) {
    classes.push(className);
  }

  return <span className={classes.join(" ")}>{children}</span>;
}



================================================
FILE: src/components/CreateLeadModal.tsx
================================================
"use client";

import React, { useEffect, useMemo, useRef, useState } from "react";
import { createPortal } from "react-dom";
import { createLead, type CreateLeadInput } from "@/lib/api";
import { ESTADOS, REGIOES } from "@/lib/filters";
import type { LeadCategory } from "@/lib/domain";
import { useToast } from "@/components/ToastProvider";

type CreateLeadModalProps = {
  open: boolean;
  onClose: () => void;
  initial?: Partial<CreateLeadInput>;
  onCreated?: () => void;
};

const normalizeTextInput = (value: string) => {
  const trimmed = value.trim();
  return trimmed ? trimmed : null;
};

export function CreateLeadModal({
  open,
  onClose,
  initial,
  onCreated,
}: CreateLeadModalProps) {
  const toast = useToast();
  const closeButtonRef = useRef<HTMLButtonElement | null>(null);

  const [regional, setRegional] = useState<string>("");
  const [estado, setEstado] = useState<string>("");
  const [city, setCity] = useState("");
  const [cliente, setCliente] = useState("");
  const [chassi, setChassi] = useState("");
  const [modelName, setModelName] = useState("");
  const [status, setStatus] = useState("");
  const [tipoLead, setTipoLead] = useState<LeadCategory>("indefinido");
  const [horimetro, setHorimetro] = useState("");

  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const createDisabled = true;

  useEffect(() => {
    if (!open) return;

    setError(null);
    setLoading(false);

    setRegional(initial?.regional ? String(initial.regional) : "");
    setEstado(initial?.estado ? String(initial.estado) : "");
    setCity(initial?.city ? String(initial.city) : "");
    setCliente(
      initial?.clienteBaseEnriquecida
        ? String(initial.clienteBaseEnriquecida)
        : ""
    );
    setChassi(initial?.chassi ? String(initial.chassi) : "");
    setModelName(initial?.modelName ? String(initial.modelName) : "");
    setStatus(initial?.status ? String(initial.status) : "");
    setTipoLead(
      typeof initial?.tipoLead === "string"
        ? (initial.tipoLead as LeadCategory)
        : "indefinido"
    );
    setHorimetro(
      typeof initial?.horimetroAtualMachineList === "number"
        ? String(initial.horimetroAtualMachineList)
        : ""
    );

    const id = window.setTimeout(() => closeButtonRef.current?.focus(), 0);
    return () => window.clearTimeout(id);
  }, [initial, open]);

  useEffect(() => {
    if (!open) return;
    const onKeyDown = (event: KeyboardEvent) => {
      if (event.key === "Escape") {
        event.preventDefault();
        onClose();
      }
    };
    window.addEventListener("keydown", onKeyDown);
    return () => window.removeEventListener("keydown", onKeyDown);
  }, [onClose, open]);

  const canCreate = useMemo(() => {
    if (loading) return false;
    if (createDisabled) return false;
    return Boolean(
      normalizeTextInput(chassi) ||
        normalizeTextInput(cliente) ||
        normalizeTextInput(city) ||
        normalizeTextInput(modelName)
    );
  }, [chassi, city, cliente, createDisabled, loading, modelName]);

  const handleCreate = async () => {
    if (!canCreate) return;

    setError(null);
    setLoading(true);
    try {
      const horimetroValueRaw = horimetro.trim();
      const horimetroValue =
        horimetroValueRaw === "" ? null : Number(horimetroValueRaw);

      const input: CreateLeadInput = {
        regional: regional || null,
        estado: estado || null,
        city: normalizeTextInput(city),
        chassi: normalizeTextInput(chassi),
        modelName: normalizeTextInput(modelName),
        clienteBaseEnriquecida: normalizeTextInput(cliente),
        status: normalizeTextInput(status),
        tipoLead,
        horimetroAtualMachineList: Number.isFinite(horimetroValue)
          ? horimetroValue
          : null,
      };

      await createLead(input);
      toast.push({ variant: "success", message: "Lead criado com sucesso." });
      onClose();
      onCreated?.();
    } catch (err: unknown) {
      const message =
        err instanceof Error && err.message
          ? err.message
          : "Nao foi possivel criar lead.";
      setError(message);
      toast.push({ variant: "error", message });
    } finally {
      setLoading(false);
    }
  };

  if (!open) return null;
  if (typeof document === "undefined") return null;

  return createPortal(
    <div
      className="fixed inset-0 z-50 flex items-center justify-center bg-slate-900/40 p-4 backdrop-blur-sm"
      onMouseDown={(e) => {
        e.stopPropagation();
        if (e.target === e.currentTarget) onClose();
      }}
      onClick={(e) => e.stopPropagation()}
      role="dialog"
      aria-modal="true"
      aria-label="Criar lead"
    >
      <div className="w-full max-w-2xl overflow-hidden rounded-2xl border border-slate-200 bg-white shadow-2xl">
        <div className="flex items-start justify-between gap-4 border-b border-slate-200 bg-slate-50 px-5 py-4">
          <div className="space-y-1">
            <h2 className="text-base font-semibold text-slate-900">
              Novo lead
            </h2>
            <p className="text-xs text-slate-500">
              Preencha os campos basicos para criar um lead manual.
            </p>
          </div>
          <button
            ref={closeButtonRef}
            type="button"
            onClick={onClose}
            className="rounded-lg border border-slate-200 bg-white px-3 py-1.5 text-xs font-semibold text-slate-700 transition hover:border-slate-300 hover:text-slate-900"
          >
            Fechar
          </button>
        </div>

        <div className="grid gap-4 p-5 md:grid-cols-[1.1fr_1fr]">
          <div className="space-y-3">
            <p className="text-xs font-semibold uppercase tracking-wide text-slate-500">
              Identificacao
            </p>

            <label className="space-y-1 text-sm font-medium text-slate-700">
              <span>Cliente</span>
              <input
                value={cliente}
                onChange={(e) => setCliente(e.target.value)}
                className="w-full rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm font-normal text-slate-900 outline-none transition focus:border-sky-400 focus:ring-4 focus:ring-sky-100"
                placeholder="Nome do cliente"
              />
            </label>

            <label className="space-y-1 text-sm font-medium text-slate-700">
              <span>Chassi</span>
              <input
                value={chassi}
                onChange={(e) => setChassi(e.target.value)}
                className="w-full rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm font-normal text-slate-900 outline-none transition focus:border-sky-400 focus:ring-4 focus:ring-sky-100"
                placeholder="Ex.: ABC123"
              />
            </label>

            <label className="space-y-1 text-sm font-medium text-slate-700">
              <span>Modelo</span>
              <input
                value={modelName}
                onChange={(e) => setModelName(e.target.value)}
                className="w-full rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm font-normal text-slate-900 outline-none transition focus:border-sky-400 focus:ring-4 focus:ring-sky-100"
                placeholder="Modelo da maquina"
              />
            </label>
          </div>

          <div className="space-y-3">
            <p className="text-xs font-semibold uppercase tracking-wide text-slate-500">
              Detalhes
            </p>

            {error && (
              <div className="rounded-xl border border-rose-200 bg-rose-50 px-4 py-3 text-sm text-rose-900">
                {error}
              </div>
            )}

            <div className="grid grid-cols-2 gap-2">
              <label className="space-y-1 text-sm font-medium text-slate-700">
                <span>Regional</span>
                <select
                  value={regional}
                  onChange={(e) => setRegional(e.target.value)}
                  className="w-full rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm font-normal text-slate-900 outline-none transition focus:border-sky-400 focus:ring-4 focus:ring-sky-100"
                >
                  <option value="">-</option>
                  {REGIOES.map((value) => (
                    <option key={value} value={value}>
                      {value}
                    </option>
                  ))}
                </select>
              </label>
              <label className="space-y-1 text-sm font-medium text-slate-700">
                <span>Estado</span>
                <select
                  value={estado}
                  onChange={(e) => setEstado(e.target.value)}
                  className="w-full rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm font-normal text-slate-900 outline-none transition focus:border-sky-400 focus:ring-4 focus:ring-sky-100"
                >
                  <option value="">-</option>
                  {ESTADOS.map((value) => (
                    <option key={value} value={value}>
                      {value}
                    </option>
                  ))}
                </select>
              </label>
            </div>

            <label className="space-y-1 text-sm font-medium text-slate-700">
              <span>Cidade</span>
              <input
                value={city}
                onChange={(e) => setCity(e.target.value)}
                className="w-full rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm font-normal text-slate-900 outline-none transition focus:border-sky-400 focus:ring-4 focus:ring-sky-100"
                placeholder="Cidade"
              />
            </label>

            <label className="space-y-1 text-sm font-medium text-slate-700">
              <span>Tipo de lead</span>
              <select
                value={tipoLead}
                onChange={(e) => setTipoLead(e.target.value as LeadCategory)}
                className="w-full rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm font-normal text-slate-900 outline-none transition focus:border-sky-400 focus:ring-4 focus:ring-sky-100"
              >
                <option value="indefinido">indefinido</option>
                <option value="preventiva">preventiva</option>
                <option value="garantia_basica">garantia_basica</option>
                <option value="garantia_estendida">garantia_estendida</option>
                <option value="reforma_componentes">reforma_componentes</option>
                <option value="lamina">lamina</option>
                <option value="dentes">dentes</option>
                <option value="rodante">rodante</option>
                <option value="disponibilidade">disponibilidade</option>
                <option value="reconexao">reconexao</option>
                <option value="transferencia_aor">transferencia_aor</option>
                <option value="pops">pops</option>
                <option value="outros">outros</option>
              </select>
            </label>

            <label className="space-y-1 text-sm font-medium text-slate-700">
              <span>Status</span>
              <input
                value={status}
                onChange={(e) => setStatus(e.target.value)}
                className="w-full rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm font-normal text-slate-900 outline-none transition focus:border-sky-400 focus:ring-4 focus:ring-sky-100"
                placeholder="Ex.: novo"
              />
            </label>

            <label className="space-y-1 text-sm font-medium text-slate-700">
              <span>Horimetro</span>
              <input
                value={horimetro}
                onChange={(e) => setHorimetro(e.target.value)}
                className="w-full rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm font-normal text-slate-900 outline-none transition focus:border-sky-400 focus:ring-4 focus:ring-sky-100"
                placeholder="Ex.: 1234"
                inputMode="numeric"
              />
            </label>

            {/* {createDisabled && (
              <div className="rounded-xl border border-amber-200 bg-amber-50 px-4 py-3 text-sm text-amber-900">
                Criacao de leads esta em desenvolvimento. O botao de criar esta desabilitado.
              </div>
            )} */}
          </div>
        </div>

        <div className="flex items-center justify-end gap-2 border-t border-slate-200 bg-white px-5 py-4">
          <button
            type="button"
            onClick={onClose}
            disabled={loading}
            className="rounded-xl border border-slate-200 bg-white px-4 py-2 text-sm font-semibold text-slate-700 transition hover:border-slate-300 hover:text-slate-900 disabled:opacity-60"
          >
            Cancelar
          </button>
          <button
            type="button"
            onClick={handleCreate}
            disabled={!canCreate}
            className="rounded-xl bg-slate-900 px-4 py-2 text-sm font-semibold text-white shadow-lg shadow-slate-200 transition hover:bg-slate-800 disabled:cursor-not-allowed disabled:opacity-60"
            title={createDisabled ? "Em breve" : "Criar lead"}
          >
            {loading ? "Criando..." : "Criar lead"}
          </button>
        </div>
      </div>
    </div>,
    document.body
  );
}



================================================
FILE: src/components/FiltersBar.tsx
================================================
﻿"use client";

import { FiltersState, SortOrder } from "@/lib/filters";
import { LeadTypesMultiSelect } from "@/components/LeadTypesMultiSelect";

type FiltersBarProps = {
  value: FiltersState;
  regiaoOptions?: string[];
  estadoOptions?: string[];
  tipoLeadOptions?: string[];
  statusOptions?: Array<string | { value: string; label: string }>;
  reserveStatusSlot?: boolean;
  sortOptions?: { id: SortOrder; label: string }[];
  searchPlaceholder?: string;
  searchLabel?: string;
  regiaoLabel?: string;
  estadoLabel?: string;
  tipoLeadLabel?: string;
  statusLabel?: string;
  onFiltersChange: (filters: FiltersState) => void;
};

const defaultSortOptions: { id: SortOrder; label: string }[] = [
  { id: "recentes", label: "Mais recentes" },
  { id: "antigos", label: "Mais antigos" },
];

export function FiltersBar({
  value,
  regiaoOptions,
  estadoOptions,
  tipoLeadOptions = [],
  statusOptions,
  reserveStatusSlot = false,
  sortOptions = defaultSortOptions,
  searchPlaceholder = "Buscar...",
  searchLabel = "Busca",
  regiaoLabel = "Regiao",
  estadoLabel = "Estado",
  tipoLeadLabel = "Tipo de lead",
  statusLabel = "Status",
  onFiltersChange,
}: FiltersBarProps) {
  const handleChange = <K extends keyof FiltersState>(
    key: K,
    val: FiltersState[K],
  ) => {
    onFiltersChange({ ...value, [key]: val });
  };

  return (
    <div className="rounded-xl border border-slate-200 bg-white p-4 shadow-sm">
      <div className="grid gap-3 md:grid-cols-3">
        <label className="flex flex-col gap-1 text-xs font-semibold uppercase tracking-wide text-slate-500">
          {searchLabel}
          <input
            type="search"
            value={value.search}
            onChange={(e) => handleChange("search", e.target.value)}
            placeholder={searchPlaceholder}
            className="w-full rounded-lg border border-slate-200 bg-white px-3 py-2 text-sm text-slate-900 placeholder:text-slate-400 focus:border-sky-400 focus:outline-none focus:ring-2 focus:ring-sky-200"
          />
        </label>

        {statusOptions !== undefined ? (
          <label className="flex flex-col gap-1 text-xs font-semibold uppercase tracking-wide text-slate-500">
            {statusLabel}
            <LeadTypesMultiSelect
              value={value.status}
              options={statusOptions}
              onChange={(next) => handleChange("status", next)}
              placeholder="Selecionar status"
            />
          </label>
        ) : reserveStatusSlot ? (
          <div aria-hidden="true" className="hidden md:block" />
        ) : null}

        <label className="flex flex-col gap-1 text-xs font-semibold uppercase tracking-wide text-slate-500">
          Ordenacao
          <select
            value={value.sort}
            onChange={(e) => handleChange("sort", e.target.value as SortOrder)}
            className="w-full rounded-lg border border-slate-200 bg-white px-3 py-2 text-sm text-slate-900 focus:border-sky-400 focus:outline-none focus:ring-2 focus:ring-sky-200"
          >
            {sortOptions.map((opt) => (
              <option key={opt.id} value={opt.id}>
                {opt.label}
              </option>
            ))}
          </select>
        </label>
      </div>

      <div className="mt-3 grid gap-3 md:grid-cols-3">
        {regiaoOptions !== undefined && (
          <label className="flex flex-col gap-1 text-xs font-semibold uppercase tracking-wide text-slate-500">
            {regiaoLabel}
            <select
              value={value.regiao}
              onChange={(e) =>
                handleChange("regiao", e.target.value as FiltersState["regiao"])
              }
              className="w-full rounded-lg border border-slate-200 bg-white px-3 py-2 text-sm text-slate-900 focus:border-sky-400 focus:outline-none focus:ring-2 focus:ring-sky-200"
            >
              <option value="">Todas</option>
              {regiaoOptions.map((opt) => (
                <option key={opt} value={opt}>
                  {opt}
                </option>
              ))}
            </select>
          </label>
        )}

        {estadoOptions !== undefined && (
          <label className="flex flex-col gap-1 text-xs font-semibold uppercase tracking-wide text-slate-500">
            {estadoLabel}
            <select
              value={value.estado}
              onChange={(e) =>
                handleChange("estado", e.target.value as FiltersState["estado"])
              }
              className="w-full rounded-lg border border-slate-200 bg-white px-3 py-2 text-sm text-slate-900 focus:border-sky-400 focus:outline-none focus:ring-2 focus:ring-sky-200"
            >
              <option value="">Todos</option>
              {estadoOptions.map((opt) => (
                <option key={opt} value={opt}>
                  {opt}
                </option>
              ))}
            </select>
          </label>
        )}

        <label className="flex flex-col gap-1 text-xs font-semibold uppercase tracking-wide text-slate-500">
          {tipoLeadLabel}
          <select
            value={value.tipoLead}
            onChange={(e) =>
              handleChange("tipoLead", e.target.value as FiltersState["tipoLead"])
            }
            className="w-full rounded-lg border border-slate-200 bg-white px-3 py-2 text-sm text-slate-900 focus:border-sky-400 focus:outline-none focus:ring-2 focus:ring-sky-200"
          >
            <option value="">Todos</option>
            {tipoLeadOptions.map((opt) => (
              <option key={opt} value={opt}>
                {opt}
              </option>
            ))}
          </select>
        </label>
      </div>
    </div>
  );
}



================================================
FILE: src/components/LeadDetailsAside.tsx
================================================
"use client";

import React, { useEffect, useMemo, useState } from "react";
import { Lead, LeadCategory } from "@/lib/domain";
import { LEAD_ACTION_DEFINITIONS, type EventPayload } from "@/lib/events";
import { LEAD_STATUS_LABELS } from "@/lib/filters";
import { Badge } from "@/components/Badge";
import { AssignLeadButton } from "@/components/AssignLeadButton";
import { CollapsibleSection } from "@/components/ticket-details/CollapsibleSection";
import {
  KeyValueGrid,
  type KeyValueItem,
} from "@/components/ticket-details/KeyValueGrid";

type LeadDetailsAsideProps = {
  lead: Lead | null;
  open: boolean;
  onClose: () => void;
  currentUserName?: string | null;
  onLeadAssigned?: (leadId: number, assignee: string) => void;
};

const dateFormatter = new Intl.DateTimeFormat("pt-BR", {
  hour: "2-digit",
  minute: "2-digit",
});

const dateOnlyFormatter = new Intl.DateTimeFormat("pt-BR", {
  day: "2-digit",
  month: "short",
  year: "numeric",
});

const numberFormatter = new Intl.NumberFormat("pt-BR");

const leadTypeTone: Record<LeadCategory, Parameters<typeof Badge>[0]["tone"]> =
  {
    preventiva: "sky",
    garantia_basica: "amber",
    garantia_estendida: "amber",
    reforma_componentes: "violet",
    lamina: "emerald",
    dentes: "emerald",
    rodante: "emerald",
    disponibilidade: "sky",
    reconexao: "slate",
    transferencia_aor: "slate",
    pops: "slate",
    outros: "stone",
    indefinido: "stone",
  };

const leadTypeLabel: Record<LeadCategory, string> = {
  preventiva: "Preventiva",
  garantia_basica: "Garantia basica",
  garantia_estendida: "Garantia estendida",
  reforma_componentes: "Reforma de componentes",
  lamina: "Lamina",
  dentes: "Dentes",
  rodante: "Rodante",
  disponibilidade: "Disponibilidade",
  reconexao: "Reconexao",
  transferencia_aor: "Transferencia de AOR",
  pops: "POPs",
  outros: "Outros",
  indefinido: "Indefinido",
};

const pickStatusTone = (
  status: string | null
): Parameters<typeof Badge>[0]["tone"] => {
  const normalized = status?.trim().toLowerCase();
  if (!normalized) return "stone";
  if (normalized.includes("fech") || normalized.includes("conclu"))
    return "emerald";
  if (normalized.includes("cancel")) return "rose";
  if (normalized.includes("novo")) return "sky";
  if (normalized.includes("pend")) return "amber";
  return "slate";
};

const formatDateParts = (iso: string) => {
  const date = new Date(iso);
  if (Number.isNaN(date.getTime())) {
    return { time: "N/A", date: "N/A" };
  }
  return {
    time: dateFormatter.format(date),
    date: dateOnlyFormatter.format(date),
  };
};

const flagValue = (value: string | null) =>
  value && value.trim() ? value.trim() : "Nao";

type LeadEventItem = {
  action: string | null;
  occurredAt: string | null;
  actorName: string | null;
  actorEmail: string | null;
  source: string | null;
  payload: EventPayload | null;
};

type EventsState =
  | { status: "idle" }
  | { status: "loading" }
  | { status: "success"; data: LeadEventItem[] }
  | { status: "error"; message: string };

const leadActionMeta = new Map<string, { label: string; description: string }>(
  LEAD_ACTION_DEFINITIONS.map((def) => [
    def.id,
    { label: def.label, description: def.description },
  ])
);

const formatEventDate = (iso: string | null) => {
  if (!iso) return "N/A";
  const date = new Date(iso);
  if (Number.isNaN(date.getTime())) return "N/A";
  return `${dateFormatter.format(date)} ${dateOnlyFormatter.format(date)}`;
};

const truncateText = (value: string, max = 120) => {
  if (value.length <= max) return value;
  return `${value.slice(0, Math.max(0, max - 3))}...`;
};

const parseMoney = (value: unknown): number | null => {
  if (typeof value === "number") {
    return Number.isFinite(value) ? value : null;
  }
  if (typeof value !== "string") return null;
  const trimmed = value.trim();
  if (!trimmed) return null;
  const normalized = trimmed.replace(/[^\d,.-]/g, "");
  if (!normalized) return null;
  let numeric = normalized;
  if (numeric.includes(",") && numeric.includes(".")) {
    numeric = numeric.replace(/\./g, "").replace(",", ".");
  } else if (numeric.includes(",")) {
    numeric = numeric.replace(",", ".");
  }
  const parsed = Number.parseFloat(numeric);
  return Number.isFinite(parsed) ? parsed : null;
};

const formatMoney = (value: unknown): string | null => {
  const parsed = parseMoney(value);
  if (parsed === null) return null;
  return numberFormatter.format(parsed);
};

const renderTemplate = (template: string, tokens: Record<string, string>) => {
  const parts: React.ReactNode[] = [];
  const regex = /\{(\w+)\}/g;
  let lastIndex = 0;
  let match: RegExpExecArray | null;

  while ((match = regex.exec(template)) !== null) {
    const [raw, key] = match;
    if (match.index > lastIndex) {
      parts.push(template.slice(lastIndex, match.index));
    }
    const value = tokens[key] ?? "...";
    parts.push(
      <span
        key={`${key}-${match.index}`}
        className="rounded-sm bg-slate-100 px-1 font-semibold text-slate-900"
      >
        {value}
      </span>
    );
    lastIndex = match.index + raw.length;
  }

  if (lastIndex < template.length) {
    parts.push(template.slice(lastIndex));
  }

  return parts;
};

const formatActorName = (value: string | null) => {
  const trimmed = value?.trim() ?? "";
  if (!trimmed) return "Sistema";
  if (trimmed.includes("@")) {
    const handle = trimmed.split("@")[0];
    return handle.replace(/\./g, " ");
  }
  return trimmed;
};

const summarizePayload = (
  payload: EventPayload | null,
  action?: string | null
): string[] => {
  if (!payload) return [];
  const parts: string[] = [];

  const note = typeof payload.note === "string" ? payload.note.trim() : "";
  const noteLabel = action === "register_contact" ? "Contato" : "Nota";
  if (note) parts.push(`${noteLabel}: ${truncateText(note)}`);

  const tags =
    Array.isArray(payload.tags) && payload.tags.length
      ? payload.tags.map((tag) => String(tag)).filter(Boolean)
      : [];
  if (tags.length) parts.push(`Tags: ${tags.join(", ")}`);

  const assignee =
    typeof payload.assignee === "string" ? payload.assignee.trim() : "";
  if (assignee) parts.push(`Responsavel: ${assignee}`);

  const reason =
    typeof payload.reason === "string" ? payload.reason.trim() : "";
  if (reason) parts.push(`Motivo: ${truncateText(reason, 90)}`);

  const osValue = typeof payload.os === "string" ? payload.os.trim() : "";
  if (osValue) parts.push(`OS: ${osValue}`);

  const partsValue = formatMoney(payload.parts_value);
  const laborValue = formatMoney(payload.labor_value);
  if (partsValue) parts.push(`Pecas: ${partsValue}`);
  if (laborValue) parts.push(`Mao de obra: ${laborValue}`);
  const valorValue = formatMoney(payload.valor);
  const totalValue =
    partsValue || laborValue
      ? formatMoney(
          (parseMoney(payload.parts_value) ?? 0) +
            (parseMoney(payload.labor_value) ?? 0)
        )
      : valorValue;
  if (totalValue && (partsValue || laborValue)) parts.push(`Total: ${totalValue}`);
  if (!partsValue && !laborValue && valorValue) parts.push(`Valor: ${valorValue}`);

  const method =
    typeof payload.method === "string" ? payload.method.trim() : "";
  if (method) parts.push(`Metodo: ${method}`);

  const changedFields = payload.changed_fields;
  if (changedFields && typeof changedFields === "object") {
    const entries = Object.entries(changedFields as Record<string, unknown>)
      .map(([key, value]) => `${key}: ${String(value)}`)
      .filter((entry) => entry.trim());
    if (entries.length) parts.push(`Campos: ${entries.join(", ")}`);
  }

  return parts;
};

function LeadHeader({ lead, onClose }: { lead: Lead; onClose: () => void }) {
  const leadTypes = lead.tipoLeadList?.length
    ? lead.tipoLeadList
    : [lead.tipoLead];
  const headerSubtitle = [lead.chassi ?? "Sem chassi", lead.modelName ?? "N/A"]
    .filter(Boolean)
    .join(" - ");

  return (
    <div className="sticky top-0 z-10 border-b border-slate-200 bg-white/90 px-5 py-4 backdrop-blur">
      <div className="flex items-start justify-between gap-3">
        <div className="min-w-0">
          <div className="flex flex-wrap items-center gap-2">
            <Badge tone="slate">Lead #{lead.id}</Badge>
            <Badge tone={pickStatusTone(lead.status)}>
              {lead.status ?? "Sem status"}
            </Badge>
            {leadTypes.map((tipo) => (
              <Badge key={tipo} tone={leadTypeTone[tipo]}>
                {leadTypeLabel[tipo]}
              </Badge>
            ))}
          </div>
          <h2 className="mt-2 line-clamp-2 text-base font-semibold text-slate-900">
            {lead.clienteBaseEnriquecida ?? "Sem cliente"}
          </h2>
          <p className="mt-1 text-xs text-slate-500">{headerSubtitle}</p>
        </div>

        <button
          type="button"
          onClick={onClose}
          aria-label="Fechar"
          className="inline-flex h-9 w-9 items-center justify-center rounded-lg border border-slate-200 bg-white text-slate-700 transition hover:border-slate-300 hover:text-slate-900"
        >
          X
        </button>
      </div>
    </div>
  );
}

export function LeadDetailsAside({
  lead,
  open,
  onClose,
  currentUserName,
  onLeadAssigned,
}: LeadDetailsAsideProps) {
  const [eventsState, setEventsState] = useState<EventsState>({
    status: "idle",
  });
  const [eventsReloadNonce, setEventsReloadNonce] = useState(0);
  const leadId = lead?.id ?? null;
  const hasLeadId = typeof leadId === "number" && Number.isFinite(leadId);

  useEffect(() => {
    if (!open) return;
    const onKeyDown = (e: KeyboardEvent) => {
      if (e.key === "Escape") onClose();
    };
    window.addEventListener("keydown", onKeyDown);
    return () => window.removeEventListener("keydown", onKeyDown);
  }, [open, onClose]);

  useEffect(() => {
    if (!open) return;
    const previousOverflow = document.body.style.overflow;
    document.body.style.overflow = "hidden";
    return () => {
      document.body.style.overflow = previousOverflow;
    };
  }, [open]);

  useEffect(() => {
    if (!open) {
      setEventsState({ status: "idle" });
      return;
    }

    if (!hasLeadId) {
      setEventsState({ status: "idle" });
      return;
    }

    const controller = new AbortController();
    setEventsState({ status: "loading" });

    const load = async () => {
      try {
        const response = await fetch(
          `/api/leads/${encodeURIComponent(String(leadId))}/events`,
          { signal: controller.signal, cache: "no-store" }
        );
        if (!response.ok) {
          const payload = await response.json().catch(() => null);
          const message =
            payload?.message ?? "Falha ao carregar eventos do lead.";
          throw new Error(message);
        }
        const data = await response.json();
        const items = Array.isArray(data?.items) ? data.items : [];
        setEventsState({ status: "success", data: items });
      } catch (err: any) {
        if (err?.name === "AbortError") return;
        const message =
          typeof err?.message === "string" && err.message
            ? err.message
            : "Falha ao carregar eventos do lead.";
        setEventsState({ status: "error", message });
      }
    };

    void load();
    return () => controller.abort();
  }, [hasLeadId, leadId, open, eventsReloadNonce]);

  const summaryItems = useMemo<KeyValueItem[]>(() => {
    if (!lead) return [];
    const importedParts = formatDateParts(lead.importedAt);
    const consultorValue = lead.consultor ?? null;
    const canAssignLead =
      !consultorValue?.trim() && Boolean(currentUserName?.trim());
    const consultorDisplay = canAssignLead ? (
      <AssignLeadButton
        leadId={lead.id}
        assigneeName={currentUserName}
        onAssigned={(assignee) => onLeadAssigned?.(lead.id, assignee)}
        className="rounded-md border border-slate-200 bg-white px-2 py-1 text-[11px] font-semibold text-slate-600 transition enabled:hover:border-slate-300 enabled:hover:text-slate-900 disabled:cursor-not-allowed disabled:opacity-60"
      />
    ) : (
      consultorValue ?? "Sem consultor"
    );
    const items: KeyValueItem[] = [
      { label: "Lead ID", value: String(lead.id) },
      { label: "Status", value: lead.status ?? "Sem status" },
      { label: "Criado por", value: lead.createdBy ?? "Nao informado" },
      { label: "Cliente", value: lead.clienteBaseEnriquecida ?? "Sem cliente" },
      { label: "Contato", value: lead.nomeContato ?? "Sem contato" },
      { label: "Telefone", value: lead.telefone ?? "Sem telefone" },
      {
        label: "Consultor",
        value: consultorDisplay,
      },
      { label: "Regional", value: lead.regional ?? "Sem regional" },
      { label: "Estado", value: lead.estado ?? "Sem estado" },
      { label: "Cidade", value: lead.city ?? "Sem cidade" },
      { label: "Grupo chamado", value: lead.lastCalledGroup ?? "Sem grupo" },
      {
        label: "Importado em",
        value: `${importedParts.date} ${importedParts.time}`,
      },
    ];
    return items;
  }, [currentUserName, lead, onLeadAssigned]);

  const equipmentItems = useMemo<KeyValueItem[]>(() => {
    if (!lead) return [];
    return [
      { label: "Chassi", value: lead.chassi ?? "Sem chassi" },
      { label: "Modelo", value: lead.modelName ?? "N/A" },
      {
        label: "Horimetro atual",
        value:
          lead.horimetroAtualMachineList !== null
            ? `${numberFormatter.format(lead.horimetroAtualMachineList)} h`
            : "N/A",
      },
    ];
  }, [lead]);

  const bancoItems = useMemo<KeyValueItem[]>(() => {
    if (!lead) return [];
    return [
      { label: "Preventiva", value: flagValue(lead.leadPreventiva) },
      { label: "Garantia basica", value: flagValue(lead.leadGarantiaBasica) },
      {
        label: "Garantia estendida",
        value: flagValue(lead.leadGarantiaEstendida),
      },
      {
        label: "Reforma de componentes",
        value: flagValue(lead.leadReformaDeComponentes),
      },
      { label: "Lamina", value: flagValue(lead.leadLamina) },
      { label: "Dentes", value: flagValue(lead.leadDentes) },
      { label: "Rodante", value: flagValue(lead.leadRodante) },
      { label: "Disponibilidade", value: flagValue(lead.leadDisponibilidade) },
      { label: "Reconexao", value: flagValue(lead.leadReconexao) },
      {
        label: "Transferencia de AOR",
        value: flagValue(lead.leadTransferenciaDeAor),
      },
    ];
  }, [lead]);

  if (!open) return null;

  return (
    <div
      className="fixed inset-0 z-[9999]"
      role="dialog"
      aria-modal="true"
      aria-label="Detalhes do lead"
    >
      <div
        className="absolute inset-0 bg-slate-900/40 backdrop-blur-[1px]"
        onClick={onClose}
      />

      <aside
        className="absolute right-0 top-0 flex h-full w-full max-w-[640px] flex-col border-l border-slate-200 bg-slate-50 shadow-2xl"
        onClick={(e) => e.stopPropagation()}
      >
        {lead ? (
          <LeadHeader lead={lead} onClose={onClose} />
        ) : (
          <div className="sticky top-0 z-10 border-b border-slate-200 bg-white/90 px-5 py-4 backdrop-blur">
            <div className="flex items-center justify-between">
              <div className="text-sm font-semibold text-slate-900">
                Nenhum lead selecionado
              </div>
              <button
                type="button"
                onClick={onClose}
                aria-label="Fechar"
                className="inline-flex h-9 w-9 items-center justify-center rounded-lg border border-slate-200 bg-white text-slate-700 transition hover:border-slate-300 hover:text-slate-900"
              >
                X
              </button>
            </div>
          </div>
        )}

        <div className="flex-1 overflow-y-auto">
          {lead ? (
            <div className="space-y-3 px-5 py-4">
              <CollapsibleSection title="Resumo do lead" defaultOpen>
                <KeyValueGrid items={summaryItems} />
              </CollapsibleSection>

              <CollapsibleSection title="Equipamento" defaultOpen>
                <KeyValueGrid items={equipmentItems} />
              </CollapsibleSection>

              <CollapsibleSection title="Tipos do lead" defaultOpen>
                <div className="flex flex-wrap gap-2">
                  {(lead.tipoLeadList?.length
                    ? lead.tipoLeadList
                    : [lead.tipoLead]
                  ).map((tipo) => (
                    <Badge key={tipo} tone={leadTypeTone[tipo]}>
                      {leadTypeLabel[tipo]}
                    </Badge>
                  ))}
                </div>
              </CollapsibleSection>

              <CollapsibleSection title="Eventos do lead" defaultOpen>
                {!hasLeadId ? (
                  <div className="text-sm text-slate-600">
                    Lead sem identificador valido.
                  </div>
                ) : null}

                {hasLeadId && eventsState.status === "loading" ? (
                  <div className="text-sm text-slate-600">
                    Carregando eventos do lead...
                  </div>
                ) : null}

                {hasLeadId && eventsState.status === "error" ? (
                  <div className="rounded-xl border border-rose-200 bg-rose-50 px-4 py-3 text-sm text-rose-900">
                    <div className="font-semibold">
                      Erro ao carregar eventos
                    </div>
                    <div className="mt-1">{eventsState.message}</div>
                    <button
                      type="button"
                      onClick={() => setEventsReloadNonce((prev) => prev + 1)}
                      className="mt-3 inline-flex items-center justify-center rounded-lg border border-rose-300 bg-white px-3 py-2 text-xs font-semibold text-rose-700 transition hover:border-rose-400 hover:text-rose-900"
                    >
                      Tentar novamente
                    </button>
                  </div>
                ) : null}

                {hasLeadId && eventsState.status === "success" ? (
                  eventsState.data.length ? (
                    <div className="space-y-2">
                      {eventsState.data.map((event, index) => {
                        const meta = event.action
                          ? leadActionMeta.get(event.action)
                          : null;
                        const label = meta?.label ?? event.action ?? "Acao";
                        const description = meta?.description ?? null;
                        const when = formatEventDate(event.occurredAt);
                        const actor = formatActorName(event.actorName);
                        const payload = event.payload ?? {};
                        const noteRaw =
                          typeof payload.note === "string"
                            ? payload.note.trim()
                            : "";
                        const reasonRaw =
                          typeof payload.reason === "string"
                            ? payload.reason.trim()
                            : "";
                        const assignee =
                          typeof payload.assignee === "string"
                            ? payload.assignee.trim()
                            : "";
                        const osValue =
                          typeof payload.os === "string"
                            ? payload.os.trim()
                            : "";
                        const partsValue = formatMoney(payload.parts_value) ?? "";
                        const laborValue = formatMoney(payload.labor_value) ?? "";
                        const totalValue = formatMoney(
                          (parseMoney(payload.parts_value) ?? 0) +
                            (parseMoney(payload.labor_value) ?? 0)
                        );
                        const valorValue =
                          totalValue ??
                          (typeof payload.valor === "string"
                            ? payload.valor.trim()
                            : "");
                        const methodValue =
                          typeof payload.method === "string"
                            ? payload.method.trim()
                            : "";
                        const statusByAction: Record<string, string> = {
                          assign: "atribuido",
                          register_contact: "em contato",
                          discard: "descartado",
                          close_without_os: "fechado_sem_os",
                          close_with_os: "fechado_com_os",
                        };
                        const statusValue = event.action
                          ? statusByAction[event.action] ?? ""
                          : "";
                        const statusLabel = statusValue
                          ? LEAD_STATUS_LABELS[statusValue] ?? statusValue
                          : "";
                        const descriptionNodes = description
                          ? renderTemplate(description, {
                              actor,
                              note: noteRaw ? truncateText(noteRaw) : "...",
                              reason: reasonRaw
                                ? truncateText(reasonRaw, 90)
                                : "...",
                              assignee: assignee || "...",
                              os: osValue || "...",
                              valor: valorValue || "...",
                              method: methodValue || "manual",
                              status: statusLabel || "...",
                            })
                          : null;
                        const payloadLines = summarizePayload(
                          event.payload,
                          event.action
                        );

                        return (
                          <div
                            key={`${event.action ?? "event"}-${index}`}
                            className="rounded-xl border border-slate-200 bg-white p-3"
                          >
                            <div className="flex items-start gap-3">
                              <div className="min-w-0 flex-1">
                                <div className="text-sm font-semibold text-slate-900 break-words">
                                  {descriptionNodes ?? label}
                                </div>
                              </div>
                              <div className="flex-shrink-0 text-right text-xs text-slate-400">
                                {when}
                              </div>
                            </div>
                            {payloadLines.length ? (
                              <div className="mt-2 text-xs text-slate-600">
                                {payloadLines.join(" | ")}
                              </div>
                            ) : null}
                          </div>
                        );
                      })}
                    </div>
                  ) : (
                    <div className="text-sm text-slate-600">
                      Nenhum evento registrado para este lead.
                    </div>
                  )
                ) : null}
              </CollapsibleSection>

              <CollapsibleSection title="Sinais do banco" defaultOpen={false}>
                <KeyValueGrid items={bancoItems} />
              </CollapsibleSection>
            </div>
          ) : (
            <div className="px-5 py-4 text-sm text-slate-600">
              Selecione um lead para visualizar os detalhes.
            </div>
          )}
        </div>
      </aside>
    </div>
  );
}



================================================
FILE: src/components/LeadServiceOrdersList.tsx
================================================
"use client";

import { useMemo, useState } from "react";
import { Lead, LeadCategory, LeadServiceOrder } from "@/lib/domain";
import type { ActionDefinition, EventPayload } from "@/lib/events";
import { updateLeadServiceOrder } from "@/lib/api";
import { ESTADOS, FiltersState, LEAD_TYPES, REGIOES } from "@/lib/filters";
import { ActionModal } from "@/components/ActionModal";
import { Badge } from "@/components/Badge";
import { FiltersBar } from "@/components/FiltersBar";
import { useToast } from "@/components/ToastProvider";

type LeadServiceOrdersListProps = {
  orders: LeadServiceOrder[];
  filters: FiltersState;
  onFiltersChange: (filters: FiltersState) => void;
  onLeadSelect?: (lead: Lead) => void;
  onOrderUpdated?: (update: ServiceOrderUpdate) => void;
  loading?: boolean;
  pageSize?: number;
};

type ServiceOrderUpdate = {
  id: number;
  partsValue: number;
  laborValue: number;
  note: string | null;
  updatedAt: string;
};

type ServiceOrderAction = "update_values";

const SERVICE_ORDER_ACTIONS: ActionDefinition<ServiceOrderAction>[] = [
  {
    id: "update_values",
    label: "Atualizar valores",
    description: "Atualiza os valores da OS.",
    requiresPartsValue: true,
    requiresLaborValue: true,
  },
];

type ColumnId =
  | "os"
  | "lead"
  | "cliente"
  | "consultor"
  | "chassi"
  | "tipoLead"
  | "valores"
  | "atualizadoEm"
  | "acoes";

const dateFormatter = new Intl.DateTimeFormat("pt-BR", {
  hour: "2-digit",
  minute: "2-digit",
});

const dateOnlyFormatter = new Intl.DateTimeFormat("pt-BR", {
  day: "2-digit",
  month: "short",
  year: "numeric",
});

const currencyFormatter = new Intl.NumberFormat("pt-BR", {
  style: "currency",
  currency: "BRL",
});

const leadTypeTone: Record<LeadCategory, Parameters<typeof Badge>[0]["tone"]> =
  {
    preventiva: "sky",
    garantia_basica: "amber",
    garantia_estendida: "amber",
    reforma_componentes: "violet",
    lamina: "emerald",
    dentes: "emerald",
    rodante: "emerald",
    disponibilidade: "sky",
    reconexao: "slate",
    transferencia_aor: "slate",
    pops: "slate",
    outros: "stone",
    indefinido: "stone",
  };

const leadTypeLabel: Record<LeadCategory, string> = {
  preventiva: "Preventiva",
  garantia_basica: "Garantia basica",
  garantia_estendida: "Garantia estendida",
  reforma_componentes: "Reforma de componentes",
  lamina: "Lamina",
  dentes: "Dentes",
  rodante: "Rodante",
  disponibilidade: "Disponibilidade",
  reconexao: "Reconexao",
  transferencia_aor: "Transferencia de AOR",
  pops: "POPs",
  outros: "Outros",
  indefinido: "Indefinido",
};

const columnLabels: Record<ColumnId, string> = {
  os: "OS",
  lead: "Lead",
  cliente: "Cliente",
  consultor: "Consultor",
  chassi: "Chassi",
  tipoLead: "Tipo de lead",
  valores: "Valores",
  atualizadoEm: "Atualizado em",
  acoes: "Acoes",
};

const columnWidths: Record<ColumnId, string> = {
  os: "0.8fr",
  lead: "1.2fr",
  cliente: "1.4fr",
  consultor: "1fr",
  chassi: "1.1fr",
  tipoLead: "1.2fr",
  valores: "1.1fr",
  atualizadoEm: "1fr",
  acoes: "0.7fr",
};

const buildColumnOrder = (
  groupByEmpresa?: boolean,
  groupByChassi?: boolean,
): ColumnId[] => {
  const base: ColumnId[] = [
    "os",
    "lead",
    "cliente",
    "consultor",
    "chassi",
    "tipoLead",
    "valores",
    "atualizadoEm",
    "acoes",
  ];
  const prioritized: ColumnId[] = [];
  if (groupByEmpresa) prioritized.push("cliente");
  if (groupByChassi) prioritized.push("chassi");
  return [...new Set([...prioritized, ...base])];
};

const formatDateParts = (iso: string) => {
  const date = new Date(iso);
  if (Number.isNaN(date.getTime())) {
    return { time: "N/A", date: "N/A" };
  }
  return {
    time: dateFormatter.format(date),
    date: dateOnlyFormatter.format(date),
  };
};

function ServiceOrderActionCell({
  order,
  onUpdated,
}: {
  order: LeadServiceOrder;
  onUpdated?: (update: ServiceOrderUpdate) => void;
}) {
  const toast = useToast();
  const [open, setOpen] = useState(false);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const handleConfirm = async (
    _action: ServiceOrderAction,
    payload: EventPayload,
  ) => {
    setError(null);
    setLoading(true);
    try {
      const updated = await updateLeadServiceOrder(order.id, {
        partsValue: payload.parts_value ?? "",
        laborValue: payload.labor_value ?? "",
        note: typeof payload.note === "string" ? payload.note : "",
      });
      onUpdated?.({
        id: updated.id,
        partsValue: updated.partsValue,
        laborValue: updated.laborValue,
        note: updated.note ?? null,
        updatedAt: updated.updatedAt,
      });
      toast.push({
        variant: "success",
        message: "OS atualizada com sucesso.",
      });
      setOpen(false);
    } catch (err: any) {
      const message =
        typeof err?.message === "string" && err.message
          ? err.message
          : "Nao foi possivel atualizar a OS.";
      setError(message);
      toast.push({ variant: "error", message });
    } finally {
      setLoading(false);
    }
  };

  return (
    <>
      <button
        type="button"
        onClick={(e) => {
          e.stopPropagation();
          setError(null);
          setOpen(true);
        }}
        onMouseDown={(e) => e.stopPropagation()}
        className="inline-flex items-center gap-2 rounded-lg border border-slate-200 bg-white px-3 py-1.5 text-xs font-semibold text-slate-700 transition hover:border-slate-300 hover:text-slate-900"
      >
        Acoes
      </button>

      <ActionModal<ServiceOrderAction>
        open={open}
        entity="lead"
        actions={SERVICE_ORDER_ACTIONS}
        defaultAction="update_values"
        initialPayload={{
          parts_value: order.partsValue,
          labor_value: order.laborValue,
          note: order.note ?? "",
        }}
        loading={loading}
        error={error}
        onClose={() => setOpen(false)}
        onConfirm={handleConfirm}
      />
    </>
  );
}

export function LeadServiceOrdersList({
  orders,
  filters,
  onFiltersChange,
  onLeadSelect,
  onOrderUpdated,
  loading = false,
  pageSize = 10,
}: LeadServiceOrdersListProps) {
  const skeletonRows = useMemo(
    () => Array.from({ length: Math.max(1, pageSize) }, (_, i) => i),
    [pageSize],
  );
  const regiaoOptions = useMemo(() => REGIOES.slice(), []);
  const estadoOptions = useMemo(() => ESTADOS.slice(), []);
  const tipoLeadOptions = useMemo(() => LEAD_TYPES.slice(), []);
  const columnOrder = useMemo(
    () => buildColumnOrder(filters.groupByEmpresa, filters.groupByChassi),
    [filters.groupByChassi, filters.groupByEmpresa],
  );

  const gridTemplateColumns = columnOrder
    .map((col) => columnWidths[col])
    .join(" ");

  const makeGroupKey = useMemo(() => {
    return (order: LeadServiceOrder) => {
      const parts: string[] = [];
      if (filters.groupByEmpresa) {
        parts.push(order.lead.clienteBaseEnriquecida ?? "Sem cliente");
      }
      if (filters.groupByChassi) {
        parts.push(order.lead.chassi ?? "Sem chassi");
      }
      return parts.join("::");
    };
  }, [filters.groupByChassi, filters.groupByEmpresa]);

  const groupedOrders = useMemo(() => {
    return orders.reduce<
      { order: LeadServiceOrder; groupKey: string; groupIndex: number }[]
    >((acc, order) => {
      const groupKey = makeGroupKey(order);
      const last = acc[acc.length - 1];
      const groupIndex =
        last && last.groupKey === groupKey
          ? last.groupIndex
          : (last?.groupIndex ?? -1) + 1;
      acc.push({ order, groupKey, groupIndex });
      return acc;
    }, []);
  }, [makeGroupKey, orders]);

  const handleToggle = (key: "groupByEmpresa" | "groupByChassi") => {
    onFiltersChange({ ...filters, [key]: !filters[key] });
  };

  return (
    <div className="space-y-4">
      <FiltersBar
        value={filters}
        regiaoOptions={regiaoOptions}
        estadoOptions={estadoOptions}
        tipoLeadOptions={tipoLeadOptions.map((id) => id)}
        reserveStatusSlot
        searchPlaceholder="Buscar por OS, chassi, modelo, cidade ou consultor"
        regiaoLabel="Regiao"
        estadoLabel="Estado"
        tipoLeadLabel="Tipo de lead"
        onFiltersChange={onFiltersChange}
      />

      <div className="flex flex-wrap items-center gap-2 rounded-xl border border-slate-200 bg-white px-4 py-3 shadow-sm">
        <span className="text-xs font-semibold uppercase tracking-wide text-slate-500">
          Agrupar
        </span>
        <button
          type="button"
          onClick={() => handleToggle("groupByEmpresa")}
          aria-pressed={filters.groupByEmpresa}
          className={`rounded-full border px-3 py-1 text-xs font-semibold transition ${
            filters.groupByEmpresa
              ? "border-sky-300 bg-sky-50 text-sky-800"
              : "border-slate-200 bg-white text-slate-700 hover:border-slate-300 hover:text-slate-900"
          }`}
        >
          Empresa
        </button>
        <button
          type="button"
          onClick={() => handleToggle("groupByChassi")}
          aria-pressed={filters.groupByChassi}
          className={`rounded-full border px-3 py-1 text-xs font-semibold transition ${
            filters.groupByChassi
              ? "border-sky-300 bg-sky-50 text-sky-800"
              : "border-slate-200 bg-white text-slate-700 hover:border-slate-300 hover:text-slate-900"
          }`}
        >
          Chassi
        </button>
      </div>

      <div className="overflow-hidden rounded-xl border border-slate-200 bg-white shadow-sm">
        <div
          className="grid gap-4 border-b border-slate-200 bg-slate-50 px-5 py-3 text-xs font-semibold uppercase tracking-wide text-slate-600"
          style={{ gridTemplateColumns }}
        >
          {columnOrder.map((col) => (
            <span key={col}>{columnLabels[col]}</span>
          ))}
        </div>

        <div className="divide-y divide-slate-200">
          {loading
            ? skeletonRows.map((index) => (
                <div
                  key={`os-skeleton-${index}`}
                  className="grid min-w-0 items-center gap-4 px-5 py-3 text-sm min-h-[56px]"
                  style={{ gridTemplateColumns }}
                >
                  {columnOrder.map((col) => (
                    <div key={`${index}-${col}`} className="min-w-0">
                      <div className="h-4 w-4/5 rounded-full bg-slate-200 animate-pulse" />
                    </div>
                  ))}
                </div>
              ))
            : groupedOrders.map(({ order, groupIndex }) => {
                const isStriped = filters.groupByEmpresa || filters.groupByChassi;
                const backgroundClass =
                  isStriped && groupIndex % 2 === 1 ? "bg-slate-50" : "bg-white";
                const lead = order.lead;
                const totalValue = order.partsValue + order.laborValue;
                const cells: Record<ColumnId, React.ReactNode> = {
                  os: (
                    <Badge tone="sky" className="max-w-[120px] truncate">
                      {order.osNumber}
                    </Badge>
                  ),
                  lead: (
                    <div className="min-w-0">
                      <span className="block truncate font-semibold text-slate-900">
                        Lead #{lead.id}
                      </span>
                      <span className="block truncate text-xs text-slate-500">
                        Criado por: {lead.createdBy ?? "Nao informado"}
                      </span>
                    </div>
                  ),
                  cliente: (
                    <span className="block max-w-[220px] truncate text-slate-800">
                      {lead.clienteBaseEnriquecida ?? "Sem cliente"}
                    </span>
                  ),
                  consultor: (
                    <span className="block max-w-[180px] truncate text-slate-800">
                      {lead.consultor ?? "Sem consultor"}
                    </span>
                  ),
                  chassi: (
                    <Badge tone="emerald" className="max-w-[160px] truncate">
                      {lead.chassi ?? "Sem chassi"}
                    </Badge>
                  ),
                  tipoLead: (
                    <div className="flex flex-wrap gap-2">
                      {(lead.tipoLeadList?.length
                        ? lead.tipoLeadList
                        : [lead.tipoLead]
                      ).map((tipo) => (
                        <Badge key={tipo} tone={leadTypeTone[tipo]}>
                          {leadTypeLabel[tipo]}
                        </Badge>
                      ))}
                    </div>
                  ),
                  valores: (
                    <div className="min-w-0 text-xs text-slate-600">
                      <div className="truncate">
                        Pecas: {currencyFormatter.format(order.partsValue)}
                      </div>
                      <div className="truncate">
                        Mao de obra: {currencyFormatter.format(order.laborValue)}
                      </div>
                      <div className="truncate font-semibold text-slate-800">
                        Total: {currencyFormatter.format(totalValue)}
                      </div>
                    </div>
                  ),
                  atualizadoEm: (() => {
                    const parts = formatDateParts(order.updatedAt);
                    return (
                      <div className="min-w-0 leading-tight">
                        <span className="block truncate text-xs font-semibold text-slate-700">
                          {parts.time}
                        </span>
                        <span className="block truncate text-xs text-slate-500">
                          {parts.date}
                        </span>
                      </div>
                    );
                  })(),
                  acoes: (
                    <ServiceOrderActionCell
                      order={order}
                      onUpdated={onOrderUpdated}
                    />
                  ),
                };

                return (
                  <div
                    key={order.id}
                    role={onLeadSelect ? "button" : undefined}
                    tabIndex={onLeadSelect ? 0 : undefined}
                    onClick={onLeadSelect ? () => onLeadSelect(lead) : undefined}
                    onKeyDown={
                      onLeadSelect
                        ? (e) => {
                            if (e.key === "Enter" || e.key === " ") {
                              e.preventDefault();
                              onLeadSelect(lead);
                            }
                          }
                        : undefined
                    }
                    className={`grid min-w-0 items-center gap-4 px-5 py-3 text-sm text-slate-800 hover:bg-slate-50 ${backgroundClass} ${
                      onLeadSelect
                        ? "cursor-pointer focus:outline-none focus:ring-2 focus:ring-sky-200"
                        : ""
                    }`}
                    style={{ gridTemplateColumns }}
                  >
                    {columnOrder.map((col) => (
                      <div key={col} className="min-w-0">
                        {cells[col]}
                      </div>
                    ))}
                  </div>
                );
              })}
          {!loading && orders.length === 0 && (
            <div className="px-5 py-4 text-sm text-slate-500">
              Nenhuma OS encontrada com esses filtros.
            </div>
          )}
        </div>
      </div>
    </div>
  );
}



================================================
FILE: src/components/LeadsFiltersPanel.tsx
================================================
"use client";

import { useMemo } from "react";
import {
  ESTADOS,
  FiltersState,
  LEAD_STATUS_OPTIONS,
  LEAD_TYPES,
  REGIOES,
} from "@/lib/filters";
import { FiltersBar } from "./FiltersBar";

type LeadsFiltersPanelProps = {
  filters: FiltersState;
  onFiltersChange: (filters: FiltersState) => void;
  showGrouping?: boolean;
};

export function LeadsFiltersPanel({
  filters,
  onFiltersChange,
  showGrouping = true,
}: LeadsFiltersPanelProps) {
  const regiaoOptions = useMemo(() => REGIOES.slice(), []);
  const estadoOptions = useMemo(() => ESTADOS.slice(), []);
  const tipoLeadOptions = useMemo(() => LEAD_TYPES.slice(), []);
  const resolvedStatusOptions = useMemo(
    () => LEAD_STATUS_OPTIONS.slice(),
    [],
  );

  const handleToggle = (key: "groupByEmpresa" | "groupByChassi") => {
    onFiltersChange({ ...filters, [key]: !filters[key] });
  };

  return (
    <div className="space-y-4">
      <FiltersBar
        value={filters}
        regiaoOptions={regiaoOptions}
        estadoOptions={estadoOptions}
        tipoLeadOptions={tipoLeadOptions.map((id) => id)}
        statusOptions={resolvedStatusOptions}
        searchPlaceholder="Buscar por chassi, modelo, cidade, consultor ou cliente"
        regiaoLabel="Regiao"
        estadoLabel="Estado"
        tipoLeadLabel="Tipo de lead"
        onFiltersChange={onFiltersChange}
      />

      {showGrouping ? (
        <div className="flex flex-wrap items-center gap-2 rounded-xl border border-slate-200 bg-white px-4 py-3 shadow-sm">
          <span className="text-xs font-semibold uppercase tracking-wide text-slate-500">
            Agrupar
          </span>
          <button
            type="button"
            onClick={() => handleToggle("groupByEmpresa")}
            aria-pressed={filters.groupByEmpresa}
            className={`rounded-full border px-3 py-1 text-xs font-semibold transition ${
              filters.groupByEmpresa
                ? "border-sky-300 bg-sky-50 text-sky-800"
                : "border-slate-200 bg-white text-slate-700 hover:border-slate-300 hover:text-slate-900"
            }`}
          >
            Empresa
          </button>
          <button
            type="button"
            onClick={() => handleToggle("groupByChassi")}
            aria-pressed={filters.groupByChassi}
            className={`rounded-full border px-3 py-1 text-xs font-semibold transition ${
              filters.groupByChassi
                ? "border-sky-300 bg-sky-50 text-sky-800"
                : "border-slate-200 bg-white text-slate-700 hover:border-slate-300 hover:text-slate-900"
            }`}
          >
            Chassi
          </button>
        </div>
      ) : null}
    </div>
  );
}



================================================
FILE: src/components/LeadsKanban.tsx
================================================
"use client";

import { useMemo } from "react";
import { Lead, LeadCategory } from "@/lib/domain";
import {
  ESTADOS,
  FiltersState,
  LEAD_STATUS_LABELS,
  LEAD_STATUS_OPTIONS,
  LEAD_TYPES,
  REGIOES,
} from "@/lib/filters";
import { Badge } from "@/components/Badge";
import { FiltersBar } from "@/components/FiltersBar";

type LeadsKanbanProps = {
  leads: Lead[];
  filters: FiltersState;
  onFiltersChange: (filters: FiltersState) => void;
  onLeadSelect?: (lead: Lead) => void;
  statusOptions?: Array<string | StatusOption>;
  loading?: boolean;
  pageSize?: number;
};

type StatusOption = {
  value: string;
  label: string;
};

type StatusColumn = {
  id: string;
  label: string;
  tone: Parameters<typeof Badge>[0]["tone"];
};

const dateFormatter = new Intl.DateTimeFormat("pt-BR", {
  hour: "2-digit",
  minute: "2-digit",
});

const dateOnlyFormatter = new Intl.DateTimeFormat("pt-BR", {
  day: "2-digit",
  month: "short",
  year: "numeric",
});

const numberFormatter = new Intl.NumberFormat("pt-BR");

const leadTypeTone: Record<LeadCategory, Parameters<typeof Badge>[0]["tone"]> =
  {
    preventiva: "sky",
    garantia_basica: "amber",
    garantia_estendida: "amber",
    reforma_componentes: "violet",
    lamina: "emerald",
    dentes: "emerald",
    rodante: "emerald",
    disponibilidade: "sky",
    reconexao: "slate",
    transferencia_aor: "slate",
    pops: "slate",
    outros: "stone",
    indefinido: "stone",
  };

const leadTypeLabel: Record<LeadCategory, string> = {
  preventiva: "Preventiva",
  garantia_basica: "Garantia basica",
  garantia_estendida: "Garantia estendida",
  reforma_componentes: "Reforma de componentes",
  lamina: "Lamina",
  dentes: "Dentes",
  rodante: "Rodante",
  disponibilidade: "Disponibilidade",
  reconexao: "Reconexao",
  transferencia_aor: "Transferencia de AOR",
  pops: "POPs",
  outros: "Outros",
  indefinido: "Indefinido",
};

const pickStatusTone = (
  status: string | null
): Parameters<typeof Badge>[0]["tone"] => {
  const normalized = status?.trim().toLowerCase();
  if (!normalized) return "stone";
  if (normalized.includes("fech") || normalized.includes("conclu"))
    return "emerald";
  if (normalized.includes("cancel")) return "rose";
  if (normalized.includes("novo")) return "sky";
  if (normalized.includes("pend")) return "amber";
  return "slate";
};

const formatDateParts = (iso?: string | null) => {
  if (!iso) {
    return { time: "N/A", date: "N/A" };
  }
  const date = new Date(iso);
  if (Number.isNaN(date.getTime())) {
    return { time: "N/A", date: "N/A" };
  }
  return {
    time: dateFormatter.format(date),
    date: dateOnlyFormatter.format(date),
  };
};

const normalizeStatus = (value?: string | null) =>
  value?.trim().toLowerCase() ?? "";

const STATUS_KEYS = new Map(
  Object.keys(LEAD_STATUS_LABELS).map((key) => [key.toLowerCase(), key])
);

const resolveStatusLabel = (value: string | null) => {
  const normalized = normalizeStatus(value);
  if (!normalized) return "Sem status";
  const key = STATUS_KEYS.get(normalized);
  return key ? LEAD_STATUS_LABELS[key] ?? key : value ?? "Sem status";
};

const formatLocation = (lead: Lead) => {
  const parts = [lead.city, lead.estado]
    .map((entry) => entry?.trim() ?? "")
    .filter(Boolean);
  return parts.length ? parts.join(" / ") : "Sem cidade";
};

function KanbanCard({
  lead,
  onSelect,
}: {
  lead: Lead;
  onSelect?: (lead: Lead) => void;
}) {
  const leadTypes = lead.tipoLeadList?.length
    ? lead.tipoLeadList
    : [lead.tipoLead];
  const displayedTypes = leadTypes.slice(0, 2);
  const extraTypes = leadTypes.length - displayedTypes.length;
  const referenceDate = lead.updatedAt ?? lead.importedAt;
  const dateParts = formatDateParts(referenceDate);
  const subtitle = [lead.chassi ?? "Sem chassi", lead.modelName ?? "N/A"]
    .filter(Boolean)
    .join(" - ");
  const statusLabel = resolveStatusLabel(lead.status);

  return (
    <button
      type="button"
      onClick={() => onSelect?.(lead)}
      className="w-full rounded-xl border border-slate-200 bg-white p-3 text-left shadow-sm transition hover:border-slate-300 hover:shadow"
    >
      <div className="flex items-start justify-between gap-2">
        <div className="flex flex-wrap items-center gap-2">
          <Badge tone="slate">Lead #{lead.id}</Badge>
          <Badge tone={pickStatusTone(lead.status)}>{statusLabel}</Badge>
        </div>
        <div className="text-right text-[11px] text-slate-400">
          <div className="font-semibold text-slate-500">{dateParts.time}</div>
          <div>{dateParts.date}</div>
        </div>
      </div>

      <div className="mt-3 min-w-0">
        <div className="text-sm font-semibold text-slate-900 line-clamp-2">
          {lead.clienteBaseEnriquecida ?? "Sem cliente"}
        </div>
        <div className="mt-1 text-xs text-slate-500 line-clamp-2">
          {subtitle}
        </div>
      </div>

      <div className="mt-3 flex flex-wrap gap-2">
        {displayedTypes.map((tipo) => (
          <Badge key={tipo} tone={leadTypeTone[tipo]}>
            {leadTypeLabel[tipo]}
          </Badge>
        ))}
        {extraTypes > 0 ? <Badge tone="stone">+{extraTypes}</Badge> : null}
        {lead.regional ? <Badge tone="sky">{lead.regional}</Badge> : null}
      </div>

      <div className="mt-3 space-y-1 text-xs text-slate-600">
        <div>{formatLocation(lead)}</div>
        <div>
          Consultor: {lead.consultor?.trim() ? lead.consultor : "Sem consultor"}
        </div>
        <div>
          Horimetro:{" "}
          {lead.horimetroAtualMachineList !== null
            ? `${numberFormatter.format(lead.horimetroAtualMachineList)} h`
            : "N/A"}
        </div>
      </div>
    </button>
  );
}

export function LeadsKanban({
  leads,
  filters,
  onFiltersChange,
  onLeadSelect,
  statusOptions,
  loading = false,
  pageSize = 10,
}: LeadsKanbanProps) {
  const normalizedStatusOptions = useMemo<StatusOption[]>(() => {
    const source: Array<string | StatusOption> = statusOptions ?? [
      ...LEAD_STATUS_OPTIONS,
    ];
    return source.map((opt): StatusOption =>
      typeof opt === "string"
        ? { value: opt, label: opt }
        : { value: opt.value, label: opt.label }
    );
  }, [statusOptions]);

  const statusKeyByValue = useMemo(
    () =>
      new Map(
        normalizedStatusOptions.map((opt) => [
          opt.value.toLowerCase(),
          opt.value,
        ])
      ),
    [normalizedStatusOptions]
  );

  const regiaoOptions = useMemo(() => REGIOES.slice(), []);
  const estadoOptions = useMemo(() => ESTADOS.slice(), []);
  const tipoLeadOptions = useMemo(() => LEAD_TYPES.slice(), []);
  const resolvedStatusOptions = useMemo(
    () => normalizedStatusOptions.slice(),
    [normalizedStatusOptions]
  );

  const baseColumns = useMemo<StatusColumn[]>(() => {
    return normalizedStatusOptions.map((opt) => ({
      id: opt.value,
      label: opt.label ?? opt.value,
      tone: pickStatusTone(opt.value),
    }));
  }, [normalizedStatusOptions]);

  const activeBaseColumns = useMemo(() => {
    const requested = filters.status
      .map((status) => normalizeStatus(status))
      .filter(Boolean);
    if (!requested.length) return baseColumns;
    const requestedSet = new Set(requested);
    const filtered = baseColumns.filter((col) =>
      requestedSet.has(col.id.toLowerCase())
    );
    return filtered.length ? filtered : baseColumns;
  }, [baseColumns, filters.status]);

  const visibleLeads = loading ? [] : leads;

  const { columns, groupedLeads } = useMemo(() => {
    const grouped = new Map<string, Lead[]>();
    activeBaseColumns.forEach((col) => grouped.set(col.id, []));

    const semStatus: Lead[] = [];
    const outros: Lead[] = [];

    visibleLeads.forEach((lead) => {
      const normalized = normalizeStatus(lead.status);
      if (!normalized) {
        semStatus.push(lead);
        return;
      }
      const key = statusKeyByValue.get(normalized);
      if (key && grouped.has(key)) {
        grouped.get(key)?.push(lead);
      } else {
        outros.push(lead);
      }
    });

    const nextColumns = [...activeBaseColumns];
    if (semStatus.length) {
      nextColumns.push({
        id: "sem_status",
        label: "Sem status",
        tone: "stone",
      });
      grouped.set("sem_status", semStatus);
    }
    if (outros.length) {
      nextColumns.push({ id: "outros", label: "Outros", tone: "slate" });
      grouped.set("outros", outros);
    }

    return { columns: nextColumns, groupedLeads: grouped };
  }, [activeBaseColumns, statusKeyByValue, visibleLeads]);

  const skeletonCount = Math.max(
    2,
    Math.ceil(pageSize / Math.max(1, activeBaseColumns.length))
  );

  const skeletonCards = useMemo(
    () => Array.from({ length: skeletonCount }, (_, i) => i),
    [skeletonCount]
  );

  return (
    <div className="space-y-4">
      {/* <FiltersBar
        value={filters}
        regiaoOptions={regiaoOptions}
        estadoOptions={estadoOptions}
        tipoLeadOptions={tipoLeadOptions.map((id) => id)}
        statusOptions={resolvedStatusOptions}
        searchPlaceholder="Buscar por chassi, modelo, cidade, consultor ou cliente"
        regiaoLabel="Regiao"
        estadoLabel="Estado"
        tipoLeadLabel="Tipo de lead"
        onFiltersChange={onFiltersChange}
      /> */}

      <div className="rounded-xl border border-slate-200 bg-slate-50 p-4 shadow-sm">
        <div className="flex items-center justify-between text-xs font-semibold uppercase tracking-wide text-slate-500">
          <span>Quadro kanban</span>
          <span>
            {loading ? "Carregando..." : `Mostrando ${leads.length} leads`}
          </span>
        </div>

        <div className="mt-4 overflow-x-auto pb-2">
          <div
            className="grid min-w-full gap-4"
            style={{
              gridTemplateColumns: `repeat(${columns.length}, minmax(240px, 1fr))`,
            }}
          >
            {columns.map((column) => {
              const columnLeads = groupedLeads.get(column.id) ?? [];
              return (
                <div key={column.id} className="w-full">
                  <div className="flex items-center justify-between rounded-lg border border-slate-200 bg-white px-3 py-2 shadow-sm">
                    <Badge tone={column.tone}>{column.label}</Badge>
                    <span className="text-xs font-semibold text-slate-500">
                      {loading ? "..." : columnLeads.length}
                    </span>
                  </div>
                  <div className="mt-3 space-y-3">
                    {loading
                      ? skeletonCards.map((index) => (
                          <div
                            key={`${column.id}-skeleton-${index}`}
                            className="rounded-xl border border-slate-200 bg-white p-3 shadow-sm"
                          >
                            <div className="h-4 w-3/5 rounded-full bg-slate-200 animate-pulse" />
                            <div className="mt-3 h-3 w-4/5 rounded-full bg-slate-200 animate-pulse" />
                            <div className="mt-2 h-3 w-2/3 rounded-full bg-slate-200 animate-pulse" />
                            <div className="mt-4 flex gap-2">
                              <div className="h-4 w-16 rounded-full bg-slate-200 animate-pulse" />
                              <div className="h-4 w-12 rounded-full bg-slate-200 animate-pulse" />
                            </div>
                          </div>
                        ))
                      : columnLeads.map((lead) => (
                          <KanbanCard
                            key={lead.id}
                            lead={lead}
                            onSelect={onLeadSelect}
                          />
                        ))}
                    {!loading &&
                    leads.length > 0 &&
                    columnLeads.length === 0 ? (
                      <div className="rounded-lg border border-dashed border-slate-200 bg-white px-3 py-6 text-center text-xs text-slate-400">
                        Sem leads neste status.
                      </div>
                    ) : null}
                  </div>
                </div>
              );
            })}
          </div>
        </div>

        {!loading && leads.length === 0 ? (
          <div className="mt-4 rounded-lg border border-dashed border-slate-200 bg-white px-4 py-3 text-sm text-slate-500">
            Nenhum lead encontrado com esses filtros.
          </div>
        ) : null}
      </div>
    </div>
  );
}



================================================
FILE: src/components/LeadsList.tsx
================================================
﻿"use client";

import { useMemo } from "react";
import { Lead, LeadCategory } from "@/lib/domain";
import { FiltersState, LEAD_STATUS_LABELS } from "@/lib/filters";
import { Badge } from "./Badge";
import { AssignLeadButton } from "./AssignLeadButton";
import { ActionButtonCell } from "./ActionButtonCell";
import { LeadsFiltersPanel } from "./LeadsFiltersPanel";

type LeadsListProps = {
  leads: Lead[];
  filters: FiltersState;
  onFiltersChange: (filters: FiltersState) => void;
  onLeadSelect?: (lead: Lead) => void;
  currentUserName?: string | null;
  onLeadAssigned?: (leadId: number, assignee: string) => void;
  onLeadStatusChange?: (leadId: number, status: string) => void;
  loading?: boolean;
  pageSize?: number;
  showFilters?: boolean;
  showGrouping?: boolean;
};

type ColumnId =
  | "regional"
  | "cidadeEstado"
  | "cliente"
  | "consultor"
  | "chassiModelo"
  | "tipoLead"
  | "status"
  | "horimetro"
  | "importadoEm"
  | "acoes";

const dateFormatter = new Intl.DateTimeFormat("pt-BR", {
  hour: "2-digit",
  minute: "2-digit",
});

const dateOnlyFormatter = new Intl.DateTimeFormat("pt-BR", {
  day: "2-digit",
  month: "short",
  year: "numeric",
});

const numberFormatter = new Intl.NumberFormat("pt-BR");

const leadTypeTone: Record<LeadCategory, Parameters<typeof Badge>[0]["tone"]> =
  {
    preventiva: "sky",
    garantia_basica: "amber",
    garantia_estendida: "amber",
    reforma_componentes: "violet",
    lamina: "emerald",
    dentes: "emerald",
    rodante: "emerald",
    disponibilidade: "sky",
    reconexao: "slate",
    transferencia_aor: "slate",
    pops: "slate",
    outros: "stone",
    indefinido: "stone",
  };

const leadTypeLabel: Record<LeadCategory, string> = {
  preventiva: "Preventiva",
  garantia_basica: "Garantia básica",
  garantia_estendida: "Garantia estendida",
  reforma_componentes: "Reforma de componentes",
  lamina: "Lâmina",
  dentes: "Dentes",
  rodante: "Rodante",
  disponibilidade: "Disponibilidade",
  reconexao: "Reconexão",
  transferencia_aor: "Transferência de AOR",
  pops: "POPs",
  outros: "Outros",
  indefinido: "Indefinido",
};

const formatDateParts = (iso: string) => {
  const date = new Date(iso);
  if (Number.isNaN(date.getTime())) {
    return { time: "N/A", date: "N/A" };
  }
  return {
    time: dateFormatter.format(date),
    date: dateOnlyFormatter.format(date),
  };
};

const pickStatusTone = (
  status: string | null
): Parameters<typeof Badge>[0]["tone"] => {
  const normalized = status?.trim().toLowerCase();
  if (!normalized) return "stone";
  if (normalized.includes("fech") || normalized.includes("conclu"))
    return "emerald";
  if (normalized.includes("cancel")) return "rose";
  if (normalized.includes("novo")) return "sky";
  if (normalized.includes("pend")) return "amber";
  return "slate";
};

const columnLabels: Record<ColumnId, string> = {
  regional: "Região",
  cidadeEstado: "Cidade / Estado",
  cliente: "Cliente",
  consultor: "Consultor",
  chassiModelo: "Chassi",
  tipoLead: "Tipo de lead",
  horimetro: "Horímetro",
  importadoEm: "Atualizado em",
  status: "Status",
  acoes: "Ações",
};

const columnWidths: Record<ColumnId, string> = {
  regional: "0.9fr",
  cidadeEstado: "1.5fr",
  cliente: "1.4fr",
  consultor: "1.1fr",
  chassiModelo: "1.3fr",
  tipoLead: "1.3fr",
  horimetro: "1fr",
  importadoEm: "1fr",
  status: "1fr",
  acoes: "0.8fr",
};

const buildColumnOrder = (
  groupByEmpresa?: boolean,
  groupByChassi?: boolean
): ColumnId[] => {
  const base: ColumnId[] = [
    "regional",
    "cidadeEstado",
    "cliente",
    "consultor",
    "chassiModelo",
    "tipoLead",
    "status",
    "horimetro",
    "importadoEm",
    "acoes",
  ];
  const prioritized: ColumnId[] = [];
  if (groupByEmpresa) prioritized.push("cliente");
  if (groupByChassi) prioritized.push("chassiModelo");
  return [...new Set([...prioritized, ...base])];
};

export function LeadsList({
  leads,
  filters,
  onFiltersChange,
  onLeadSelect,
  currentUserName,
  onLeadAssigned,
  onLeadStatusChange,
  loading = false,
  pageSize = 10,
  showFilters = true,
  showGrouping = true,
}: LeadsListProps) {
  const skeletonRows = useMemo(
    () => Array.from({ length: Math.max(1, pageSize) }, (_, i) => i),
    [pageSize]
  );
  const columnOrder = useMemo(
    () => buildColumnOrder(filters.groupByEmpresa, filters.groupByChassi),
    [filters.groupByChassi, filters.groupByEmpresa]
  );

  const gridTemplateColumns = columnOrder
    .map((col) => columnWidths[col])
    .join(" ");

  const makeGroupKey = useMemo(() => {
    return (lead: Lead) => {
      const parts: string[] = [];
      if (filters.groupByEmpresa) {
        parts.push(lead.clienteBaseEnriquecida ?? "Sem cliente");
      }
      if (filters.groupByChassi) {
        parts.push(lead.chassi ?? "Sem chassi");
      }
      return parts.join("::");
    };
  }, [filters.groupByChassi, filters.groupByEmpresa]);

  const groupedLeads = useMemo(() => {
    return leads.reduce<{ lead: Lead; groupKey: string; groupIndex: number }[]>(
      (acc, lead) => {
        const groupKey = makeGroupKey(lead);
        const last = acc[acc.length - 1];
        const groupIndex =
          last && last.groupKey === groupKey
            ? last.groupIndex
            : (last?.groupIndex ?? -1) + 1;
        acc.push({ lead, groupKey, groupIndex });
        return acc;
      },
      []
    );
  }, [leads, makeGroupKey]);

  return (
    <div className="space-y-4">
      {showFilters ? (
        <LeadsFiltersPanel
          filters={filters}
          onFiltersChange={onFiltersChange}
          showGrouping={showGrouping}
        />
      ) : null}

      <div className="overflow-hidden rounded-xl border border-slate-200 bg-white shadow-sm">
        <div
          className="grid gap-4 border-b border-slate-200 bg-slate-50 px-5 py-3 text-xs font-semibold uppercase tracking-wide text-slate-600"
          style={{ gridTemplateColumns }}
        >
          {columnOrder.map((col) => (
            <span key={col}>{columnLabels[col]}</span>
          ))}
        </div>

        <div className="divide-y divide-slate-200">
          {loading
            ? skeletonRows.map((index) => (
                <div
                  key={`lead-skeleton-${index}`}
                  className="grid min-w-0 items-center gap-4 px-5 py-3 text-sm min-h-[56px]"
                  style={{ gridTemplateColumns }}
                >
                  {columnOrder.map((col) => (
                    <div key={`${index}-${col}`} className="min-w-0">
                      <div className="h-4 w-4/5 rounded-full bg-slate-200 animate-pulse" />
                    </div>
                  ))}
                </div>
              ))
            : groupedLeads.map(({ lead, groupIndex }) => {
                const isStriped = filters.groupByEmpresa || filters.groupByChassi;
                const backgroundClass =
                  isStriped && groupIndex % 2 === 1 ? "bg-slate-50" : "bg-white";
                const hasConsultor = Boolean(lead.consultor?.trim());
                const canShowAssign =
                  !hasConsultor && Boolean(currentUserName?.trim());

                const cells: Record<ColumnId, React.ReactNode> = {
                  regional: (
                    <Badge tone="sky" className="max-w-[130px] truncate">
                      {lead.regional ?? "Sem regional"}
                    </Badge>
                  ),
                  cidadeEstado: (
                    <div className="flex min-w-0 flex-col gap-0.5">
                      <span className="truncate font-semibold text-slate-900">
                        {lead.city ?? "Cidade n?o informada"}
                      </span>
                      <span className="truncate text-xs text-slate-500">
                        {lead.estado ?? "Sem estado"}
                      </span>
                    </div>
                  ),
                  cliente: (
                    <span className="block max-w-[240px] truncate text-slate-800">
                      {lead.clienteBaseEnriquecida ?? "Sem cliente"}
                    </span>
                  ),
                  consultor: canShowAssign ? (
                    <AssignLeadButton
                      leadId={lead.id}
                      assigneeName={currentUserName}
                      onAssigned={(assignee) => onLeadAssigned?.(lead.id, assignee)}
                      className="rounded-md border border-slate-200 bg-white px-2 py-1 text-[11px] font-semibold text-slate-600 transition enabled:hover:border-slate-300 enabled:hover:text-slate-900 disabled:cursor-not-allowed disabled:opacity-60"
                    />
                  ) : (
                    <span className="block max-w-[180px] truncate text-slate-800">
                      {lead.consultor ?? "Sem consultor"}
                    </span>
                  ),
                  chassiModelo: (
                    <Badge tone="emerald" className="max-w-[170px] truncate">
                      {lead.chassi ?? "Sem chassi"}
                    </Badge>
                  ),
                  tipoLead: (
                    <div className="flex flex-wrap gap-2">
                      {(lead.tipoLeadList?.length
                        ? lead.tipoLeadList
                        : [lead.tipoLead]
                      ).map((tipo) => (
                        <Badge key={tipo} tone={leadTypeTone[tipo]}>
                          {leadTypeLabel[tipo]}
                        </Badge>
                      ))}
                    </div>
                  ),
                  status: (
                    <Badge
                      tone={pickStatusTone(lead.status)}
                      className="max-w-[160px] truncate"
                    >
                      {lead.status
                        ? LEAD_STATUS_LABELS[lead.status] ?? lead.status
                        : "Sem status"}
                    </Badge>
                  ),
                  horimetro: (
                    <span className="truncate text-slate-800">
                      {lead.horimetroAtualMachineList !== null
                        ? `${numberFormatter.format(
                            lead.horimetroAtualMachineList
                          )} h`
                        : "N/A"}
                    </span>
                  ),
                  importadoEm: (() => {
                    const referenceDate = lead.updatedAt ?? lead.importedAt;
                    const parts = formatDateParts(referenceDate);
                    return (
                      <div className="min-w-0 leading-tight">
                        <span className="block truncate text-xs font-semibold text-slate-700">
                          {parts.time}
                        </span>
                        <span className="block truncate text-xs text-slate-500">
                          {parts.date}
                        </span>
                      </div>
                    );
                  })(),
                  acoes: (
                    <ActionButtonCell
                      entity="lead"
                      leadId={lead.id}
                      leadStatus={lead.status}
                      onLeadStatusChange={onLeadStatusChange}
                    />
                  ),
                };

                return (
                  <div
                    key={lead.id}
                    role={onLeadSelect ? "button" : undefined}
                    tabIndex={onLeadSelect ? 0 : undefined}
                    onClick={onLeadSelect ? () => onLeadSelect(lead) : undefined}
                    onKeyDown={
                      onLeadSelect
                        ? (e) => {
                            if (e.key === "Enter" || e.key === " ") {
                              e.preventDefault();
                              onLeadSelect(lead);
                            }
                          }
                        : undefined
                    }
                    className={`grid min-w-0 items-center gap-4 px-5 py-3 text-sm text-slate-800 hover:bg-slate-50 ${backgroundClass} ${
                      onLeadSelect
                        ? "cursor-pointer focus:outline-none focus:ring-2 focus:ring-sky-200"
                        : ""
                    }`}
                    style={{ gridTemplateColumns }}
                  >
                    {columnOrder.map((col) => (
                      <div key={col} className="min-w-0">
                        {cells[col]}
                      </div>
                    ))}
                  </div>
                );
              })}
          {!loading && leads.length === 0 && (
            <div className="px-5 py-4 text-sm text-slate-500">
              {loading
                ? "Carregando leads..."
                : "Nenhum lead encontrado com esses filtros."}
            </div>
          )}
        </div>
      </div>
    </div>
  );
}



================================================
FILE: src/components/LeadsMapView.tsx
================================================
"use client";

import { useEffect, useMemo, useRef } from "react";
import type { LatLngBounds, Layer, Map as LeafletMap } from "leaflet";
import { Lead } from "@/lib/domain";

type MarkerClusterGroup = Layer & {
  addLayer: (layer: Layer) => void;
  clearLayers: () => void;
  getBounds: () => LatLngBounds;
};

type LeafletWithCluster = typeof import("leaflet") & {
  markerClusterGroup: (options?: Record<string, unknown>) => MarkerClusterGroup;
};

type LeadsMapViewProps = {
  leads: Lead[];
  onLeadSelect?: (lead: Lead) => void;
  visible?: boolean;
  loading?: boolean;
  error?: string | null;
};

type LeadPoint = {
  lead: Lead;
  lat: number;
  lng: number;
};

const DEFAULT_CENTER: [number, number] = [-14.235, -51.9253];
const DEFAULT_ZOOM = 4;
const BRAZIL_BOUNDS = {
  latMin: -33.8,
  latMax: 5.3,
  lngMin: -74.0,
  lngMax: -34.8,
};

const normalizeCoordinate = (
  value: unknown,
  min: number,
  max: number,
): number | null => {
  if (typeof value === "number") {
    return value >= min && value <= max ? value : null;
  }
  if (typeof value === "string") {
    const trimmed = value.trim();
    if (!trimmed) return null;
    const parsed = Number(trimmed.replace(",", "."));
    return parsed >= min && parsed <= max ? parsed : null;
  }
  return null;
};

const getLeadPoint = (lead: Lead): LeadPoint | null => {
  const record = lead as Record<string, unknown>;
  const lat =
    normalizeCoordinate(record.latitude, -90, 90) ??
    normalizeCoordinate(record.lat, -90, 90);
  const lng =
    normalizeCoordinate(record.longitude, -180, 180) ??
    normalizeCoordinate(record.lng, -180, 180);
  if (lat !== null && lng !== null) {
    return { lead, lat, lng };
  }

  // TEMP: mock lat/lng inside Brazil while leads have no coordinates.
  const seed = Number.isFinite(lead.id) ? lead.id : Date.now();
  const random = (value: number) => {
    const x = Math.sin(value) * 10000;
    return x - Math.floor(x);
  };
  const mockedLat =
    BRAZIL_BOUNDS.latMin +
    random(seed) * (BRAZIL_BOUNDS.latMax - BRAZIL_BOUNDS.latMin);
  const mockedLng =
    BRAZIL_BOUNDS.lngMin +
    random(seed + 1) * (BRAZIL_BOUNDS.lngMax - BRAZIL_BOUNDS.lngMin);
  return { lead, lat: mockedLat, lng: mockedLng };
};

const getMarkerLabel = (lead: Lead) =>
  lead.chassi ??
  lead.clienteBaseEnriquecida ??
  lead.nomeContato ??
  `Lead ${lead.id}`;

export function LeadsMapView({
  leads,
  onLeadSelect,
  visible = false,
  loading = false,
  error = null,
}: LeadsMapViewProps) {
  const containerRef = useRef<HTMLDivElement | null>(null);
  const mapRef = useRef<LeafletMap | null>(null);
  const markerGroupRef = useRef<MarkerClusterGroup | null>(null);
  const leafletRef = useRef<LeafletWithCluster | null>(null);

  const leadPoints = useMemo(() => {
    return leads
      .map((lead) => getLeadPoint(lead))
      .filter((item): item is LeadPoint => Boolean(item));
  }, [leads]);

  useEffect(() => {
    let mounted = true;

    const initMap = async () => {
      if (!containerRef.current || mapRef.current) return;

      await import("leaflet/dist/leaflet-src.js");
      const L = (globalThis as typeof globalThis & {
        L?: LeafletWithCluster;
      }).L;
      if (!L) {
        throw new Error("Leaflet global was not initialized.");
      }
      await import("leaflet.markercluster/dist/leaflet.markercluster-src.js");

      if (!mounted || !containerRef.current) return;

      L.Icon.Default.mergeOptions({
        iconRetinaUrl: "/leaflet/marker-icon-2x.png",
        iconUrl: "/leaflet/marker-icon.png",
        shadowUrl: "/leaflet/marker-shadow.png",
      });

      const map = L.map(containerRef.current, {
        center: DEFAULT_CENTER,
        zoom: DEFAULT_ZOOM,
        scrollWheelZoom: true,
      });

      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        attribution: "&copy; OpenStreetMap contributors",
      }).addTo(map);

      const createClusterGroup =
        L.markerClusterGroup ??
        (() => {
          throw new Error("leaflet.markercluster did not attach to Leaflet.");
        });
      const clusterGroup = createClusterGroup({
        maxClusterRadius: 42,
        showCoverageOnHover: false,
      });
      clusterGroup.addTo(map);

      mapRef.current = map;
      markerGroupRef.current = clusterGroup;
      leafletRef.current = L;
    };

    void initMap();

    return () => {
      mounted = false;
      if (mapRef.current) {
        mapRef.current.remove();
        mapRef.current = null;
      }
      markerGroupRef.current = null;
      leafletRef.current = null;
    };
  }, []);

  useEffect(() => {
    const map = mapRef.current;
    const markerGroup = markerGroupRef.current;
    const L = leafletRef.current;
    if (!map || !markerGroup || !L) return;

    markerGroup.clearLayers();

    if (!leadPoints.length) {
      map.setView(DEFAULT_CENTER, DEFAULT_ZOOM);
      return;
    }

    leadPoints.forEach((point) => {
      const marker = L.marker([point.lat, point.lng], {
        title: getMarkerLabel(point.lead),
      });
      marker.on("click", () => onLeadSelect?.(point.lead));
      markerGroup.addLayer(marker);
    });

    const bounds = markerGroup.getBounds();
    if (bounds.isValid()) {
      map.fitBounds(bounds.pad(0.2), { maxZoom: 13 });
    }
  }, [leadPoints, onLeadSelect]);

  useEffect(() => {
    if (!visible) return;
    const map = mapRef.current;
    if (!map) return;
    const timeoutId = window.setTimeout(() => {
      map.invalidateSize();
    }, 0);
    return () => window.clearTimeout(timeoutId);
  }, [visible]);

  const overlayMessage = error
    ? error
    : loading
      ? "Carregando mapa..."
      : leadPoints.length === 0
        ? "Nenhum lead para mostrar no mapa."
        : null;

  return (
    <div className="relative overflow-hidden rounded-xl border border-slate-200 bg-white shadow-sm">
      <div ref={containerRef} className="h-[520px] w-full bg-slate-100" />
      {overlayMessage ? (
        <div className="pointer-events-none absolute inset-0 flex items-center justify-center">
          <div className="rounded-lg border border-slate-200 bg-white/90 px-4 py-2 text-xs font-semibold text-slate-600 shadow-sm">
            {overlayMessage}
          </div>
        </div>
      ) : null}
    </div>
  );
}



================================================
FILE: src/components/LeadsMetricsView.tsx
================================================
"use client";

import { Lead, TimeRange } from "@/lib/domain";
import { MetricCard } from "./MetricCard";

type LeadsMetricsViewProps = {
  leads: Lead[];
  timeRange: TimeRange;
};

const DAY_MS = 24 * 60 * 60 * 1000;

const isWithinRange = (dateStr: string, range: TimeRange) => {
  const date = new Date(dateStr);
  const now = new Date();
  const diff = now.getTime() - date.getTime();

  if (diff < 0) {
    return false;
  }

  switch (range) {
    case "today":
      return date.toDateString() === now.toDateString();
    case "week":
      return diff <= 7 * DAY_MS;
    case "month":
      return diff <= 30 * DAY_MS;
    case "year":
      return date.getFullYear() === now.getFullYear();
    default:
      return false;
  }
};

export function LeadsMetricsView({ leads, timeRange }: LeadsMetricsViewProps) {
  const leadsInRange = leads.filter((lead) =>
    isWithinRange(lead.importedAt, timeRange),
  );

  const leadsWithTipo = leadsInRange.filter((lead) => {
    const tipos = lead.tipoLeadList?.length
      ? lead.tipoLeadList
      : [lead.tipoLead];
    return tipos.some((tipo) => tipo && tipo !== "indefinido");
  });

  return (
    <div className="grid gap-4 sm:grid-cols-2 lg:grid-cols-3">
      <MetricCard label="Leads adicionados" value={leadsInRange.length} />
      <MetricCard
        label="Leads com tipo identificado"
        value={leadsWithTipo.length}
        subtitle="Possuem tipo marcado"
      />
    </div>
  );
}



================================================
FILE: src/components/LeadStatusMetricsView.tsx
================================================
"use client";

import { useMemo } from "react";
import {
  Cell,
  Pie,
  PieChart,
  ResponsiveContainer,
  Tooltip,
  type TooltipContentProps,
} from "recharts";
import { Lead, TimeRange } from "@/lib/domain";
import { LEAD_STATUS_LABELS, LEAD_STATUS_OPTIONS } from "@/lib/filters";
import { Badge } from "@/components/Badge";
import { LeadTypesMultiSelect } from "@/components/LeadTypesMultiSelect";

type LeadStatusMetricsViewProps = {
  leads: Lead[];
  timeRange: TimeRange;
  statusOptions: string[];
  selectedStatuses: string[];
  onSelectedStatusesChange: (next: string[]) => void;
  onLeadSelect?: (lead: Lead) => void;
  loading?: boolean;
  error?: string | null;
  onRetry?: () => void;
};

type StatusChartDatum = {
  status: string;
  label: string;
  count: number;
  color: string;
};

const DAY_MS = 24 * 60 * 60 * 1000;

const isWithinRange = (dateStr: string | null | undefined, range: TimeRange) => {
  if (!dateStr) return false;
  const date = new Date(dateStr);
  const now = new Date();
  const diff = now.getTime() - date.getTime();

  if (Number.isNaN(diff) || diff < 0) {
    return false;
  }

  switch (range) {
    case "today":
      return date.toDateString() === now.toDateString();
    case "week":
      return diff <= 7 * DAY_MS;
    case "month":
      return diff <= 30 * DAY_MS;
    case "year":
      return date.getFullYear() === now.getFullYear();
    default:
      return false;
  }
};

const normalizeStatus = (value: string | null | undefined) =>
  value?.trim().toLowerCase() ?? "";

type StatusTone =
  | "sky"
  | "emerald"
  | "amber"
  | "rose"
  | "slate"
  | "violet"
  | "stone";

const STATUS_TONES: Record<StatusTone, string> = {
  sky: "#0EA5E9",
  emerald: "#10B981",
  amber: "#F59E0B",
  rose: "#F43F5E",
  slate: "#475569",
  violet: "#8B5CF6",
  stone: "#78716C",
};

const pickStatusTone = (status: string): StatusTone => {
  const normalized = status.toLowerCase();
  if (normalized.includes("fech") || normalized.includes("conclu")) {
    return "emerald";
  }
  if (normalized.includes("descart") || normalized.includes("cancel")) {
    return "rose";
  }
  if (normalized.includes("novo")) {
    return "sky";
  }
  if (normalized.includes("contato")) {
    return "amber";
  }
  if (normalized.includes("atrib")) {
    return "violet";
  }
  return "slate";
};

const dateFormatter = new Intl.DateTimeFormat("pt-BR", {
  day: "2-digit",
  month: "short",
  year: "numeric",
});

const timeFormatter = new Intl.DateTimeFormat("pt-BR", {
  hour: "2-digit",
  minute: "2-digit",
});

const formatLeadDate = (value: string | null | undefined) => {
  if (!value) return "N/A";
  const date = new Date(value);
  if (Number.isNaN(date.getTime())) return "N/A";
  return `${dateFormatter.format(date)} ${timeFormatter.format(date)}`;
};

function StatusTooltip({
  active,
  payload,
}: Partial<TooltipContentProps<number, string>>) {
  if (!active || !payload?.length) return null;
  const datum = (payload[0] as { payload?: StatusChartDatum }).payload;
  if (!datum) return null;

  return (
    <div className="rounded-lg border border-slate-200 bg-white px-3 py-2 text-xs shadow-sm">
      <div className="font-semibold text-slate-900">{datum.label}</div>
      <div className="mt-1 text-slate-600">
        {datum.count} {datum.count === 1 ? "lead" : "leads"}
      </div>
    </div>
  );
}

export function LeadStatusMetricsView({
  leads,
  timeRange,
  statusOptions,
  selectedStatuses,
  onSelectedStatusesChange,
  onLeadSelect,
  loading,
  error,
  onRetry,
}: LeadStatusMetricsViewProps) {
  const resolvedStatusOptions = useMemo(() => {
    const map = new Map<string, string>();
    const addOption = (value: string, label?: string) => {
      const normalized = normalizeStatus(value);
      if (!normalized) return;
      if (!map.has(normalized)) {
        map.set(
          normalized,
          label ?? LEAD_STATUS_LABELS[normalized] ?? value,
        );
      }
    };

    statusOptions.forEach((status) => addOption(status));
    LEAD_STATUS_OPTIONS.forEach((option) => addOption(option.value, option.label));
    selectedStatuses.forEach((status) => addOption(status));

    return Array.from(map.entries())
      .map(([value, label]) => ({
        value,
        label: LEAD_STATUS_LABELS[value] ?? label,
      }))
      .sort((a, b) => a.label.localeCompare(b.label, "pt-BR"));
  }, [selectedStatuses, statusOptions]);

  const statusLabelByValue = useMemo(() => {
    const map = new Map<string, string>();
    resolvedStatusOptions.forEach((option) => {
      map.set(option.value, option.label);
    });
    return map;
  }, [resolvedStatusOptions]);

  const selectedStatusSet = useMemo(
    () => new Set(selectedStatuses.map((status) => normalizeStatus(status))),
    [selectedStatuses],
  );

  const leadsInRange = useMemo(() => {
    return leads.filter((lead) =>
      isWithinRange(lead.updatedAt ?? lead.importedAt, timeRange),
    );
  }, [leads, timeRange]);

  const filteredLeads = useMemo(() => {
    if (!selectedStatusSet.size) return [];
    return leadsInRange.filter((lead) => {
      const normalized = normalizeStatus(lead.status);
      return normalized && selectedStatusSet.has(normalized);
    });
  }, [leadsInRange, selectedStatusSet]);

  const chartData = useMemo(() => {
    const byStatus = new Map<string, number>();
    filteredLeads.forEach((lead) => {
      const normalized = normalizeStatus(lead.status);
      if (!normalized) return;
      byStatus.set(normalized, (byStatus.get(normalized) ?? 0) + 1);
    });

    return Array.from(byStatus.entries())
      .map(([status, count]) => ({
        status,
        label: statusLabelByValue.get(status) ?? status,
        count,
        color: STATUS_TONES[pickStatusTone(status)],
      }))
      .sort((a, b) => b.count - a.count);
  }, [filteredLeads, statusLabelByValue]);

  const sortedLeads = useMemo(() => {
    return [...filteredLeads].sort((a, b) => {
      const aDate = new Date(a.updatedAt ?? a.importedAt).getTime();
      const bDate = new Date(b.updatedAt ?? b.importedAt).getTime();
      return bDate - aDate;
    });
  }, [filteredLeads]);

  const listTotal = sortedLeads.length;

  if (loading) {
    return (
      <div className="rounded-xl border border-slate-200 bg-white p-6 text-sm text-slate-600 shadow-sm">
        Carregando leads...
      </div>
    );
  }

  if (error) {
    return (
      <div className="flex flex-col gap-3 rounded-xl border border-rose-200 bg-rose-50 p-6 text-sm text-rose-900 shadow-sm">
        <span>{error}</span>
        {onRetry ? (
          <button
            type="button"
            onClick={onRetry}
            className="inline-flex w-fit items-center gap-2 rounded-lg border border-rose-300 px-3 py-2 text-xs font-semibold text-rose-700 transition hover:border-rose-400 hover:text-rose-900"
          >
            Tentar novamente
          </button>
        ) : null}
      </div>
    );
  }

  return (
    <div className="rounded-xl border border-slate-200 bg-white shadow-sm">
      <div className="flex flex-col gap-3 border-b border-slate-200 bg-slate-50 px-5 py-4">
        <div className="flex flex-col gap-3 sm:flex-row sm:items-end sm:justify-between">
          <div>
            <div className="text-xs font-semibold uppercase tracking-wide text-slate-500">
              Leads por status
            </div>
            <div className="mt-1 text-sm text-slate-600">
              {listTotal} lead{listTotal === 1 ? "" : "s"} no periodo
            </div>
          </div>
          <label className="flex flex-col gap-1 text-[11px] font-semibold uppercase tracking-wide text-slate-500">
            <span>Status na pizza</span>
            <LeadTypesMultiSelect
              value={selectedStatuses}
              options={resolvedStatusOptions}
              onChange={onSelectedStatusesChange}
              placeholder="Selecionar status"
            />
          </label>
        </div>
      </div>

      <div className="px-5 py-4">
        <div className="text-xs font-semibold uppercase tracking-wide text-slate-500">
          Distribuicao
        </div>

        {chartData.length ? (
          <div className="mt-3">
            <div className="flex flex-col gap-4 md:flex-row">
              <div className="h-64 w-full md:w-2/3">
                <ResponsiveContainer width="100%" height="100%">
                  <PieChart>
                    <Tooltip content={<StatusTooltip />} />
                    <Pie
                      data={chartData}
                      dataKey="count"
                      nameKey="label"
                      cx="50%"
                      cy="50%"
                      innerRadius={60}
                      outerRadius={90}
                      paddingAngle={2}
                    >
                      {chartData.map((item) => (
                        <Cell key={item.status} fill={item.color} />
                      ))}
                    </Pie>
                  </PieChart>
                </ResponsiveContainer>
              </div>
              <div className="w-full md:w-1/3">
                <div className="text-xs font-semibold uppercase tracking-wide text-slate-500">
                  Legenda
                </div>
                <div className="mt-2 max-h-64 overflow-y-auto rounded-lg border border-slate-200 bg-slate-50 px-3 py-2 text-xs text-slate-700">
                  {chartData.map((item) => (
                    <div
                      key={`legend-${item.status}`}
                      className="flex items-start gap-2 border-b border-slate-200 py-2 last:border-b-0"
                    >
                      <span
                        className="mt-1 inline-flex h-2.5 w-2.5 rounded-full"
                        style={{ backgroundColor: item.color }}
                      />
                      <div className="flex-1">
                        <div className="font-semibold text-slate-900">
                          {item.label}
                        </div>
                        <div className="text-slate-600">
                          {item.count} {item.count === 1 ? "lead" : "leads"}
                        </div>
                      </div>
                    </div>
                  ))}
                </div>
              </div>
            </div>
          </div>
        ) : (
          <div className="mt-3 text-sm text-slate-500">
            Nenhum lead para os status selecionados.
          </div>
        )}

        <div className="mt-4">
          <div className="text-xs font-semibold uppercase tracking-wide text-slate-500">
            Lista de leads no periodo
          </div>
          <div className="mt-2 overflow-hidden rounded-lg border border-slate-200">
            <div
              className="grid gap-4 border-b border-slate-200 bg-slate-50 px-4 py-2 text-xs font-semibold uppercase tracking-wide text-slate-600"
              style={{ gridTemplateColumns: "1.6fr 1fr 1fr 1fr" }}
            >
              <span>Lead</span>
              <span>Status</span>
              <span>Consultor</span>
              <span>Atualizado</span>
            </div>
            <div className="max-h-80 overflow-y-auto divide-y divide-slate-200">
              {sortedLeads.length ? (
                sortedLeads.map((lead, index) => {
                  const normalized = normalizeStatus(lead.status);
                  const label =
                    statusLabelByValue.get(normalized) ??
                    lead.status?.trim() ??
                    "Sem status";
                  const backgroundClass = onLeadSelect
                    ? "hover:bg-slate-50 focus:outline-none focus:ring-2 focus:ring-sky-200"
                    : "";
                  const leadTitle =
                    lead.clienteBaseEnriquecida?.trim() ||
                    lead.modelName?.trim() ||
                    lead.chassi?.trim() ||
                    `Lead ${lead.id}`;

                  return (
                    <div
                      key={`${lead.id}-${index}`}
                      role={onLeadSelect ? "button" : undefined}
                      tabIndex={onLeadSelect ? 0 : undefined}
                      onClick={onLeadSelect ? () => onLeadSelect(lead) : undefined}
                      onKeyDown={
                        onLeadSelect
                          ? (event) => {
                              if (event.key === "Enter" || event.key === " ") {
                                event.preventDefault();
                                onLeadSelect(lead);
                              }
                            }
                          : undefined
                      }
                      className={`grid items-center gap-4 px-4 py-3 text-sm text-slate-800 ${backgroundClass}`}
                      style={{ gridTemplateColumns: "1.6fr 1fr 1fr 1fr" }}
                    >
                      <div className="min-w-0">
                        <div className="truncate font-semibold text-slate-900">
                          {leadTitle}
                        </div>
                        <div className="truncate text-xs text-slate-500">
                          Lead {lead.id}
                        </div>
                      </div>
                      <div className="min-w-0">
                        <Badge tone={pickStatusTone(normalized)}>{label}</Badge>
                      </div>
                      <div className="min-w-0 truncate text-slate-700">
                        {lead.consultor ?? "Sem consultor"}
                      </div>
                      <div className="min-w-0 truncate text-xs text-slate-500">
                        {formatLeadDate(lead.updatedAt ?? lead.importedAt)}
                      </div>
                    </div>
                  );
                })
              ) : (
                <div className="px-4 py-3 text-sm text-slate-500">
                  Nenhum lead encontrado para esse filtro.
                </div>
              )}
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}



================================================
FILE: src/components/LeadTypesMultiSelect.tsx
================================================
"use client";

import {
  useCallback,
  useEffect,
  useId,
  useMemo,
  useRef,
  useState,
  type KeyboardEvent as ReactKeyboardEvent,
} from "react";

type LeadTypesMultiSelectProps = {
  value: string[];
  options: Array<string | { value: string; label: string }>;
  onChange: (next: string[]) => void;
  placeholder?: string;
};

const buildSummary = (
  value: string[],
  labelByValue: Map<string, string>,
  placeholder?: string
) => {
  if (!value.length) return placeholder ?? "Selecionar tipos";
  const labels = value.map((item) => labelByValue.get(item) ?? item);
  if (labels.length === 1) return labels[0];
  if (labels.length === 2) return `${labels[0]}, ${labels[1]}`;
  return `${value.length} selecionados`;
};

export function LeadTypesMultiSelect({
  value,
  options,
  onChange,
  placeholder,
}: LeadTypesMultiSelectProps) {
  const [open, setOpen] = useState(false);
  const [query, setQuery] = useState("");
  const wrapperRef = useRef<HTMLDivElement | null>(null);
  const triggerRef = useRef<HTMLButtonElement | null>(null);
  const searchRef = useRef<HTMLInputElement | null>(null);
  const listRef = useRef<HTMLDivElement | null>(null);
  const listId = useId();

  const normalizedOptions = useMemo(
    () =>
      options.map((option) =>
        typeof option === "string" ? { value: option, label: option } : option,
      ),
    [options],
  );

  const labelByValue = useMemo(() => {
    const map = new Map<string, string>();
    normalizedOptions.forEach((option) => {
      map.set(option.value, option.label);
    });
    return map;
  }, [normalizedOptions]);

  const filteredOptions = useMemo(() => {
    const normalized = query.trim().toLowerCase();
    if (!normalized) return normalizedOptions;
    return normalizedOptions.filter((option) => {
      const label = option.label.toLowerCase();
      const value = option.value.toLowerCase();
      return label.includes(normalized) || value.includes(normalized);
    });
  }, [normalizedOptions, query]);

  useEffect(() => {
    if (!open) return;
    const handleOutside = (event: MouseEvent) => {
      if (!wrapperRef.current) return;
      if (!wrapperRef.current.contains(event.target as Node)) {
        setOpen(false);
      }
    };
    document.addEventListener("mousedown", handleOutside);
    return () => document.removeEventListener("mousedown", handleOutside);
  }, [open]);

  useEffect(() => {
    if (!open) return;
    const timer = window.setTimeout(() => {
      searchRef.current?.focus();
    }, 0);
    return () => window.clearTimeout(timer);
  }, [open]);

  const summary = useMemo(
    () => buildSummary(value, labelByValue, placeholder),
    [value, labelByValue, placeholder],
  );

  const toggleOption = useCallback(
    (option: string) => {
      const selected = new Set(value);
      if (selected.has(option)) {
        selected.delete(option);
      } else {
        selected.add(option);
      }
      onChange(Array.from(selected));
    },
    [onChange, value],
  );

  const focusOption = (index: number) => {
    const buttons =
      listRef.current?.querySelectorAll<HTMLButtonElement>(
        "button[data-option]",
      ) ?? [];
    if (!buttons.length) return;
    const clamped = Math.max(0, Math.min(index, buttons.length - 1));
    buttons[clamped]?.focus();
  };

  const handleTriggerKeyDown = (event: ReactKeyboardEvent<HTMLButtonElement>) => {
    if (event.key === "ArrowDown" || event.key === "Enter" || event.key === " ") {
      event.preventDefault();
      setOpen(true);
    }
  };

  const handleInputKeyDown = (event: ReactKeyboardEvent<HTMLInputElement>) => {
    if (event.key === "Escape") {
      event.preventDefault();
      setOpen(false);
      triggerRef.current?.focus();
    }
    if (event.key === "ArrowDown") {
      event.preventDefault();
      focusOption(0);
    }
  };

  const handleOptionKeyDown = (
    event: ReactKeyboardEvent<HTMLButtonElement>,
  ) => {
    const buttons =
      listRef.current?.querySelectorAll<HTMLButtonElement>(
        "button[data-option]",
      ) ?? [];
    const currentIndex = Array.from(buttons).indexOf(
      event.currentTarget,
    );

    if (event.key === "Escape") {
      event.preventDefault();
      setOpen(false);
      triggerRef.current?.focus();
    }
    if (event.key === "ArrowDown") {
      event.preventDefault();
      focusOption(currentIndex + 1);
    }
    if (event.key === "ArrowUp") {
      event.preventDefault();
      focusOption(currentIndex - 1);
    }
    if (event.key === "Home") {
      event.preventDefault();
      focusOption(0);
    }
    if (event.key === "End") {
      event.preventDefault();
      focusOption(buttons.length - 1);
    }
  };

  return (
    <div ref={wrapperRef} className="relative z-20">
      <button
        ref={triggerRef}
        type="button"
        onClick={() => setOpen((prev) => !prev)}
        onKeyDown={handleTriggerKeyDown}
        aria-haspopup="listbox"
        aria-expanded={open}
        aria-controls={listId}
        className="flex w-full items-center justify-between gap-2 rounded-md border border-slate-200 bg-white px-2 py-1 text-xs text-slate-900 outline-none transition focus:border-sky-400 focus:ring-2 focus:ring-sky-100"
      >
        <span
          className={`truncate ${
            value.length ? "text-slate-900" : "text-slate-400"
          }`}
        >
          {summary}
        </span>
        <span className="text-slate-400">v</span>
      </button>

      {open ? (
        <div
          className="absolute left-0 bottom-full z-50 mb-1 w-60 overflow-hidden rounded-lg border border-slate-200 bg-white shadow-lg"
          role="listbox"
          aria-multiselectable="true"
          id={listId}
        >
          <div className="border-b border-slate-200 px-2 py-2">
            <input
              ref={searchRef}
              value={query}
              onChange={(event) => setQuery(event.target.value)}
              onKeyDown={handleInputKeyDown}
              placeholder="Buscar tipo..."
              className="w-full rounded-md border border-slate-200 bg-white px-2 py-1 text-xs text-slate-900 outline-none focus:border-sky-400 focus:ring-2 focus:ring-sky-100"
            />
          </div>
          <div
            ref={listRef}
            className="max-h-[240px] overflow-y-auto p-1"
          >
            {filteredOptions.length ? (
              filteredOptions.map((option) => {
                const selected = value.includes(option.value);
                return (
                  <button
                    key={option.value}
                    type="button"
                    role="option"
                    aria-selected={selected}
                    data-option
                    onClick={() => toggleOption(option.value)}
                    onKeyDown={handleOptionKeyDown}
                    className="flex w-full items-center gap-2 rounded-md px-2 py-1 text-left text-xs text-slate-700 transition hover:bg-slate-100 focus:bg-slate-100 focus:outline-none"
                  >
                    <span
                      className={`flex h-4 w-4 items-center justify-center rounded border text-[10px] ${
                        selected
                          ? "border-sky-400 bg-sky-50 text-sky-700"
                          : "border-slate-300 text-transparent"
                      }`}
                      aria-hidden="true"
                    >
                      x
                    </span>
                    <span className="truncate">{option.label}</span>
                  </button>
                );
              })
            ) : (
              <div className="px-3 py-2 text-xs text-slate-500">
                Nenhum resultado
              </div>
            )}
          </div>
        </div>
      ) : null}
    </div>
  );
}



================================================
FILE: src/components/MetricCard.tsx
================================================
"use client";

type MetricCardProps = {
  label: string;
  value: number;
  subtitle?: string;
};

export function MetricCard({ label, value, subtitle }: MetricCardProps) {
  return (
    <div className="rounded-xl border border-slate-200 bg-white px-4 py-5 shadow-sm">
      <p className="text-xs font-semibold uppercase tracking-wide text-slate-500">
        {label}
      </p>
      <div className="mt-2 flex items-baseline gap-2">
        <span className="text-3xl font-bold text-slate-900">{value}</span>
        {subtitle && (
          <span className="text-xs text-slate-500">{subtitle}</span>
        )}
      </div>
    </div>
  );
}



================================================
FILE: src/components/MetricsTabs.tsx
================================================
"use client";

import { Tabs } from "./Tabs";

type MetricsTabId = "leads" | "tickets";

type MetricsTabsProps = {
  activeTabId: MetricsTabId;
  onChange: (tab: MetricsTabId) => void;
};

export function MetricsTabs({ activeTabId, onChange }: MetricsTabsProps) {
  return (
    <Tabs
      tabs={[
        { id: "leads", label: "LEADS" },
        { id: "tickets", label: "TICKETS" },
      ]}
      activeTabId={activeTabId}
      onTabChange={(id) => onChange(id as MetricsTabId)}
    />
  );
}



================================================
FILE: src/components/PageShell.tsx
================================================
"use client";

import { useEffect } from "react";

type PageShellProps = {
  children: React.ReactNode;
  title?: string;
  subtitle?: string;
};

export function PageShell({ children, title, subtitle }: PageShellProps) {
  useEffect(() => {
    document.body.classList.add("hide-scrollbar");
    document.documentElement.classList.add("hide-scrollbar");
    return () => {
      document.body.classList.remove("hide-scrollbar");
      document.documentElement.classList.remove("hide-scrollbar");
    };
  }, []);

  return (
    <div className="min-h-screen bg-slate-100 text-slate-900">
      <div className="mx-auto flex max-w-screen-2xl flex-col gap-6 px-6 py-10">
        {(title || subtitle) && (
          <header className="space-y-1">
            {title && (
              <h1 className="text-2xl font-semibold text-slate-900">
                {title}
              </h1>
            )}
            {subtitle && (
              <p className="text-sm text-slate-600">{subtitle}</p>
            )}
          </header>
        )}
        {children}
      </div>
    </div>
  );
}



================================================
FILE: src/components/RequireAuth.tsx
================================================
"use client";

import { useEffect } from "react";
import { useRouter } from "next/navigation";
import { useAuth } from "@/contexts/AuthContext";

export function RequireAuth({ children }: { children: React.ReactNode }) {
  const { user, loading } = useAuth();
  const router = useRouter();

  useEffect(() => {
    if (!loading && !user) {
      router.replace("/login");
    }
  }, [loading, router, user]);

  if (loading || !user) {
    return (
      <div className="flex min-h-[calc(100vh-120px)] items-center justify-center px-4 py-10 text-sm text-slate-500">
        Loading...
      </div>
    );
  }

  return <>{children}</>;
}



================================================
FILE: src/components/Tabs.tsx
================================================
"use client";

type Tab = {
  id: string;
  label: string;
};

type TabsProps = {
  tabs: Tab[];
  activeTabId: string;
  onTabChange: (id: string) => void;
};

export function Tabs({ tabs, activeTabId, onTabChange }: TabsProps) {
  return (
    <div className="inline-flex items-center divide-x divide-slate-200 rounded-full border border-slate-200 bg-white">
      {tabs.map((tab) => {
        const isActive = tab.id === activeTabId;
        return (
          <button
            key={tab.id}
            type="button"
            onClick={() => onTabChange(tab.id)}
            className={`px-4 py-2 text-sm font-semibold transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-300/80 focus-visible:z-10 first:rounded-l-full last:rounded-r-full ${
              isActive
                ? "bg-sky-100 text-sky-800"
                : "bg-transparent text-slate-600 hover:bg-slate-50 hover:text-slate-900"
            }`}
          >
            {tab.label}
          </button>
        );
      })}
    </div>
  );
}



================================================
FILE: src/components/TicketDetailsAside.tsx
================================================
"use client";

import React, { useEffect, useMemo, useRef, useState } from "react";
import {
  ExpertConnectTicketDetails,
  fetchTicketDetails,
} from "@/lib/ticketDetails";
import { buildTicketDetailsViewModel } from "@/lib/ticketDetailsViewModel";
import { CollapsibleSection } from "@/components/ticket-details/CollapsibleSection";
import { TicketHeader } from "@/components/ticket-details/TicketHeader";
import { TicketContactCard } from "@/components/ticket-details/TicketContactCard";
import { TicketAdvisorCard } from "@/components/ticket-details/TicketAdvisorCard";
import { TicketMetaInfo } from "@/components/ticket-details/TicketMetaInfo";
import { TicketTags } from "@/components/ticket-details/TicketTags";
import { TicketMachineList } from "@/components/ticket-details/TicketMachineList";
import { TicketDescription } from "@/components/ticket-details/TicketDescription";
import { TicketWatchers } from "@/components/ticket-details/TicketWatchers";
import { TicketCustomFields } from "@/components/ticket-details/TicketCustomFields";

type TicketDetailsAsideProps = {
  ticketId: string;
  open: boolean;
  onClose: () => void;
};

type LoadState =
  | { status: "idle" }
  | { status: "loading" }
  | { status: "success"; data: ExpertConnectTicketDetails }
  | { status: "error"; message: string };

function TicketDetailsSkeleton() {
  return (
    <div className="space-y-3 px-5 py-4">
      {Array.from({ length: 6 }).map((_, idx) => (
        <div
          key={idx}
          className="rounded-xl border border-slate-200 bg-white p-4 shadow-sm"
        >
          <div className="h-4 w-40 animate-pulse rounded bg-slate-200" />
          <div className="mt-3 grid grid-cols-1 gap-3 sm:grid-cols-2">
            <div className="h-4 w-full animate-pulse rounded bg-slate-200" />
            <div className="h-4 w-full animate-pulse rounded bg-slate-200" />
            <div className="h-4 w-4/5 animate-pulse rounded bg-slate-200" />
            <div className="h-4 w-3/5 animate-pulse rounded bg-slate-200" />
          </div>
        </div>
      ))}
    </div>
  );
}

export function TicketDetailsAside({
  ticketId,
  open,
  onClose,
}: TicketDetailsAsideProps) {
  const [state, setState] = useState<LoadState>({ status: "idle" });
  const [reloadNonce, setReloadNonce] = useState(0);
  const lastTicketIdRef = useRef<string | null>(null);

  useEffect(() => {
    if (open) return;
    lastTicketIdRef.current = null;
    setState({ status: "idle" });
  }, [open]);

  useEffect(() => {
    if (!open) return;

    const onKeyDown = (e: KeyboardEvent) => {
      if (e.key === "Escape") onClose();
    };
    window.addEventListener("keydown", onKeyDown);
    return () => window.removeEventListener("keydown", onKeyDown);
  }, [open, onClose]);

  useEffect(() => {
    if (!open) return;
    const previousOverflow = document.body.style.overflow;
    document.body.style.overflow = "hidden";
    return () => {
      document.body.style.overflow = previousOverflow;
    };
  }, [open]);

  useEffect(() => {
    if (!open) return;
    const trimmedId = ticketId.trim();
    if (!trimmedId) {
      setState({ status: "error", message: "ticketId inválido" });
      return;
    }

    if (lastTicketIdRef.current !== trimmedId) {
      lastTicketIdRef.current = trimmedId;
      setState({ status: "loading" });
    }

    const controller = new AbortController();
    const load = async () => {
      try {
        const data = await fetchTicketDetails(trimmedId, {
          signal: controller.signal,
        });
        setState({ status: "success", data });
      } catch (err) {
        if ((err as any)?.name === "AbortError") return;
        const message =
          (err as any)?.error?.message ??
          (err as any)?.message ??
          "Falha ao carregar detalhes do ticket";
        setState({ status: "error", message: String(message) });
      }
    };

    void load();
    return () => controller.abort();
  }, [open, ticketId, reloadNonce]);

  const viewModel = useMemo(() => {
    if (state.status !== "success") return null;
    return buildTicketDetailsViewModel(state.data);
  }, [state]);

  if (!open) return null;

  return (
    <div
      className="fixed inset-0 z-[9999]"
      role="dialog"
      aria-modal="true"
      aria-label="Detalhes do ticket"
    >
      <div
        className="absolute inset-0 bg-slate-900/40 backdrop-blur-[1px]"
        onClick={onClose}
      />

      <aside
        className="absolute right-0 top-0 flex h-full w-full max-w-[640px] flex-col border-l border-slate-200 bg-slate-50 shadow-2xl"
        onClick={(e) => e.stopPropagation()}
      >
        {viewModel ? (
          <TicketHeader
            number={viewModel.header.number}
            title={viewModel.header.title}
            status={viewModel.header.status}
            priority={viewModel.header.priority}
            url={viewModel.header.url}
            onClose={onClose}
          />
        ) : (
          <div className="sticky top-0 z-10 border-b border-slate-200 bg-white/90 px-5 py-4 backdrop-blur">
            <div className="flex items-center justify-between">
              <div className="h-4 w-56 animate-pulse rounded bg-slate-200" />
              <button
                type="button"
                onClick={onClose}
                aria-label="Fechar"
                className="inline-flex h-9 w-9 items-center justify-center rounded-lg border border-slate-200 bg-white text-slate-700 transition hover:border-slate-300 hover:text-slate-900"
              >
                ✕
              </button>
            </div>
          </div>
        )}

        <div className="flex-1 overflow-y-auto">
          {state.status === "loading" || state.status === "idle" ? (
            <TicketDetailsSkeleton />
          ) : null}

          {state.status === "error" ? (
            <div className="px-5 py-4">
              <div className="rounded-xl border border-rose-200 bg-rose-50 p-4 text-sm text-rose-900 shadow-sm">
                <div className="font-semibold">Erro ao carregar ticket</div>
                <div className="mt-1">{state.message}</div>
                <button
                  type="button"
                  onClick={() => {
                    setState({ status: "loading" });
                    setReloadNonce((n) => n + 1);
                  }}
                  className="mt-3 inline-flex items-center justify-center rounded-lg border border-rose-300 bg-white px-3 py-2 text-xs font-semibold text-rose-700 transition hover:border-rose-400 hover:text-rose-900"
                >
                  Tentar novamente
                </button>
              </div>
            </div>
          ) : null}

          {state.status === "success" && viewModel ? (
            <div className="space-y-3 px-5 py-4">
              <CollapsibleSection title="Contato" defaultOpen>
                <TicketContactCard contact={viewModel.contact} />
              </CollapsibleSection>

              <CollapsibleSection title="Consultor / Equipe" defaultOpen>
                <TicketAdvisorCard advisor={viewModel.advisor} />
              </CollapsibleSection>

              <CollapsibleSection title="Detalhes do ticket" defaultOpen>
                <TicketMetaInfo meta={viewModel.meta} />
              </CollapsibleSection>

              <CollapsibleSection
                title="Tags"
                defaultOpen
                rightSlot={
                  viewModel.tags.length ? (
                    <span className="text-xs font-semibold text-slate-500">
                      {viewModel.tags.length}
                    </span>
                  ) : null
                }
              >
                <TicketTags tags={viewModel.tags} />
              </CollapsibleSection>

              <CollapsibleSection
                title="Máquinas"
                defaultOpen={false}
                rightSlot={
                  viewModel.machines.length ? (
                    <span className="text-xs font-semibold text-slate-500">
                      {viewModel.machines.length}
                    </span>
                  ) : null
                }
              >
                <TicketMachineList machines={viewModel.machines} />
              </CollapsibleSection>

              <CollapsibleSection
                title="Resolução / Descrição"
                defaultOpen={false}
              >
                <TicketDescription description={viewModel.description} />
              </CollapsibleSection>

              <CollapsibleSection
                title="Watchers / Participantes"
                defaultOpen={false}
                rightSlot={
                  viewModel.watchers.length ? (
                    <span className="text-xs font-semibold text-slate-500">
                      {viewModel.watchers.length}
                    </span>
                  ) : null
                }
              >
                <TicketWatchers watchers={viewModel.watchers} />
              </CollapsibleSection>

              <CollapsibleSection
                title="Campos customizados"
                defaultOpen={false}
                rightSlot={
                  viewModel.customFields.length ? (
                    <span className="text-xs font-semibold text-slate-500">
                      {viewModel.customFields.length}
                    </span>
                  ) : null
                }
              >
                <TicketCustomFields fields={viewModel.customFields} />
              </CollapsibleSection>
            </div>
          ) : null}
        </div>
      </aside>
    </div>
  );
}



================================================
FILE: src/components/TicketsList.tsx
================================================
"use client";

import React, { useMemo } from "react";
import { Ticket, TicketStatus } from "@/lib/domain";
import { SortOrder } from "@/lib/filters";
import { TicketFiltersState } from "@/lib/ticketFilters";
import { Badge } from "./Badge";
import { ActionButtonCell } from "./ActionButtonCell";

type TicketsListProps = {
  tickets: Ticket[];
  total: number;
  page: number;
  pageSize: number;
  filters: TicketFiltersState;
  loading?: boolean;
  onFiltersChange: (filters: TicketFiltersState) => void;
  onPageChange: (direction: -1 | 1) => void;
  onTicketSelect?: (ticket: Ticket) => void;
  options?: {
    consultores: string[];
    clientes: string[];
    equipes: string[];
  };
};

type ColumnId =
  | "ticket"
  | "titulo"
  | "status"
  | "chassi"
  | "consultor"
  | "cliente"
  | "equipe"
  | "atualizado"
  | "acoes";

const timeFormatter = new Intl.DateTimeFormat("pt-BR", {
  hour: "2-digit",
  minute: "2-digit",
});

const dateFormatter = new Intl.DateTimeFormat("pt-BR", {
  day: "2-digit",
  month: "short",
  year: "numeric",
});

const ticketStatusTone: Record<
  TicketStatus,
  Parameters<typeof Badge>[0]["tone"]
> = {
  aberto: "amber",
  fechado: "emerald",
  desconhecido: "slate",
};

const ticketStatusLabel: Record<TicketStatus, string> = {
  aberto: "Aberto",
  fechado: "Fechado",
  desconhecido: "Desconhecido",
};

const formatDateParts = (iso: string | null) => {
  if (!iso) return { time: "N/A", date: "N/A" };
  const date = new Date(iso);
  if (Number.isNaN(date.getTime())) return { time: "N/A", date: "N/A" };
  return {
    time: timeFormatter.format(date),
    date: dateFormatter.format(date),
  };
};

const columnLabels: Record<ColumnId, string> = {
  ticket: "Ticket",
  titulo: "Título",
  status: "Status",
  chassi: "Chassi",
  consultor: "Consultor",
  cliente: "Cliente",
  equipe: "Equipe",
  atualizado: "Atualizado",
  acoes: "Ações",
};

const columnWidths: Record<ColumnId, string> = {
  ticket: "1fr",
  titulo: "1.6fr",
  status: "0.9fr",
  chassi: "1.1fr",
  consultor: "1.1fr",
  cliente: "1.2fr",
  equipe: "1fr",
  atualizado: "1fr",
  acoes: "0.8fr",
};

const buildColumnOrder = (
  groupByEmpresa: boolean,
  groupByChassi: boolean
): ColumnId[] => {
  const baseOrder: ColumnId[] = [
    "ticket",
    "titulo",
    "status",
    "chassi",
    "consultor",
    "cliente",
    "equipe",
    "atualizado",
    "acoes",
  ];

  const prioritized: ColumnId[] = [];
  if (groupByEmpresa) prioritized.push("cliente");
  if (groupByChassi) prioritized.push("chassi");

  const deduped = [...new Set([...prioritized, ...baseOrder])];
  return deduped;
};

export function TicketsList({
  tickets,
  total,
  page,
  pageSize,
  filters,
  loading = false,
  onFiltersChange,
  onPageChange,
  onTicketSelect,
  options,
}: TicketsListProps) {
  const totalPages = Math.max(1, Math.ceil(total / pageSize));
  const skeletonRows = useMemo(
    () => Array.from({ length: Math.max(1, pageSize) }, (_, i) => i),
    [pageSize]
  );

  const columnOrder = useMemo(
    () => buildColumnOrder(filters.groupByEmpresa, filters.groupByChassi),
    [filters.groupByEmpresa, filters.groupByChassi]
  );

  const gridTemplateColumns = columnOrder
    .map((col) => columnWidths[col])
    .join(" ");

  const handleFilterChange = <K extends keyof TicketFiltersState>(
    key: K,
    val: TicketFiltersState[K]
  ) => {
    onFiltersChange({ ...filters, [key]: val });
  };

  const makeGroupKey = useMemo(() => {
    return (ticket: Ticket) => {
      const parts: string[] = [];
      if (filters.groupByEmpresa) {
        parts.push(
          ticket.customerOrganization ?? ticket.customerName ?? "Sem empresa"
        );
      }
      if (filters.groupByChassi) {
        parts.push(ticket.serialNumber ?? "Sem chassi");
      }
      return parts.join("::");
    };
  }, [filters.groupByChassi, filters.groupByEmpresa]);

  const groupedTickets = useMemo(() => {
    return tickets.reduce<
      { ticket: Ticket; groupKey: string; groupIndex: number }[]
    >((acc, ticket) => {
      const groupKey = makeGroupKey(ticket);
      const last = acc[acc.length - 1];
      const groupIndex =
        last && last.groupKey === groupKey
          ? last.groupIndex
          : (last?.groupIndex ?? -1) + 1;
      acc.push({ ticket, groupKey, groupIndex });
      return acc;
    }, []);
  }, [makeGroupKey, tickets]);

  return (
    <div className="space-y-4">
      <div className="flex flex-col gap-3 rounded-xl border border-slate-200 bg-white p-4 shadow-sm">
        <div className="grid gap-3 md:grid-cols-3">
          <label className="flex flex-col gap-1 text-xs font-semibold uppercase tracking-wide text-slate-500">
            Busca
            <input
              type="search"
              value={filters.search}
              onChange={(e) => handleFilterChange("search", e.target.value)}
              placeholder="Buscar por ticket, título, chassi ou cliente"
              className="w-full rounded-lg border border-slate-200 bg-white px-3 py-2 text-sm text-slate-900 placeholder:text-slate-400 focus:border-sky-400 focus:outline-none focus:ring-2 focus:ring-sky-200"
            />
          </label>

          <label className="flex flex-col gap-1 text-xs font-semibold uppercase tracking-wide text-slate-500">
            Status
            <select
              value={filters.status}
              onChange={(e) =>
                handleFilterChange(
                  "status",
                  e.target.value as TicketStatus | ""
                )
              }
              className="w-full rounded-lg border border-slate-200 bg-white px-3 py-2 text-sm text-slate-900 focus:border-sky-400 focus:outline-none focus:ring-2 focus:ring-sky-200"
            >
              <option value="">Todos</option>
              <option value="aberto">Aberto</option>
              <option value="fechado">Fechado</option>
            </select>
          </label>

          <label className="flex flex-col gap-1 text-xs font-semibold uppercase tracking-wide text-slate-500">
            Ordenação
            <select
              value={filters.sort}
              onChange={(e) =>
                handleFilterChange("sort", e.target.value as SortOrder)
              }
              className="w-full rounded-lg border border-slate-200 bg-white px-3 py-2 text-sm text-slate-900 focus:border-sky-400 focus:outline-none focus:ring-2 focus:ring-sky-200"
            >
              <option value="recentes">Mais recentes</option>
              <option value="antigos">Mais antigos</option>
            </select>
          </label>
        </div>

        <div className="grid gap-3 md:grid-cols-3">
          <label className="flex flex-col gap-1 text-xs font-semibold uppercase tracking-wide text-slate-500">
            Consultor
            <select
              value={filters.consultor}
              onChange={(e) => handleFilterChange("consultor", e.target.value)}
              className="w-full rounded-lg border border-slate-200 bg-white px-3 py-2 text-sm text-slate-900 focus:border-sky-400 focus:outline-none focus:ring-2 focus:ring-sky-200"
            >
              <option value="">Todos</option>
              {(options?.consultores ?? []).map((item) => (
                <option key={item} value={item}>
                  {item}
                </option>
              ))}
            </select>
          </label>

          <label className="flex flex-col gap-1 text-xs font-semibold uppercase tracking-wide text-slate-500">
            Cliente
            <select
              value={filters.cliente}
              onChange={(e) => handleFilterChange("cliente", e.target.value)}
              className="w-full rounded-lg border border-slate-200 bg-white px-3 py-2 text-sm text-slate-900 focus:border-sky-400 focus:outline-none focus:ring-2 focus:ring-sky-200"
            >
              <option value="">Todos</option>
              {(options?.clientes ?? []).map((item) => (
                <option key={item} value={item}>
                  {item}
                </option>
              ))}
            </select>
          </label>

          <label className="flex flex-col gap-1 text-xs font-semibold uppercase tracking-wide text-slate-500">
            Equipe
            <select
              value={filters.equipe}
              onChange={(e) => handleFilterChange("equipe", e.target.value)}
              className="w-full rounded-lg border border-slate-200 bg-white px-3 py-2 text-sm text-slate-900 focus:border-sky-400 focus:outline-none focus:ring-2 focus:ring-sky-200"
            >
              <option value="">Todas</option>
              {(options?.equipes ?? []).map((item) => (
                <option key={item} value={item}>
                  {item}
                </option>
              ))}
            </select>
          </label>
        </div>

        <div className="flex flex-wrap items-center gap-2">
          <span className="text-xs font-semibold uppercase tracking-wide text-slate-500">
            Agrupar
          </span>
          <button
            type="button"
            onClick={() =>
              handleFilterChange("groupByEmpresa", !filters.groupByEmpresa)
            }
            aria-pressed={filters.groupByEmpresa}
            className={`rounded-full border px-3 py-1 text-xs font-semibold transition ${
              filters.groupByEmpresa
                ? "border-sky-300 bg-sky-50 text-sky-800"
                : "border-slate-200 bg-white text-slate-700 hover:border-slate-300 hover:text-slate-900"
            }`}
          >
            Empresa
          </button>
          <button
            type="button"
            onClick={() =>
              handleFilterChange("groupByChassi", !filters.groupByChassi)
            }
            aria-pressed={filters.groupByChassi}
            className={`rounded-full border px-3 py-1 text-xs font-semibold transition ${
              filters.groupByChassi
                ? "border-sky-300 bg-sky-50 text-sky-800"
                : "border-slate-200 bg-white text-slate-700 hover:border-slate-300 hover:text-slate-900"
            }`}
          >
            Chassi
          </button>
        </div>
      </div>

      <div className="overflow-hidden rounded-xl border border-slate-200 bg-white shadow-sm">
        <div
          className="grid gap-4 border-b border-slate-200 bg-slate-50 px-5 py-3 text-xs font-semibold uppercase tracking-wide text-slate-600"
          style={{ gridTemplateColumns }}
        >
          {columnOrder.map((column) => (
            <span key={column}>{columnLabels[column]}</span>
          ))}
        </div>

        <div className="divide-y divide-slate-200">
          {loading
            ? skeletonRows.map((index) => (
                <div
                  key={`ticket-skeleton-${index}`}
                  className="grid min-w-0 items-center gap-4 px-5 py-3 text-sm min-h-[56px]"
                  style={{ gridTemplateColumns }}
                >
                  {columnOrder.map((column) => (
                    <div key={`${index}-${column}`} className="min-w-0">
                      <div className="h-4 w-4/5 rounded-full bg-slate-200 animate-pulse" />
                    </div>
                  ))}
                </div>
              ))
            : groupedTickets.map(({ ticket, groupIndex }) => {
                const isStriped = filters.groupByChassi || filters.groupByEmpresa;
                const backgroundClass =
                  isStriped && groupIndex % 2 === 1 ? "bg-slate-50" : "bg-white";

                const cells: Record<ColumnId, React.ReactNode> = {
                  ticket: (
                    <div className="flex min-w-0 flex-wrap items-center gap-2">
                      <Badge tone="slate" className="max-w-[150px] truncate">
                        #{ticket.number}
                      </Badge>
                      {ticket.url && (
                        <a
                          href={ticket.url}
                          target="_blank"
                          rel="noreferrer"
                          onClick={(e) => e.stopPropagation()}
                          className="text-xs font-semibold text-sky-700 underline decoration-sky-300 decoration-2 underline-offset-4 transition hover:text-sky-900"
                        >
                          Abrir
                        </a>
                      )}
                    </div>
                  ),
                  titulo: (
                    <div className="flex min-w-0 flex-col gap-1">
                      <span className="truncate font-semibold text-slate-800">
                        {ticket.title}
                      </span>
                      {ticket.createdAt &&
                        (() => {
                          const parts = formatDateParts(ticket.createdAt);
                          return (
                            <span className="text-xs text-slate-500 leading-tight">
                              <span className="block truncate">{parts.time}</span>
                              <span className="block truncate">{parts.date}</span>
                            </span>
                          );
                        })()}
                    </div>
                  ),
                  status: (
                    <Badge
                      tone={ticketStatusTone[ticket.status]}
                      className="max-w-[120px] truncate"
                    >
                      {ticketStatusLabel[ticket.status]}
                    </Badge>
                  ),
                  chassi: (
                    <Badge
                      tone={ticket.serialNumber ? "emerald" : "slate"}
                      className="max-w-[170px] truncate"
                    >
                      {ticket.serialNumber ?? "Sem chassi"}
                    </Badge>
                  ),
                  consultor: (
                    <span className="block max-w-[220px] truncate text-slate-700">
                      {ticket.advisorName ?? "N/A"}
                    </span>
                  ),
                  cliente: (
                    <div className="flex min-w-0 max-w-[220px] flex-col">
                      <span className="truncate text-slate-700">
                        {ticket.customerName ?? "N/A"}
                      </span>
                      {ticket.customerOrganization && (
                        <span className="truncate text-xs text-slate-500">
                          {ticket.customerOrganization}
                        </span>
                      )}
                    </div>
                  ),
                  equipe: (
                    <Badge tone="sky" className="max-w-[150px] truncate">
                      {ticket.teamName ?? "N/A"}
                    </Badge>
                  ),
                  atualizado:
                    (() => {
                      const parts = formatDateParts(ticket.updatedAt);
                      return (
                        <div className="min-w-0 leading-tight">
                          <span className="block truncate text-xs font-semibold text-slate-700">
                            {parts.time}
                          </span>
                          <span className="block truncate text-xs text-slate-500">
                            {parts.date}
                          </span>
                        </div>
                      );
                    })(),
                  acoes: (
                    <ActionButtonCell
                      entity="ticket"
                      ticketId={ticket.id}
                      ticketStatus={ticket.status}
                    />
                  ),
                };

                return (
                  <div
                    key={ticket.id}
                    role={onTicketSelect ? "button" : undefined}
                    tabIndex={onTicketSelect ? 0 : undefined}
                    onClick={
                      onTicketSelect ? () => onTicketSelect(ticket) : undefined
                    }
                    onKeyDown={
                      onTicketSelect
                        ? (e) => {
                            if (e.key === "Enter" || e.key === " ") {
                              e.preventDefault();
                              onTicketSelect(ticket);
                            }
                          }
                        : undefined
                    }
                    className={`grid min-w-0 items-center gap-4 px-5 py-3 text-sm text-slate-800 hover:bg-slate-50 ${backgroundClass} ${
                      onTicketSelect
                        ? "cursor-pointer focus:outline-none focus:ring-2 focus:ring-sky-200"
                        : ""
                    }`}
                    style={{ gridTemplateColumns }}
                  >
                    {columnOrder.map((column) => (
                      <div key={column} className="min-w-0 overflow-hidden">
                        {cells[column]}
                      </div>
                    ))}
                  </div>
                );
              })}
          {!loading && tickets.length === 0 && (
            <div className="px-5 py-4 text-sm text-slate-500">
              {loading
                ? "Carregando tickets..."
                : "Nenhum ticket encontrado com esses filtros."}
            </div>
          )}
        </div>
      </div>

      <div className="flex flex-col gap-2 rounded-lg border border-slate-200 bg-slate-50 px-3 py-2 text-xs text-slate-600 sm:flex-row sm:items-center sm:justify-between sm:text-sm">
        <div className="flex items-center gap-2">
          <span>
            Página {page} de {totalPages}
          </span>
          <span className="text-slate-400">({total} tickets filtrados)</span>
        </div>
        <div className="flex items-center gap-2">
          <button
            type="button"
            onClick={() => onPageChange(-1)}
            disabled={page <= 1 || loading}
            className="rounded-lg border border-slate-200 bg-white px-3 py-1 text-sm font-semibold text-slate-700 transition enabled:hover:border-slate-300 enabled:hover:text-slate-900 disabled:opacity-50"
          >
            Anterior
          </button>
          <button
            type="button"
            onClick={() => onPageChange(1)}
            disabled={page >= totalPages || loading}
            className="rounded-lg border border-slate-200 bg-white px-3 py-1 text-sm font-semibold text-slate-700 transition enabled:hover:border-slate-300 enabled:hover:text-slate-900 disabled:opacity-50"
          >
            Próxima
          </button>
        </div>
      </div>
    </div>
  );
}



================================================
FILE: src/components/TicketsMetricsView.tsx
================================================
"use client";

import { Ticket, TimeRange } from "@/lib/domain";
import { MetricCard } from "./MetricCard";

type TicketsMetricsViewProps = {
  tickets: Ticket[];
  timeRange: TimeRange;
};

const DAY_MS = 24 * 60 * 60 * 1000;

const isWithinRange = (dateStr: string | null, range: TimeRange) => {
  if (!dateStr) return false;

  const date = new Date(dateStr);
  const now = new Date();
  const diff = now.getTime() - date.getTime();

  if (Number.isNaN(diff) || diff < 0) {
    return false;
  }

  switch (range) {
    case "today":
      return date.toDateString() === now.toDateString();
    case "week":
      return diff <= 7 * DAY_MS;
    case "month":
      return diff <= 30 * DAY_MS;
    case "year":
      return date.getFullYear() === now.getFullYear();
    default:
      return false;
  }
};

export function TicketsMetricsView({
  tickets,
  timeRange,
}: TicketsMetricsViewProps) {
  const ticketsInRange = tickets.filter((ticket) =>
    isWithinRange(ticket.createdAt ?? ticket.updatedAt, timeRange),
  );
  const openTickets = ticketsInRange.filter(
    (ticket) => ticket.status === "aberto",
  );
  const closedTickets = ticketsInRange.filter(
    (ticket) => ticket.status === "fechado",
  );

  return (
    <div className="grid gap-4 sm:grid-cols-2 lg:grid-cols-3">
      <MetricCard label="Tickets adicionados" value={ticketsInRange.length} />
      <MetricCard label="Tickets abertos" value={openTickets.length} />
      <MetricCard label="Tickets fechados" value={closedTickets.length} />
    </div>
  );
}



================================================
FILE: src/components/TimeRangeSelector.tsx
================================================
"use client";

import { TimeRange } from "@/lib/domain";

type TimeRangeSelectorProps = {
  activeRange: TimeRange;
  onChange: (range: TimeRange) => void;
};

const ranges: { id: TimeRange; label: string }[] = [
  { id: "today", label: "Hoje" },
  { id: "week", label: "7 dias" },
  { id: "month", label: "30 dias" },
  { id: "year", label: "Esse ano" },
];

export function TimeRangeSelector({
  activeRange,
  onChange,
}: TimeRangeSelectorProps) {
  return (
    <div className="inline-flex items-center divide-x divide-slate-200 rounded-lg border border-slate-200 bg-white">
      {ranges.map((range) => {
        const isActive = range.id === activeRange;
        return (
          <button
            key={range.id}
            type="button"
            onClick={() => onChange(range.id)}
            className={`px-4 py-2 text-sm font-semibold transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-300/80 focus-visible:z-10 first:rounded-l-lg last:rounded-r-lg ${
              isActive
                ? "bg-sky-100 text-sky-800"
                : "bg-transparent text-slate-600 hover:bg-slate-50 hover:text-slate-900"
            }`}
          >
            {range.label}
          </button>
        );
      })}
    </div>
  );
}



================================================
FILE: src/components/ToastProvider.tsx
================================================
"use client";

import React, { createContext, useCallback, useContext, useMemo, useState } from "react";

type ToastVariant = "success" | "error";

type Toast = {
  id: string;
  variant: ToastVariant;
  message: string;
};

type ToastContextValue = {
  push: (toast: Omit<Toast, "id">) => void;
};

const ToastContext = createContext<ToastContextValue | null>(null);

const toastClasses: Record<ToastVariant, string> = {
  success: "border-emerald-200 bg-emerald-50 text-emerald-900",
  error: "border-rose-200 bg-rose-50 text-rose-900",
};

export function ToastProvider({ children }: { children: React.ReactNode }) {
  const [toasts, setToasts] = useState<Toast[]>([]);

  const push = useCallback((toast: Omit<Toast, "id">) => {
    const id = `${Date.now()}-${Math.random().toString(16).slice(2)}`;
    const next: Toast = { id, ...toast };
    setToasts((prev) => [...prev, next]);

    window.setTimeout(() => {
      setToasts((prev) => prev.filter((t) => t.id !== id));
    }, 3200);
  }, []);

  const value = useMemo<ToastContextValue>(() => ({ push }), [push]);

  return (
    <ToastContext.Provider value={value}>
      {children}
      <div className="pointer-events-none fixed right-4 top-4 z-50 flex w-[min(420px,calc(100vw-2rem))] flex-col gap-2">
        {toasts.map((toast) => (
          <div
            key={toast.id}
            className={`pointer-events-auto rounded-xl border px-4 py-3 text-sm shadow-lg ${toastClasses[toast.variant]}`}
            role="status"
          >
            {toast.message}
          </div>
        ))}
      </div>
    </ToastContext.Provider>
  );
}

export function useToast() {
  const ctx = useContext(ToastContext);
  if (!ctx) {
    throw new Error("useToast deve ser usado dentro de <ToastProvider />");
  }
  return ctx;
}




================================================
FILE: src/components/UserActionMetricsView.tsx
================================================
﻿"use client";

import { useEffect, useMemo, useState } from "react";
import {
  CartesianGrid,
  Cell,
  Line,
  LineChart,
  Pie,
  PieChart,
  ResponsiveContainer,
  Tooltip,
  type TooltipContentProps,
  XAxis,
  YAxis,
} from "recharts";
import type {
  DailyActionMetricsRow,
  MetricsRange,
  UserActionEventRow,
  UserActionMetricsRow,
  UserIdentity,
} from "@/lib/metrics";
import type { EventPayload } from "@/lib/events";
import { listMetricsRangeDays } from "@/lib/metrics";
import {
  LEAD_ACTION_DEFINITIONS,
  TICKET_ACTION_DEFINITIONS,
} from "@/lib/events";

type EntityKind = "leads" | "tickets";

type UserActionMetricsViewProps = {
  entity: EntityKind;
  rows: UserActionMetricsRow[];
  daily: DailyActionMetricsRow[];
  events: UserActionEventRow[];
  users: UserIdentity[];
  selectedUserId: string | null;
  range: MetricsRange;
  viewMode: "actions" | "billing";
  onActionEventClick?: (event: UserActionEventRow) => void;
};

type ActionTone =
  | "sky"
  | "emerald"
  | "amber"
  | "rose"
  | "slate"
  | "violet"
  | "stone";

const actionTone = (action: string): ActionTone => {
  const normalized = action.toLowerCase();
  if (normalized.includes("register_contact")) return "sky";
  if (normalized.includes("discard")) return "rose";
  if (normalized.includes("close")) return "emerald";
  if (normalized.includes("reopen")) return "amber";
  if (normalized.includes("convert")) return "violet";
  if (normalized.includes("add_tags")) return "violet";
  if (normalized.includes("remove_tags")) return "rose";
  if (normalized.includes("assign")) return "sky";
  if (normalized.includes("qualify")) return "emerald";
  if (normalized.includes("update_field")) return "slate";
  if (normalized.includes("add_note")) return "amber";
  return "stone";
};

const TONE_FILL: Record<ActionTone, string> = {
  sky: "#0EA5E9",
  emerald: "#10B981",
  amber: "#F59E0B",
  rose: "#F43F5E",
  slate: "#475569",
  violet: "#8B5CF6",
  stone: "#78716C",
};

type ChartDatum = {
  action: string;
  label: string;
  count: number;
  tone: ActionTone;
};

const truncateLabel = (value: string, maxChars = 28) => {
  if (value.length <= maxChars) return value;
  const sliceLen = Math.max(0, maxChars - 3);
  return `${value.slice(0, sliceLen)}...`;
};

type DailyChartDatum = {
  date: string;
  total: number;
};

const shortDateFormatter = new Intl.DateTimeFormat("pt-BR", {
  day: "2-digit",
  month: "short",
});

const currencyFormatter = new Intl.NumberFormat("pt-BR", {
  style: "currency",
  currency: "BRL",
});

const formatShortDate = (value: string) => {
  const parsed = new Date(`${value}T00:00:00Z`);
  if (Number.isNaN(parsed.getTime())) return value;
  return shortDateFormatter.format(parsed);
};

const getUserLabel = (user: UserIdentity) => {
  const name = user.name?.trim();
  if (name) return name;
  const email = user.email?.trim();
  if (email) return email;
  return user.id;
};

const buildUserOptions = (
  users: UserIdentity[],
  rows: UserActionMetricsRow[]
) => {
  const map = new Map<string, UserIdentity>();
  users.forEach((user) => map.set(user.id, user));
  rows.forEach((row) => {
    const existing = map.get(row.actor_user_id);
    map.set(row.actor_user_id, {
      id: row.actor_user_id,
      name: row.actor_name || existing?.name,
      email: row.actor_email || existing?.email,
    });
  });
  return Array.from(map.values());
};

const getSelectedUser = (
  userOptions: UserIdentity[],
  selectedUserId: string | null
) => {
  if (!userOptions.length) return null;
  if (!selectedUserId) return userOptions[0];
  return (
    userOptions.find((user) => user.id === selectedUserId) ?? userOptions[0]
  );
};

type UserActionMetricsHeaderProps = {
  rows: UserActionMetricsRow[];
  users: UserIdentity[];
  selectedUserId: string | null;
  onSelectedUserIdChange: (id: string | null) => void;
};

export function UserActionMetricsHeader({
  rows,
  users,
  selectedUserId,
  onSelectedUserIdChange,
}: UserActionMetricsHeaderProps) {
  const userOptions = useMemo(
    () => buildUserOptions(users, rows),
    [rows, users]
  );
  const selectedUser = useMemo(
    () => getSelectedUser(userOptions, selectedUserId),
    [selectedUserId, userOptions]
  );

  useEffect(() => {
    if (!userOptions.length) {
      if (selectedUserId !== null) {
        onSelectedUserIdChange(null);
      }
      return;
    }

    if (
      selectedUserId &&
      userOptions.some((user) => user.id === selectedUserId)
    ) {
      return;
    }

    onSelectedUserIdChange(userOptions[0].id);
  }, [onSelectedUserIdChange, selectedUserId, userOptions]);

  const selectedRow = selectedUser
    ? rows.find((row) => row.actor_user_id === selectedUser.id) ?? null
    : null;

  const selectedDisplayName =
    selectedRow?.actor_name ||
    selectedRow?.actor_email ||
    (selectedUser ? getUserLabel(selectedUser) : "Nenhum usuario");
  const selectedEmail = selectedRow?.actor_email || selectedUser?.email || "";
  const periodMessage =
    rows.length === 0
      ? "Nenhuma acao registrada nesse periodo."
      : !selectedRow
      ? "Nenhuma acao registrada para esse usuario no periodo."
      : null;

  return (
    <div className="rounded-xl border border-slate-200 bg-slate-50 px-5 py-4 shadow-sm">
      <div className="flex flex-col gap-4 md:flex-row md:items-center md:justify-between">
        <div className="min-w-0">
          <div className="text-xs font-semibold uppercase tracking-wide text-slate-500">
            Usuario
          </div>
          <div className="mt-1 truncate text-sm font-semibold text-slate-900">
            {selectedDisplayName}
          </div>
          {selectedEmail ? (
            <div className="truncate text-xs text-slate-500">
              {selectedEmail}
            </div>
          ) : null}
          {/* {periodMessage ? (
            <div className="mt-2 text-xs text-slate-500">{periodMessage}</div>
          ) : null} */}
        </div>

        <label className="flex w-full flex-col gap-1 text-xs font-semibold uppercase tracking-wide text-slate-500 md:w-64">
          <span>Selecionar pessoa</span>
          <select
            value={selectedUser?.id ?? ""}
            onChange={(event) => onSelectedUserIdChange(event.target.value)}
            disabled={!userOptions.length}
            className="w-full rounded-lg border border-slate-200 bg-white px-3 py-2 text-xs font-semibold text-slate-700 transition focus:border-sky-400 focus:outline-none focus:ring-2 focus:ring-sky-100 disabled:cursor-not-allowed disabled:bg-slate-100 disabled:text-slate-400"
          >
            {userOptions.length ? (
              userOptions.map((option) => (
                <option key={option.id} value={option.id}>
                  {getUserLabel(option)}
                </option>
              ))
            ) : (
              <option value="">Nenhum usuario</option>
            )}
          </select>
        </label>
      </div>
    </div>
  );
}

function ActionsTooltip({
  active,
  payload,
}: Partial<TooltipContentProps<number, string>>) {
  if (!active || !payload?.length) return null;
  const datum = (payload[0] as { payload?: ChartDatum }).payload;
  if (!datum) return null;

  return (
    <div className="rounded-lg border border-slate-200 bg-white px-3 py-2 text-xs shadow-sm">
      <div className="font-semibold text-slate-900">{datum.label}</div>
      <div className="mt-1 text-slate-600">
        {datum.count} {datum.count === 1 ? "acao" : "acoes"}
      </div>
    </div>
  );
}

function DailyActionsTooltip({
  active,
  payload,
}: Partial<TooltipContentProps<number, string>>) {
  if (!active || !payload?.length) return null;
  const datum = (payload[0] as { payload?: DailyChartDatum }).payload;
  if (!datum) return null;

  return (
    <div className="rounded-lg border border-slate-200 bg-white px-3 py-2 text-xs shadow-sm">
      <div className="font-semibold text-slate-900">
        {formatShortDate(datum.date)}
      </div>
      <div className="mt-1 text-slate-600">
        {datum.total} {datum.total === 1 ? "acao" : "acoes"}
      </div>
    </div>
  );
}

function BillingTooltip({
  active,
  payload,
}: Partial<TooltipContentProps<number, string>>) {
  if (!active || !payload?.length) return null;
  const datum = (payload[0] as { payload?: DailyChartDatum }).payload;
  if (!datum) return null;

  return (
    <div className="rounded-lg border border-slate-200 bg-white px-3 py-2 text-xs shadow-sm">
      <div className="font-semibold text-slate-900">
        {formatShortDate(datum.date)}
      </div>
      <div className="mt-1 text-slate-600">
        {currencyFormatter.format(datum.total)}
      </div>
    </div>
  );
}

export function UserActionMetricsView({
  entity,
  rows,
  daily,
  events,
  users,
  selectedUserId,
  range,
  viewMode,
  onActionEventClick,
}: UserActionMetricsViewProps) {
  const definitions =
    entity === "leads" ? LEAD_ACTION_DEFINITIONS : TICKET_ACTION_DEFINITIONS;

  const labelByAction = useMemo(() => {
    const map = new Map<string, string>();
    definitions.forEach((def) => map.set(def.id, def.label));
    return map;
  }, [definitions]);

  const userOptions = useMemo(
    () => buildUserOptions(users, rows),
    [rows, users]
  );
  const selectedUser = useMemo(
    () => getSelectedUser(userOptions, selectedUserId),
    [selectedUserId, userOptions]
  );

  const selectedRow = selectedUser
    ? rows.find((row) => row.actor_user_id === selectedUser.id) ?? null
    : null;

  const totalActions = selectedRow?.total_actions ?? 0;
  const uniqueItems = selectedRow?.unique_items ?? 0;
  const dailyEmptyMessage = selectedUser
    ? "Sem dados diarios para esse usuario no periodo."
    : "Sem dados diarios para esse periodo.";
  const distributionEmptyMessage = selectedUser
    ? "Nenhuma acao registrada para esse usuario no periodo."
    : "Nenhuma acao registrada nesse periodo.";
  const billingEmptyMessage = selectedUser
    ? "Sem faturamento para esse usuario no periodo."
    : "Sem faturamento nesse periodo.";
  const lineTitle = viewMode === "billing" ? "Faturamento por dia" : "Acoes por dia";
  const lineEmptyMessage = viewMode === "billing" ? billingEmptyMessage : dailyEmptyMessage;
  const distributionTitle =
    viewMode === "billing" ? "Distribuicao de fechamentos" : "Distribuicao de acoes";
  const listTitle =
    viewMode === "billing" ? "Lista de fechamentos no periodo" : "Lista de acoes no periodo";

  const billingActionIds = useMemo(() => {
    if (entity !== "leads") return [] as string[];
    return ["close_with_os", "close_without_os"];
  }, [entity]);

  const chartData: ChartDatum[] = (() => {
    const breakdown = selectedRow?.actions_breakdown ?? {};
    if (viewMode === "billing") {
      const items = billingActionIds.map((action) => ({
        action,
        label: labelByAction.get(action) ?? action,
        count: breakdown[action] ?? 0,
        tone: action === "close_with_os" ? ("emerald" as const) : ("amber" as const),
      }));
      return items.filter((item) => item.count > 0);
    }

    const entries = Object.entries(breakdown).sort((a, b) => b[1] - a[1]);
    const topEntries = entries.slice(0, 10);
    const remainingCount = entries
      .slice(10)
      .reduce((acc, [, count]) => acc + count, 0);

    return [
      ...topEntries.map(([action, count]) => ({
        action,
        label: labelByAction.get(action) ?? action,
        count,
        tone: actionTone(action),
      })),
      ...(remainingCount > 0
        ? [
            {
              action: "__other__",
              label: "Outras acoes",
              count: remainingCount,
              tone: "slate" as const,
            },
          ]
        : []),
    ];
  })();

  const dailySeries: DailyChartDatum[] = useMemo(() => {
    if (!selectedUser) return [];
    const byDate = new Map<string, number>();
    daily
      .filter((row) => row.actor_user_id === selectedUser.id)
      .forEach((row) => {
        byDate.set(row.date, (byDate.get(row.date) ?? 0) + row.total_actions);
      });

    return listMetricsRangeDays(range).map((date) => ({
      date,
      total: byDate.get(date) ?? 0,
    }));
  }, [daily, range, selectedUser?.id]);

  const billingDailySeries: DailyChartDatum[] = useMemo(() => {
    if (!selectedUser || entity !== "leads") return [];
    const byDate = new Map<string, Map<string, number>>();

    events
      .filter((event) => event.actor_user_id === selectedUser.id)
      .filter((event) => event.action === "close_with_os")
      .forEach((event) => {
        const os = String(event.payload?.os ?? "").trim();
        if (!os) return;
        const date = new Date(event.occurred_at);
        if (Number.isNaN(date.getTime())) return;
        const dayKey = date.toISOString().slice(0, 10);
        const value = getTotalValue((event.payload ?? {}) as EventPayload);
        if (!value) return;

        const byOs = byDate.get(dayKey) ?? new Map<string, number>();
        if (!byOs.has(os)) {
          byOs.set(os, value);
          byDate.set(dayKey, byOs);
        }
      });

    return listMetricsRangeDays(range).map((date) => {
      const byOs = byDate.get(date);
      const total = byOs
        ? Array.from(byOs.values()).reduce((acc, value) => acc + value, 0)
        : 0;
      return { date, total };
    });
  }, [entity, events, range, selectedUser?.id]);

  const lineSeries = viewMode === "billing" ? billingDailySeries : dailySeries;

  const [actionFilter, setActionFilter] = useState<string>("all");
  useEffect(() => {
    setActionFilter("all");
  }, [selectedUser?.id, viewMode]);
  const actionFilterOptions = useMemo(() => {
    const breakdown = selectedRow?.actions_breakdown ?? {};
    if (viewMode === "billing") {
      return billingActionIds
        .map((action) => ({
          action,
          label: labelByAction.get(action) ?? action,
          count: breakdown[action] ?? 0,
        }))
        .filter((item) => item.count > 0)
        .map(({ action, label }) => ({ action, label }));
    }
    return Object.entries(breakdown)
      .sort((a, b) => b[1] - a[1])
      .map(([action]) => ({
        action,
        label: labelByAction.get(action) ?? action,
      }));
  }, [billingActionIds, labelByAction, selectedRow?.actions_breakdown, viewMode]);

  const actionEvents = useMemo(() => {
    if (!selectedUser) return [];
    return events
      .filter((event) => event.actor_user_id === selectedUser.id)
      .filter(
        (event) => viewMode !== "billing" || billingActionIds.includes(event.action),
      )
      .filter(
        (event) => actionFilter === "all" || event.action === actionFilter
      )
      .sort((a, b) => b.occurred_at.localeCompare(a.occurred_at));
  }, [actionFilter, billingActionIds, events, selectedUser?.id, viewMode]);

  const hasAnyEventsForUser = useMemo(() => {
    if (!selectedUser) return false;
    return events.some((event) => {
      if (event.actor_user_id !== selectedUser.id) return false;
      if (viewMode !== "billing") return true;
      return billingActionIds.includes(event.action);
    });
  }, [billingActionIds, events, selectedUser?.id, viewMode]);

  const formatEventDate = (value: string) => {
    const date = new Date(value);
    if (Number.isNaN(date.getTime())) return value;
    return date.toLocaleDateString("pt-BR");
  };

  function parseMoney(value: unknown): number | null {
    if (typeof value === "number") {
      return Number.isFinite(value) ? value : null;
    }
    if (typeof value !== "string") return null;
    const trimmed = value.trim();
    if (!trimmed) return null;
    const normalized = trimmed.replace(/[^\d,.-]/g, "");
    if (!normalized) return null;
    let numeric = normalized;
    if (numeric.includes(",") && numeric.includes(".")) {
      numeric = numeric.replace(/\./g, "").replace(",", ".");
    } else if (numeric.includes(",")) {
      numeric = numeric.replace(",", ".");
    }
    const parsed = Number.parseFloat(numeric);
    return Number.isFinite(parsed) ? parsed : null;
  }

  function getTotalValue(payload: EventPayload | null) {
    if (!payload) return null;
    const parts = parseMoney(payload.parts_value);
    const labor = parseMoney(payload.labor_value);
    if (parts !== null || labor !== null) {
      return (parts ?? 0) + (labor ?? 0);
    }
    return parseMoney(payload.valor);
  }

  const formatPayloadDetails = (event: UserActionEventRow) => {
    const payload = (event.payload ?? {}) as EventPayload;
    const details: { label: string; value: string }[] = [];

    if (payload.note) {
      details.push({ label: "Nota", value: String(payload.note) });
    }
    if (payload.reason) {
      details.push({ label: "Motivo", value: String(payload.reason) });
    }
    if (payload.assignee) {
      details.push({ label: "Responsavel", value: String(payload.assignee) });
    }
    if (payload.os) {
      details.push({ label: "OS", value: String(payload.os) });
    }
    const partsValue = parseMoney(payload.parts_value);
    const laborValue = parseMoney(payload.labor_value);
    if (partsValue !== null) {
      details.push({
        label: "Pecas",
        value: currencyFormatter.format(partsValue),
      });
    }
    if (laborValue !== null) {
      details.push({
        label: "Mao de obra",
        value: currencyFormatter.format(laborValue),
      });
    }
    const totalValue = getTotalValue(payload);
    if (totalValue !== null && (partsValue !== null || laborValue !== null)) {
      details.push({
        label: "Total",
        value: currencyFormatter.format(totalValue),
      });
    }
    if (
      totalValue === null &&
      payload.valor &&
      (partsValue === null || laborValue === null)
    ) {
      details.push({ label: "Valor", value: String(payload.valor) });
    }
    if (payload.method) {
      details.push({ label: "Metodo", value: String(payload.method) });
    }
    if (Array.isArray(payload.tags) && payload.tags.length) {
      details.push({ label: "Tags", value: payload.tags.join(", ") });
    }
    if (
      payload.changed_fields &&
      typeof payload.changed_fields === "object" &&
      !Array.isArray(payload.changed_fields)
    ) {
      const entries = Object.entries(payload.changed_fields as Record<string, string>)
        .map(([key, value]) => `${key}: ${value}`)
        .join(", ");
      if (entries) {
        details.push({ label: "Campos alterados", value: entries });
      }
    }

    return details;
  };

  const isEventClickable = Boolean(onActionEventClick);

  return (
    <div className="overflow-hidden rounded-xl border border-slate-200 bg-white shadow-sm">
      <div className="flex flex-col gap-4 border-b border-slate-200 bg-slate-50 px-5 py-4">
        {/* <div className="grid gap-3 sm:grid-cols-2">
          <div className="rounded-lg border border-slate-200 bg-white px-4 py-3">
            <div className="text-xs font-semibold uppercase tracking-wide text-slate-500">
              Total de acoes
            </div>
            <div className="mt-1 text-2xl font-semibold text-slate-900">
              {totalActions}
            </div>
          </div>
          <div className="rounded-lg border border-slate-200 bg-white px-4 py-3">
            <div className="text-xs font-semibold uppercase tracking-wide text-slate-500">
              Itens unicos
            </div>
            <div className="mt-1 text-2xl font-semibold text-slate-900">
              {uniqueItems}
            </div>
          </div>
        </div> */}
      </div>

      <div className="border-b border-slate-200 px-5 py-4">
        <div className="text-xs font-semibold uppercase tracking-wide text-slate-500">
          {lineTitle}
        </div>
        {lineSeries.length > 0 ? (
          <div className="mt-3 h-56 w-full">
            <ResponsiveContainer width="100%" height="100%">
              <LineChart
                data={lineSeries}
                margin={{ top: 8, right: 16, bottom: 8, left: 12 }}
              >
                <CartesianGrid strokeDasharray="3 3" vertical={false} />
                <XAxis
                  dataKey="date"
                  tick={{ fontSize: 12, fill: "#64748B" }}
                  tickFormatter={(value) => formatShortDate(String(value))}
                />
                <YAxis
                  allowDecimals={false}
                  tick={{ fontSize: 12, fill: "#64748B" }}
                  width={72}
                  tickFormatter={(value) =>
                    viewMode === "billing"
                      ? currencyFormatter.format(Number(value))
                      : String(value)
                  }
                />
                <Tooltip
                  cursor={{ stroke: "#E2E8F0", strokeWidth: 1 }}
                  content={viewMode === "billing" ? <BillingTooltip /> : <DailyActionsTooltip />}
                />
                <Line
                  type="monotone"
                  dataKey="total"
                  stroke="#0EA5E9"
                  strokeWidth={2}
                  dot={{ r: 3, strokeWidth: 2, fill: "#fff" }}
                />
              </LineChart>
            </ResponsiveContainer>
          </div>
        ) : (
          <div className="mt-3 text-sm text-slate-500">{lineEmptyMessage}</div>
        )}
      </div>

      <div className="px-5 py-4">
        <div className="text-xs font-semibold uppercase tracking-wide text-slate-500">
          {distributionTitle}
        </div>

        {chartData.length > 0 ? (
          <div className={`mt-3 w-full`}>
            <div className="flex flex-col gap-4 md:flex-row">
              <div className="h-64 w-full md:w-2/3">
                <ResponsiveContainer width="100%" height="100%">
                  <PieChart>
                    <Tooltip content={<ActionsTooltip />} />
                    <Pie
                      data={chartData}
                      dataKey="count"
                      nameKey="label"
                      cx="50%"
                      cy="50%"
                      innerRadius={60}
                      outerRadius={90}
                      paddingAngle={2}
                    >
                      {chartData.map((item) => (
                        <Cell key={item.action} fill={TONE_FILL[item.tone]} />
                      ))}
                    </Pie>
                  </PieChart>
                </ResponsiveContainer>
              </div>
              <div className="w-full md:w-1/3">
                <div className="text-xs font-semibold uppercase tracking-wide text-slate-500">
                  Legenda
                </div>
                <div className="mt-2 max-h-64 overflow-y-auto rounded-lg border border-slate-200 bg-slate-50 px-3 py-2 text-xs text-slate-700">
                  {chartData.map((item) => (
                    <div
                      key={`legend-${item.action}`}
                      className="flex items-start gap-2 border-b border-slate-200 py-2 last:border-b-0"
                    >
                      <span
                        className="mt-1 inline-flex h-2.5 w-2.5 rounded-full"
                        style={{ backgroundColor: TONE_FILL[item.tone] }}
                      />
                      <div className="flex-1">
                        <div className="font-semibold text-slate-900">
                          {truncateLabel(item.label, 28)}
                        </div>
                        <div className="text-slate-600">
                          {item.count} {item.count === 1 ? "acao" : "acoes"}
                        </div>
                      </div>
                    </div>
                  ))}
                </div>
              </div>
            </div>
          </div>
        ) : (
          <div className="my-3 text-sm text-slate-500">
            {viewMode === "billing" ? billingEmptyMessage : distributionEmptyMessage}
          </div>
        )}

        {hasAnyEventsForUser ? (
          <div className="mt-4">
            <div className="text-xs font-semibold uppercase tracking-wide text-slate-500">
              {listTitle}
            </div>
            <div className="mt-2">
              <label className="flex flex-col gap-1 text-[11px] font-semibold uppercase tracking-wide text-slate-500">
                <span>Filtrar por acao</span>
                <select
                  value={actionFilter}
                  onChange={(event) => setActionFilter(event.target.value)}
                  className="w-full rounded-lg border border-slate-200 bg-white px-3 py-2 text-xs font-semibold text-slate-700 transition focus:border-sky-400 focus:outline-none focus:ring-2 focus:ring-sky-100"
                >
                  <option value="all">Todas as acoes</option>
                  {actionFilterOptions.map((option) => (
                    <option key={option.action} value={option.action}>
                      {option.label}
                    </option>
                  ))}
                </select>
              </label>
            </div>
            <div className="mt-2 max-h-64 overflow-y-auto rounded-lg border border-slate-200 bg-slate-50 px-3 py-2 text-xs text-slate-700">
              {actionEvents.length > 0 ? (
                actionEvents.map((event, index) => (
                  <button
                    key={`${event.action}-${event.item_id}-${event.occurred_at}-${index}`}
                    type="button"
                    disabled={!isEventClickable}
                    onClick={() => onActionEventClick?.(event)}
                    className={`w-full border-b border-slate-200 py-2 text-left last:border-b-0 ${
                      isEventClickable
                        ? "cursor-pointer transition hover:bg-slate-100 focus:outline-none focus:ring-2 focus:ring-sky-200"
                        : "disabled:opacity-100"
                    }`}
                  >
                    {(() => {
                      const details = formatPayloadDetails(event);
                      return (
                        <>
                          <div className="font-semibold text-slate-900">
                            {labelByAction.get(event.action) ?? event.action}
                          </div>
                          <div className="text-slate-600">
                            {entity === "tickets" ? "Ticket" : "Lead"} {event.item_id}{" "}
                            - {formatEventDate(event.occurred_at)}
                          </div>
                          {details.length ? (
                            <div className="mt-2 space-y-1 text-slate-600">
                              {details.map((detail) => (
                                <div
                                  key={`${event.action}-${event.item_id}-${event.occurred_at}-${detail.label}`}
                                >
                                  <span className="font-semibold text-slate-700">
                                    {detail.label}:
                                  </span>{" "}
                                  {detail.value}
                                </div>
                              ))}
                            </div>
                          ) : null}
                        </>
                      );
                    })()}
                  </button>
                ))
              ) : (
                <div className="py-3 text-center text-slate-500">
                  {viewMode === "billing"
                    ? "Nenhum fechamento para o filtro selecionado."
                    : "Nenhuma acao para o filtro selecionado."}
                </div>
              )}
            </div>
          </div>
        ) : (
          <div className="mt-4 text-sm text-slate-500">
            {viewMode === "billing" ? billingEmptyMessage : distributionEmptyMessage}
          </div>
        )}
      </div>
    </div>
  );
}




================================================
FILE: src/components/ticket-details/CollapsibleSection.tsx
================================================
"use client";

import React from "react";

type CollapsibleSectionProps = {
  title: string;
  defaultOpen?: boolean;
  children: React.ReactNode;
  rightSlot?: React.ReactNode;
};

export function CollapsibleSection({
  title,
  defaultOpen = true,
  children,
  rightSlot,
}: CollapsibleSectionProps) {
  return (
    <details
      className="group rounded-xl border border-slate-200 bg-white shadow-sm"
      open={defaultOpen}
    >
      <summary className="flex cursor-pointer list-none items-center justify-between gap-3 px-4 py-3">
        <div className="flex min-w-0 items-center gap-2">
          <span className="text-sm font-semibold text-slate-900">{title}</span>
          <span className="text-xs text-slate-400 transition group-open:rotate-180">
            ▾
          </span>
        </div>
        {rightSlot ? <div className="shrink-0">{rightSlot}</div> : null}
      </summary>
      <div className="border-t border-slate-200 px-4 py-3">{children}</div>
    </details>
  );
}




================================================
FILE: src/components/ticket-details/KeyValueGrid.tsx
================================================
"use client";

import React from "react";

export type KeyValueItem = {
  label: string;
  value: React.ReactNode;
};

type KeyValueGridProps = {
  items: KeyValueItem[];
  columns?: 1 | 2;
};

export function KeyValueGrid({ items, columns = 2 }: KeyValueGridProps) {
  const gridClass =
    columns === 1 ? "grid grid-cols-1 gap-3" : "grid grid-cols-1 gap-3 sm:grid-cols-2";

  return (
    <div className={gridClass}>
      {items.map((item) => (
        <div key={item.label} className="min-w-0">
          <div className="text-[11px] font-semibold uppercase tracking-wide text-slate-500">
            {item.label}
          </div>
          <div className="mt-1 break-words text-sm text-slate-800">
            {item.value}
          </div>
        </div>
      ))}
    </div>
  );
}




================================================
FILE: src/components/ticket-details/TicketAdvisorCard.tsx
================================================
"use client";

import React from "react";
import { KeyValueGrid } from "@/components/ticket-details/KeyValueGrid";

type TicketAdvisorCardProps = {
  advisor: {
    name: string;
    email: string;
    racfid: string;
    team: string;
    division: string;
    template: string;
  };
};

export function TicketAdvisorCard({ advisor }: TicketAdvisorCardProps) {
  return (
    <KeyValueGrid
      items={[
        { label: "Nome do advisor", value: advisor.name },
        { label: "Email", value: advisor.email },
        { label: "RACFID", value: advisor.racfid },
        { label: "Equipe", value: advisor.team },
        { label: "Divisão", value: advisor.division },
        { label: "Template", value: advisor.template },
      ]}
    />
  );
}




================================================
FILE: src/components/ticket-details/TicketContactCard.tsx
================================================
"use client";

import React from "react";
import { Badge } from "@/components/Badge";
import { KeyValueGrid } from "@/components/ticket-details/KeyValueGrid";

type TicketContactCardProps = {
  contact: {
    name: string;
    phone: string;
    email: string;
    organization: string;
    account: string;
    externalId: string;
    segments: string[];
  };
};

export function TicketContactCard({ contact }: TicketContactCardProps) {
  return (
    <div className="space-y-3">
      <KeyValueGrid
        items={[
          { label: "Nome do cliente", value: contact.name },
          { label: "Telefone", value: contact.phone },
          { label: "Email", value: contact.email },
          { label: "Organização", value: contact.organization },
          { label: "Conta", value: contact.account },
          { label: "ID Externo", value: contact.externalId },
        ]}
      />

      <div>
        <div className="text-[11px] font-semibold uppercase tracking-wide text-slate-500">
          Segmentos
        </div>
        <div className="mt-2 flex flex-wrap gap-2">
          {contact.segments.length ? (
            contact.segments.map((seg) => (
              <Badge key={seg} tone="stone">
                {seg}
              </Badge>
            ))
          ) : (
            <span className="text-sm text-slate-600">N/A</span>
          )}
        </div>
      </div>
    </div>
  );
}




================================================
FILE: src/components/ticket-details/TicketCustomFields.tsx
================================================
"use client";

import React from "react";

type TicketCustomFieldsProps = {
  fields: Array<{ name: string; value: string }>;
};

export function TicketCustomFields({ fields }: TicketCustomFieldsProps) {
  if (!fields.length) {
    return <div className="text-sm text-slate-600">N/A</div>;
  }

  return (
    <div className="overflow-hidden rounded-xl border border-slate-200 bg-white shadow-sm">
      <div className="grid grid-cols-2 gap-3 border-b border-slate-200 bg-slate-50 px-4 py-3 text-[11px] font-semibold uppercase tracking-wide text-slate-600">
        <span>Campo</span>
        <span>Valor</span>
      </div>
      <div className="divide-y divide-slate-200">
        {fields.map((f, idx) => (
          <div
            key={`${f.name}::${idx}`}
            className="grid grid-cols-2 gap-3 px-4 py-3 text-sm text-slate-700"
          >
            <span className="font-semibold text-slate-800">{f.name}</span>
            <span className="break-words">{f.value}</span>
          </div>
        ))}
      </div>
    </div>
  );
}




================================================
FILE: src/components/ticket-details/TicketDescription.tsx
================================================
"use client";

import React from "react";

type TicketDescriptionProps = {
  description: {
    description: string;
    resolution: string;
    misc: string;
  };
};

const Block = ({ title, text }: { title: string; text: string }) => (
  <div className="space-y-1">
    <div className="text-[11px] font-semibold uppercase tracking-wide text-slate-500">
      {title}
    </div>
    <div className="rounded-lg border border-slate-200 bg-slate-50 p-3 text-sm text-slate-800 whitespace-pre-wrap break-words">
      {text}
    </div>
  </div>
);

export function TicketDescription({ description }: TicketDescriptionProps) {
  return (
    <div className="space-y-3">
      <Block title="Description" text={description.description} />
      <Block title="Resolution" text={description.resolution} />
      <Block title="Misc" text={description.misc} />
    </div>
  );
}




================================================
FILE: src/components/ticket-details/TicketHeader.tsx
================================================
"use client";

import React from "react";
import { Badge } from "@/components/Badge";

type TicketHeaderProps = {
  number: string;
  title: string;
  status: string;
  priority: string;
  url: string | null;
  onClose: () => void;
};

const statusTone = (status: string): Parameters<typeof Badge>[0]["tone"] => {
  const normalized = status.trim().toLowerCase();
  if (normalized.includes("open") || normalized.includes("abert")) return "amber";
  if (normalized.includes("close") || normalized.includes("fech")) return "emerald";
  if (normalized.includes("cancel")) return "rose";
  return "slate";
};

const priorityTone = (priority: string): Parameters<typeof Badge>[0]["tone"] => {
  const normalized = priority.trim().toLowerCase();
  if (normalized.includes("high") || normalized.includes("alta") || normalized.includes("urgent")) return "rose";
  if (normalized.includes("medium") || normalized.includes("média") || normalized.includes("media")) return "amber";
  if (normalized.includes("low") || normalized.includes("baixa")) return "slate";
  return "violet";
};

export function TicketHeader({
  number,
  title,
  status,
  priority,
  url,
  onClose,
}: TicketHeaderProps) {
  return (
    <div className="sticky top-0 z-10 border-b border-slate-200 bg-white/90 px-5 py-4 backdrop-blur">
      <div className="flex items-start justify-between gap-3">
        <div className="min-w-0">
          <div className="flex flex-wrap items-center gap-2">
            <Badge tone="slate">#{number}</Badge>
            <Badge tone={statusTone(status)}>{status}</Badge>
            <Badge tone={priorityTone(priority)}>Prioridade: {priority}</Badge>
          </div>
          <h2 className="mt-2 line-clamp-2 text-base font-semibold text-slate-900">
            {title}
          </h2>
        </div>

        <div className="flex shrink-0 items-center gap-2">
          {url ? (
            <a
              href={url}
              target="_blank"
              rel="noreferrer"
              className="inline-flex items-center justify-center rounded-lg border border-slate-200 bg-white px-3 py-2 text-xs font-semibold text-slate-700 transition hover:border-slate-300 hover:text-slate-900"
            >
              Abrir no ExpertConnect
            </a>
          ) : null}
          <button
            type="button"
            onClick={onClose}
            aria-label="Fechar"
            className="inline-flex h-9 w-9 items-center justify-center rounded-lg border border-slate-200 bg-white text-slate-700 transition hover:border-slate-300 hover:text-slate-900"
          >
            ✕
          </button>
        </div>
      </div>
    </div>
  );
}




================================================
FILE: src/components/ticket-details/TicketMachineList.tsx
================================================
"use client";

import React from "react";
import { Badge } from "@/components/Badge";

type TicketMachineListProps = {
  machines: Array<{
    serialNumber: string;
    productNote: string;
    details: Array<{ date: string; machineHours: string }>;
  }>;
};

export function TicketMachineList({ machines }: TicketMachineListProps) {
  if (!machines.length) {
    return <div className="text-sm text-slate-600">N/A</div>;
  }

  return (
    <div className="space-y-3">
      {machines.map((machine, index) => (
        <div
          key={`${machine.serialNumber}::${index}`}
          className="rounded-xl border border-slate-200 bg-slate-50 p-3"
        >
          <div className="flex flex-wrap items-center gap-2">
            <Badge tone="emerald">{machine.serialNumber}</Badge>
            <span className="text-sm font-semibold text-slate-800">
              {machine.productNote}
            </span>
          </div>

          <div className="mt-3 overflow-hidden rounded-lg border border-slate-200 bg-white">
            <div className="grid grid-cols-2 gap-3 border-b border-slate-200 bg-slate-50 px-3 py-2 text-[11px] font-semibold uppercase tracking-wide text-slate-600">
              <span>Data</span>
              <span>Machine hours</span>
            </div>
            <div className="divide-y divide-slate-200">
              {machine.details.length ? (
                machine.details.map((d, i) => (
                  <div
                    key={`${machine.serialNumber}::${i}`}
                    className="grid grid-cols-2 gap-3 px-3 py-2 text-sm text-slate-700"
                  >
                    <span className="truncate">{d.date}</span>
                    <span className="truncate">{d.machineHours}</span>
                  </div>
                ))
              ) : (
                <div className="px-3 py-2 text-sm text-slate-600">N/A</div>
              )}
            </div>
          </div>
        </div>
      ))}
    </div>
  );
}




================================================
FILE: src/components/ticket-details/TicketMetaInfo.tsx
================================================
"use client";

import React from "react";
import { KeyValueGrid } from "@/components/ticket-details/KeyValueGrid";

type TicketMetaInfoProps = {
  meta: {
    createdAt: string;
    updatedAt: string;
    closedAt: string;
    product: string;
    serialNumber: string;
    machineHours: string;
    status: string;
    source: string;
    support: string;
    timeToFirstResponse: string;
  };
};

export function TicketMetaInfo({ meta }: TicketMetaInfoProps) {
  return (
    <KeyValueGrid
      items={[
        { label: "Criado em", value: meta.createdAt },
        { label: "Atualizado em", value: meta.updatedAt },
        { label: "Fechado em", value: meta.closedAt },
        { label: "Produto", value: meta.product },
        { label: "Número de série", value: meta.serialNumber },
        { label: "Horas da máquina", value: meta.machineHours },
        { label: "Status", value: meta.status },
        { label: "Source", value: meta.source },
        { label: "Support", value: meta.support },
        { label: "Time to first response", value: meta.timeToFirstResponse },
      ]}
    />
  );
}




================================================
FILE: src/components/ticket-details/TicketTags.tsx
================================================
"use client";

import React from "react";
import { Badge } from "@/components/Badge";

type TicketTagsProps = {
  tags: { name: string; subTags: string[] }[];
};

export function TicketTags({ tags }: TicketTagsProps) {
  if (!tags.length) {
    return <div className="text-sm text-slate-600">N/A</div>;
  }

  return (
    <div className="space-y-3">
      {tags.map((tag) => (
        <div key={tag.name} className="rounded-lg border border-slate-200 bg-slate-50 px-3 py-2">
          <div className="flex flex-wrap items-center gap-2">
            <Badge tone="violet">{tag.name}</Badge>
            {tag.subTags.length ? (
              <span className="text-xs font-semibold uppercase tracking-wide text-slate-400">
                Subtags
              </span>
            ) : null}
          </div>
          {tag.subTags.length ? (
            <div className="mt-2 flex flex-wrap gap-2">
              {tag.subTags.map((sub) => (
                <Badge key={`${tag.name}::${sub}`} tone="stone">
                  {sub}
                </Badge>
              ))}
            </div>
          ) : null}
        </div>
      ))}
    </div>
  );
}




================================================
FILE: src/components/ticket-details/TicketWatchers.tsx
================================================
"use client";

import React from "react";
import { Badge } from "@/components/Badge";

type TicketWatchersProps = {
  watchers: Array<{ name: string; type: string; watchType: string }>;
};

export function TicketWatchers({ watchers }: TicketWatchersProps) {
  if (!watchers.length) {
    return <div className="text-sm text-slate-600">N/A</div>;
  }

  return (
    <div className="space-y-2">
      {watchers.map((w, idx) => (
        <div
          key={`${w.name}::${idx}`}
          className="flex flex-col gap-2 rounded-xl border border-slate-200 bg-white p-3 shadow-sm sm:flex-row sm:items-center sm:justify-between"
        >
          <div className="min-w-0">
            <div className="truncate text-sm font-semibold text-slate-900">
              {w.name}
            </div>
            <div className="mt-1 flex flex-wrap gap-2">
              <Badge tone="slate">{w.type}</Badge>
              <Badge tone="sky">{w.watchType}</Badge>
            </div>
          </div>
        </div>
      ))}
    </div>
  );
}




================================================
FILE: src/contexts/AuthContext.tsx
================================================
"use client";

import {
  createContext,
  useContext,
  useEffect,
  useMemo,
  useRef,
  useState,
} from "react";
import type { Session, User } from "@supabase/supabase-js";
import { createSupabaseBrowserClient } from "@/lib/supabaseClient";

type AuthState = {
  user: User | null;
  session: Session | null;
  loading: boolean;
  error: string | null;
};

type AuthContextValue = AuthState;

const AuthContext = createContext<AuthContextValue | null>(null);

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const supabase = useMemo(() => createSupabaseBrowserClient(), []);
  const [state, setState] = useState<AuthState>({
    user: null,
    session: null,
    loading: true,
    error: null,
  });
  const didValidateUserRef = useRef(false);

  useEffect(() => {
    let active = true;

    const bootstrap = async () => {
      setState((prev) => ({ ...prev, loading: true }));

      const {
        data: { session },
        error: sessionError,
      } = await supabase.auth.getSession();

      if (!active) return;

      setState((prev) => ({
        ...prev,
        session,
        user: session?.user ?? null,
        error: sessionError?.message ?? null,
        loading: true,
      }));

      if (session?.access_token && !didValidateUserRef.current) {
        didValidateUserRef.current = true;
        // Validate once on boot to avoid calling /auth/v1/user on every navigation.
        const {
          data: { user },
          error: userError,
        } = await supabase.auth.getUser();

        if (!active) return;

        setState((prev) => ({
          ...prev,
          user: user ?? null,
          error: userError?.message ?? prev.error ?? null,
          loading: false,
        }));
        return;
      }

      setState((prev) => ({ ...prev, loading: false }));
    };

    void bootstrap();

    const {
      data: { subscription },
    } = supabase.auth.onAuthStateChange((_event, session) => {
      if (!active) return;
      setState({
        user: session?.user ?? null,
        session,
        loading: false,
        error: null,
      });
    });

    return () => {
      active = false;
      subscription.unsubscribe();
    };
  }, [supabase]);

  const value = useMemo(() => state, [state]);

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
}

export function useAuth(): AuthContextValue {
  const ctx = useContext(AuthContext);
  if (!ctx) {
    throw new Error("useAuth must be used inside <AuthProvider />");
  }
  return ctx;
}

export function getUserDisplayName(user: User | null): string | null {
  if (!user) return null;
  const metadata = (user.user_metadata ?? {}) as Record<string, unknown>;
  const fromMetadata =
    (typeof metadata.full_name === "string" && metadata.full_name.trim()) ||
    (typeof metadata.name === "string" && metadata.name.trim()) ||
    (typeof metadata.user_name === "string" && metadata.user_name.trim()) ||
    (typeof metadata.username === "string" && metadata.username.trim()) ||
    "";

  const fromEmail = user.email?.trim() ?? "";
  return (fromMetadata || fromEmail || "User").trim();
}



================================================
FILE: src/hooks/useCreateEvent.ts
================================================
"use client";

import { useCallback, useState } from "react";
import type { EventPayload, LeadEventAction, TicketEventAction } from "@/lib/events";

type ApiSuccess<T> = { success: true; event: T };
type ApiError = { success: false; message?: string; details?: unknown };

const ensureAuthenticated = (response: Response) => {
  if (response.status === 401) {
    if (typeof window !== "undefined") {
      window.location.href = "/login?message=Faǧa login para continuar.";
    }
    throw new Error("auth_required");
  }
};

async function postJson<T>(url: string, body: unknown): Promise<T> {
  const response = await fetch(url, {
    method: "POST",
    headers: { "content-type": "application/json" },
    body: JSON.stringify(body),
  });

  ensureAuthenticated(response);

  let json: any = null;
  try {
    json = await response.json();
  } catch {
    // ignore
  }

  if (!response.ok) {
    const message =
      (json as ApiError | null)?.message ??
      "Nǜo foi possǭvel registrar aǧǜo.";
    throw new Error(message);
  }

  if (!json?.success) {
    throw new Error(json?.message ?? "Falha ao registrar aǧǜo.");
  }

  return (json as ApiSuccess<T>).event;
}

export function useCreateEvent() {
  const [loading, setLoading] = useState(false);

  const createLeadEvent = useCallback(
    async (input: { leadId: number; action: LeadEventAction; payload: EventPayload }) => {
      setLoading(true);
      try {
        return await postJson("/api/events/lead", input);
      } finally {
        setLoading(false);
      }
    },
    [],
  );

  const createTicketEvent = useCallback(
    async (input: { ticketId: string; action: TicketEventAction; payload: EventPayload }) => {
      setLoading(true);
      try {
        return await postJson("/api/events/ticket", input);
      } finally {
        setLoading(false);
      }
    },
    [],
  );

  return { createLeadEvent, createTicketEvent, loading };
}




================================================
FILE: src/lib/api.ts
================================================
import { FiltersState, INITIAL_FILTERS } from "./filters";
import { Lead, LeadCategory, LeadServiceOrder, Ticket } from "./domain";
import {
  INITIAL_TICKET_FILTERS,
  TicketFiltersState,
} from "./ticketFilters";
import type {
  DailyActionMetricsRow,
  MetricsRange,
  UserActionEventRow,
  UserActionMetricsRow,
  UserIdentity,
} from "./metrics";

export type LeadsPageResponse = {
  items: Lead[];
  total: number;
  page: number;
  pageSize: number;
  statusOptions?: string[];
};

export type LeadsQueryParams = Partial<
  { page: number; pageSize: number; consultor: string } & FiltersState
>;

export type CreateLeadInput = {
  status?: string | null;
  regional?: string | null;
  estado?: string | null;
  city?: string | null;
  consultor?: string | null;
  nomeContato?: string | null;
  telefone?: string | null;
  chassi?: string | null;
  modelName?: string | null;
  clienteBaseEnriquecida?: string | null;
  horimetroAtualMachineList?: number | null;
  tipoLead?: LeadCategory | null;
};

export type CreateLeadResponse = {
  item: Lead;
};

export type LeadResponse = {
  success: true;
  item: Lead;
};

export type LeadImportItem = {
  status?: string | null;
  regional?: string | null;
  estado?: string | null;
  city?: string | null;
  consultor?: string | null;
  nomeContato?: string | null;
  telefone?: string | null;
  chassi?: string | null;
  clienteBaseEnriquecida?: string | null;
  horimetroAtualMachineList?: number | string | null;
  leadTipos?: string[] | string | null;
};

export type LeadImportResponse = {
  success: true;
  inserted: number;
};

export type TicketsPageResponse = {
  items: Ticket[];
  total: number;
  page: number;
  pageSize: number;
  options?: TicketFilterOptions;
};

export type TicketsQueryParams = Partial<
  { page: number; pageSize: number } & TicketFiltersState
>;

export type LeadServiceOrdersPageResponse = {
  items: LeadServiceOrder[];
  total: number;
  page: number;
  pageSize: number;
};

export type LeadServiceOrdersQueryParams = Partial<
  { page: number; pageSize: number; consultor: string } & FiltersState
>;

export type UpdateLeadServiceOrderInput = {
  partsValue: string | number;
  laborValue: string | number;
  note?: string;
};

export type UpdateLeadServiceOrderResponse = {
  item: {
    id: number;
    leadId: number | null;
    partsValue: number;
    laborValue: number;
    note: string | null;
    updatedAt: string;
  };
};

export type TicketFilterOptions = {
  consultores: string[];
  clientes: string[];
  equipes: string[];
};

const ensureAuthenticated = (response: Response) => {
  if (response.status === 401) {
    if (typeof window !== "undefined") {
      window.location.href = "/login?message=Faça login para continuar.";
    }
    throw new Error("auth_required");
  }
};

export async function fetchLeads(
  params?: LeadsQueryParams,
): Promise<LeadsPageResponse> {
  const page = params?.page ?? 1;
  const pageSize = params?.pageSize ?? 10;

  const {
    search = INITIAL_FILTERS.search,
    regiao = INITIAL_FILTERS.regiao,
    estado = INITIAL_FILTERS.estado,
    tipoLead = INITIAL_FILTERS.tipoLead,
    status = INITIAL_FILTERS.status,
    sort = INITIAL_FILTERS.sort,
    groupByChassi = INITIAL_FILTERS.groupByChassi ?? false,
    groupByEmpresa = INITIAL_FILTERS.groupByEmpresa ?? false,
    consultor = "",
  } = params ?? {};

  const searchParams = new URLSearchParams({
    page: String(page),
    pageSize: String(pageSize),
    sort,
  });

  if (search) searchParams.set("search", search);
  if (regiao) searchParams.set("regiao", regiao);
  if (estado) searchParams.set("estado", estado);
  if (tipoLead) searchParams.set("tipoLead", tipoLead);
  if (status.length) searchParams.set("status", status.join(","));
  if (consultor) searchParams.set("consultor", consultor);
  const groupBy: string[] = [];
  if (groupByEmpresa) groupBy.push("empresa");
  if (groupByChassi) groupBy.push("chassi");
  if (groupBy.length) searchParams.set("groupBy", groupBy.join(","));

  const response = await fetch(`/api/leads?${searchParams.toString()}`, {
    cache: "no-store",
  });
  ensureAuthenticated(response);
  if (!response.ok) {
    throw new Error("Falha ao buscar leads do Supabase");
  }
  const data = (await response.json()) as LeadsPageResponse;
  return data;
}

export async function createLead(input: CreateLeadInput): Promise<CreateLeadResponse> {
  const response = await fetch("/api/leads", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(input),
  });
  ensureAuthenticated(response);
  if (!response.ok) {
    const text = await response.text().catch(() => "");
    throw new Error(text || "Falha ao criar lead");
  }
  return (await response.json()) as CreateLeadResponse;
}

export async function importLeads(
  items: LeadImportItem[],
): Promise<LeadImportResponse> {
  const response = await fetch("/api/leads/import", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ items }),
  });
  ensureAuthenticated(response);
  if (!response.ok) {
    const text = await response.text().catch(() => "");
    throw new Error(text || "Falha ao importar leads");
  }
  return (await response.json()) as LeadImportResponse;
}

export async function fetchTickets(
  params?: TicketsQueryParams,
): Promise<TicketsPageResponse> {
  const page = params?.page ?? 1;
  const pageSize = params?.pageSize ?? 10;

  const {
    search = INITIAL_TICKET_FILTERS.search,
    status = INITIAL_TICKET_FILTERS.status,
    sort = INITIAL_TICKET_FILTERS.sort,
    groupByEmpresa = INITIAL_TICKET_FILTERS.groupByEmpresa,
    groupByChassi = INITIAL_TICKET_FILTERS.groupByChassi,
    consultor = INITIAL_TICKET_FILTERS.consultor,
    cliente = INITIAL_TICKET_FILTERS.cliente,
    equipe = INITIAL_TICKET_FILTERS.equipe,
  } = params ?? {};

  const searchParams = new URLSearchParams({
    page: String(page),
    pageSize: String(pageSize),
    sort,
  });

  if (search) searchParams.set("search", search);
  if (status) searchParams.set("status", status);
  if (consultor) searchParams.set("consultor", consultor);
  if (cliente) searchParams.set("cliente", cliente);
  if (equipe) searchParams.set("equipe", equipe);
  const groupBy: string[] = [];
  if (groupByEmpresa) groupBy.push("empresa");
  if (groupByChassi) groupBy.push("chassi");
  if (groupBy.length) searchParams.set("groupBy", groupBy.join(","));

  const response = await fetch(`/api/tickets?${searchParams.toString()}`, {
    cache: "no-store",
  });
  ensureAuthenticated(response);
  if (!response.ok) {
    throw new Error("Falha ao buscar tickets do Supabase");
  }
  const data = (await response.json()) as TicketsPageResponse;
  return data;
}

export async function fetchLeadServiceOrders(
  params?: LeadServiceOrdersQueryParams,
): Promise<LeadServiceOrdersPageResponse> {
  const page = params?.page ?? 1;
  const pageSize = params?.pageSize ?? 10;

  const {
    search = INITIAL_FILTERS.search,
    regiao = INITIAL_FILTERS.regiao,
    estado = INITIAL_FILTERS.estado,
    tipoLead = INITIAL_FILTERS.tipoLead,
    sort = INITIAL_FILTERS.sort,
    groupByChassi = INITIAL_FILTERS.groupByChassi ?? false,
    groupByEmpresa = INITIAL_FILTERS.groupByEmpresa ?? false,
    consultor = "",
  } = params ?? {};

  const searchParams = new URLSearchParams({
    page: String(page),
    pageSize: String(pageSize),
    sort,
  });

  if (search) searchParams.set("search", search);
  if (regiao) searchParams.set("regiao", regiao);
  if (estado) searchParams.set("estado", estado);
  if (tipoLead) searchParams.set("tipoLead", tipoLead);
  if (consultor) searchParams.set("consultor", consultor);
  const groupBy: string[] = [];
  if (groupByEmpresa) groupBy.push("empresa");
  if (groupByChassi) groupBy.push("chassi");
  if (groupBy.length) searchParams.set("groupBy", groupBy.join(","));

  const response = await fetch(
    `/api/lead-service-orders?${searchParams.toString()}`,
    { cache: "no-store" },
  );
  ensureAuthenticated(response);
  if (!response.ok) {
    throw new Error("Falha ao buscar OS do Supabase");
  }
  const data = (await response.json()) as LeadServiceOrdersPageResponse;
  return data;
}

export async function updateLeadServiceOrder(
  orderId: number,
  input: UpdateLeadServiceOrderInput,
) {
  const response = await fetch(
    `/api/lead-service-orders/${encodeURIComponent(String(orderId))}`,
    {
      method: "PATCH",
      headers: { "content-type": "application/json" },
      body: JSON.stringify({
        parts_value: input.partsValue,
        labor_value: input.laborValue,
        note: input.note ?? "",
      }),
    },
  );
  ensureAuthenticated(response);
  if (!response.ok) {
    const payload = await response.json().catch(() => null);
    throw new Error(payload?.message ?? "Falha ao atualizar OS");
  }
  const data = (await response.json()) as UpdateLeadServiceOrderResponse;
  return data.item;
}

export async function fetchTicketOptions() {
  const response = await fetch("/api/tickets/options", { cache: "no-store" });
  ensureAuthenticated(response);
  if (!response.ok) {
    throw new Error("Falha ao buscar opВリes de tickets");
  }
  return (await response.json()) as TicketFilterOptions;
}

export type MetricsApiResponse = {
  success: true;
  range: MetricsRange;
  items: UserActionMetricsRow[];
  daily: DailyActionMetricsRow[];
  users: UserIdentity[];
  events: UserActionEventRow[];
};

type FetchMetricsOptions = {
  includeUsers?: boolean;
};

async function fetchMetrics(
  path: string,
  range: MetricsRange,
  options?: FetchMetricsOptions,
) {
  const includeUsers = options?.includeUsers ?? true;
  const searchParams = new URLSearchParams({
    range: String(range),
    includeUsers: includeUsers ? "1" : "0",
  });
  const response = await fetch(`${path}?${searchParams.toString()}`, {
    cache: "no-store",
  });
  ensureAuthenticated(response);
  if (!response.ok) {
    throw new Error("Falha ao buscar mÇ¸tricas");
  }
  return (await response.json()) as MetricsApiResponse;
}

export async function fetchLeadMetrics(
  range: MetricsRange,
  options?: FetchMetricsOptions,
) {
  return fetchMetrics("/api/metrics/leads", range, options);
}

export async function fetchLeadById(leadId: number): Promise<Lead> {
  const response = await fetch(`/api/leads/${encodeURIComponent(String(leadId))}`, {
    cache: "no-store",
  });
  ensureAuthenticated(response);
  if (!response.ok) {
    throw new Error("Falha ao buscar lead");
  }
  const data = (await response.json()) as LeadResponse;
  return data.item;
}

export async function fetchTicketMetrics(
  range: MetricsRange,
  options?: FetchMetricsOptions,
) {
  return fetchMetrics("/api/metrics/tickets", range, options);
}



================================================
FILE: src/lib/currentUser.ts
================================================
import "server-only";

import { createSupabaseServerClient } from "@/lib/supabase/server";
import { isUuid } from "@/lib/events";

export type CurrentUser = {
  id: string;
  email: string;
  name: string;
};

const pickName = (user: { email?: string | null; user_metadata?: any }) => {
  const metadata = user.user_metadata ?? {};
  const fromMetadata =
    metadata.full_name ??
    metadata.name ??
    metadata.user_name ??
    metadata.username ??
    null;
  return (
    (typeof fromMetadata === "string" ? fromMetadata.trim() : "") ||
    (user.email?.trim() ?? "") ||
    "Usuǭrio"
  );
};

export async function getCurrentUser(): Promise<CurrentUser | null> {
  const supabase = await createSupabaseServerClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (user?.id) {
    return {
      id: user.id,
      email: user.email ?? "",
      name: pickName(user),
    };
  }

  const mockId = process.env.MOCK_USER_ID?.trim();
  const mockEmail = process.env.MOCK_USER_EMAIL?.trim();
  const mockName = process.env.MOCK_USER_NAME?.trim();

  if (mockId && isUuid(mockId)) {
    return {
      id: mockId,
      email: mockEmail ?? "mock@example.com",
      name: mockName ?? "Mock User",
    };
  }

  return null;
}

export async function requireCurrentUser(): Promise<CurrentUser> {
  const user = await getCurrentUser();
  if (!user) {
    throw Object.assign(new Error("auth_required"), { status: 401 });
  }
  return user;
}



================================================
FILE: src/lib/domain.ts
================================================
export type TicketStatus = "aberto" | "fechado" | "desconhecido";

export type TimeRange = "today" | "week" | "month" | "year";

export type LeadCategory =
  | "preventiva"
  | "garantia_basica"
  | "garantia_estendida"
  | "reforma_componentes"
  | "lamina"
  | "dentes"
  | "rodante"
  | "disponibilidade"
  | "reconexao"
  | "transferencia_aor"
  | "pops"
  | "outros"
  | "indefinido";

export type Lead = {
  id: number;
  status: string | null;
  regional: string | null;
  estado: string | null;
  city: string | null;
  consultor: string | null;
  nomeContato: string | null;
  createdBy: string | null;
  telefone: string | null;
  chassi: string | null;
  modelName: string | null;
  clienteBaseEnriquecida: string | null;
  horimetroAtualMachineList: number | null;
  lastCalledGroup: string | null;
  leadPreventiva: string | null;
  leadGarantiaBasica: string | null;
  leadGarantiaEstendida: string | null;
  leadReformaDeComponentes: string | null;
  leadLamina: string | null;
  leadDentes: string | null;
  leadRodante: string | null;
  leadDisponibilidade: string | null;
  leadReconexao: string | null;
  leadTransferenciaDeAor: string | null;
  leadPops: string | null;
  leadOutros: string | null;
  importedAt: string;
  updatedAt: string | null;
  tipoLead: LeadCategory;
  tipoLeadList: LeadCategory[];
  ticketId?: string;
};

export type Ticket = {
  id: string;
  number: string;
  title: string;
  status: TicketStatus;
  statusCode: number | null;
  serialNumber: string | null;
  advisorName: string | null;
  customerName: string | null;
  customerOrganization: string | null;
  teamName: string | null;
  updatedAt: string | null;
  createdAt: string | null;
  url: string | null;
};

export type LeadServiceOrder = {
  id: number;
  leadId: number;
  osNumber: string;
  partsValue: number;
  laborValue: number;
  note: string | null;
  createdAt: string;
  updatedAt: string;
  lead: Lead;
};



================================================
FILE: src/lib/events.ts
================================================
export type LeadEventAction =
  | "register_contact"
  | "assign"
  | "close_without_os"
  | "close_with_os"
  | "discard"
  | "convert_to_ticket";

export type TicketEventAction =
  | "view"
  | "add_note"
  | "add_tags"
  | "remove_tags"
  | "close"
  | "reopen"
  | "assign"
  | "external_update_detected";

export type ActionRole = "user" | "admin";

export type EventPayload = {
  reason?: string;
  note?: string;
  tags?: string[];
  assignee?: string;
  method?: string;
  os?: string;
  valor?: string;
  parts_value?: string | number;
  labor_value?: string | number;
  service_order_id?: string | number;
  changed_fields?: Record<string, string>;
  [key: string]: unknown;
};

export type ActionDefinition<Action extends string> = {
  id: Action;
  label: string;
  description: string;
  requiresNote?: boolean;
  requiresReason?: boolean;
  requiresTags?: boolean;
  requiresAssignee?: boolean;
  requiresOs?: boolean;
  requiresValor?: boolean;
  requiresPartsValue?: boolean;
  requiresLaborValue?: boolean;
  requiresChangedFields?: boolean;
  hideNote?: boolean;
  payloadDefaults?: Partial<EventPayload>;
  allowedStatuses?: string[];
  allowedRoles?: ActionRole[];
  disabled?: boolean;
};

export const LEAD_ACTION_DEFINITIONS: ActionDefinition<LeadEventAction>[] = [
  {
    id: "register_contact",
    label: "Registrar contato",
    description: "{actor} realizou um contato com o cliente.",
    requiresNote: true,
    allowedStatuses: ["atribuido", "em contato"],
    allowedRoles: ["user", "admin"],
  },
  {
    id: "assign",
    label: "Atribuir",
    description: "{actor} atribuiu esse lead.",
    requiresAssignee: true,
    allowedStatuses: ["novo", "atribuido"],
    allowedRoles: ["user", "admin"],
  },
  {
    id: "discard",
    label: "Descartar",
    description: "{actor} descartou esse lead.",
    requiresReason: true,
    allowedStatuses: ["novo"],
    allowedRoles: ["user", "admin"],
  },
  {
    id: "close_without_os",
    label: "Fechar (sem OS)",
    description: "{actor} fechou esse lead sem OS.",
    requiresReason: true,
    allowedStatuses: ["atribuido", "em contato"],
    allowedRoles: ["user", "admin"],
  },
  {
    id: "close_with_os",
    label: "Fechar (com OS)",
    description: "{actor} fechou esse lead com a OS {os}.",
    requiresOs: true,
    requiresPartsValue: true,
    requiresLaborValue: true,
    allowedStatuses: ["atribuido", "em contato"],
    allowedRoles: ["user", "admin"],
  },
  {
    id: "convert_to_ticket",
    label: "Converter em ticket",
    description: "{actor} marcou esse lead para conversao em ticket.",
    payloadDefaults: { method: "manual" },
    allowedStatuses: ["*"],
    allowedRoles: [],
  },
];

export const TICKET_ACTION_DEFINITIONS: ActionDefinition<TicketEventAction>[] =
  [
    {
      id: "view",
      label: "Visualizar",
      description: "Marca que vocǻ visualizou/avaliou o ticket.",
      allowedStatuses: ["*"],
      allowedRoles: ["user", "admin"],
    },
    {
      id: "add_note",
      label: "Adicionar nota",
      description: "Registra uma observaǧǜo interna.",
      allowedStatuses: ["*"],
      allowedRoles: ["user", "admin"],
    },
    {
      id: "add_tags",
      label: "Adicionar tags",
      description: "Adiciona tags ao ticket (exige pelo menos 1 tag).",
      allowedStatuses: ["*"],
      allowedRoles: ["user", "admin"],
      requiresTags: true,
    },
    {
      id: "remove_tags",
      label: "Remover tags",
      description: "Remove tags do ticket (exige pelo menos 1 tag).",
      allowedStatuses: ["*"],
      allowedRoles: ["user", "admin"],
      requiresTags: true,
    },
    {
      id: "close",
      label: "Fechar",
      description: "Registra fechamento do ticket.",
      allowedStatuses: ["*"],
      allowedRoles: ["user", "admin"],
    },
    {
      id: "reopen",
      label: "Reabrir",
      description: "Registra reabertura do ticket.",
      allowedStatuses: ["*"],
      allowedRoles: ["user", "admin"],
    },
    {
      id: "assign",
      label: "Atribuir",
      description: "Atribui o ticket a um responsǭvel.",
      allowedStatuses: ["*"],
      allowedRoles: ["user", "admin"],
      requiresAssignee: true,
    },
    {
      id: "external_update_detected",
      label: "Atualizaǧǜo externa detectada",
      description: "Marca que houve mudanǧa fora do middleware.",
      allowedStatuses: ["*"],
      allowedRoles: ["user", "admin"],
    },
  ];

export type LeadEventInput = {
  leadId: number;
  action: LeadEventAction;
  payload: EventPayload;
};

export type TicketEventInput = {
  ticketId: string;
  action: TicketEventAction;
  payload: EventPayload;
};

export type ValidationResult<T> =
  | { ok: true; value: T }
  | { ok: false; error: string; details?: Record<string, unknown> };

export const MAX_NOTE_CHARS = 2000;
export const MAX_REASON_CHARS = 500;
export const MAX_TAG_CHARS = 50;
export const MAX_TAGS = 20;

const isPlainObject = (value: unknown): value is Record<string, unknown> => {
  if (!value || typeof value !== "object") return false;
  return Object.getPrototypeOf(value) === Object.prototype;
};

const coercePayload = (value: unknown): EventPayload => {
  if (!isPlainObject(value)) return {};
  return value as EventPayload;
};

export const isUuid = (value: string) =>
  /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(
    value.trim()
  );

const normalizeText = (value: unknown): string | undefined => {
  if (typeof value !== "string") return undefined;
  const trimmed = value.trim();
  return trimmed ? trimmed : undefined;
};

const normalizeTags = (value: unknown): string[] | undefined => {
  if (!Array.isArray(value)) return undefined;
  const tags = value
    .map((item) => (typeof item === "string" ? item.trim() : ""))
    .filter(Boolean)
    .slice(0, MAX_TAGS)
    .map((tag) => tag.slice(0, MAX_TAG_CHARS));
  return tags.length ? tags : undefined;
};

const parseMoney = (value: unknown): number | null => {
  if (typeof value === "number") {
    return Number.isFinite(value) ? value : null;
  }
  if (typeof value !== "string") return null;
  const trimmed = value.trim();
  if (!trimmed) return null;
  const normalized = trimmed.replace(/[^\d,.-]/g, "");
  if (!normalized) return null;
  let numeric = normalized;
  if (numeric.includes(",") && numeric.includes(".")) {
    numeric = numeric.replace(/\./g, "").replace(",", ".");
  } else if (numeric.includes(",")) {
    numeric = numeric.replace(",", ".");
  }
  const parsed = Number.parseFloat(numeric);
  return Number.isFinite(parsed) ? parsed : null;
};

const normalizeAmount = (value: unknown): number | undefined => {
  const parsed = parseMoney(value);
  if (parsed === null) return undefined;
  return parsed;
};

const normalizeId = (value: unknown): number | undefined => {
  if (typeof value === "number") {
    return Number.isFinite(value) && Number.isInteger(value) ? value : undefined;
  }
  if (typeof value !== "string") return undefined;
  const trimmed = value.trim();
  if (!trimmed) return undefined;
  const parsed = Number.parseInt(trimmed, 10);
  if (!Number.isFinite(parsed) || !Number.isInteger(parsed) || parsed <= 0) {
    return undefined;
  }
  return parsed;
};

const normalizeChangedFields = (
  value: unknown
): Record<string, string> | undefined => {
  if (!isPlainObject(value)) return undefined;
  const entries = Object.entries(value)
    .map(
      ([k, v]) =>
        [
          String(k).trim(),
          typeof v === "string" ? v.trim() : String(v),
        ] as const
    )
    .filter(([k, v]) => Boolean(k) && Boolean(v));
  if (!entries.length) return undefined;
  return Object.fromEntries(entries);
};

const applyActionDefaults = <A extends string>(
  defs: ActionDefinition<A>[],
  action: A,
  payload: EventPayload
): EventPayload => {
  const def = defs.find((item) => item.id === action);
  if (!def?.payloadDefaults) return payload;
  return { ...def.payloadDefaults, ...payload };
};

const validatePayloadCommon = (
  payload: EventPayload
): ValidationResult<EventPayload> => {
  const note = normalizeText(payload.note);
  if (note && note.length > MAX_NOTE_CHARS) {
    return {
      ok: false,
      error: `Campo note deve ter atǻ ${MAX_NOTE_CHARS} caracteres.`,
    };
  }
  const reason = normalizeText(payload.reason);
  if (reason && reason.length > MAX_REASON_CHARS) {
    return {
      ok: false,
      error: `Campo reason deve ter atǻ ${MAX_REASON_CHARS} caracteres.`,
    };
  }

  const tags = normalizeTags(payload.tags);
  const changed_fields = normalizeChangedFields(payload.changed_fields);

  const next: EventPayload = {
    ...payload,
    note,
    reason,
    tags,
    changed_fields,
  };

  return { ok: true, value: next };
};

export function validateLeadEventInput(
  raw: unknown
): ValidationResult<LeadEventInput> {
  if (!isPlainObject(raw)) {
    return { ok: false, error: "Body invǭlido (esperado objeto JSON)." };
  }

  const leadIdRaw = (raw as any).leadId;
  const actionRaw = (raw as any).action;
  const payload = applyActionDefaults(
    LEAD_ACTION_DEFINITIONS,
    actionRaw as LeadEventAction,
    coercePayload((raw as any).payload)
  );

  const leadId = typeof leadIdRaw === "number" ? leadIdRaw : Number(leadIdRaw);
  if (!Number.isFinite(leadId) || !Number.isInteger(leadId) || leadId <= 0) {
    return {
      ok: false,
      error: "leadId invǭlido (esperado bigint/id numǻrico).",
    };
  }

  const action = normalizeText(actionRaw);
  if (!action) return { ok: false, error: "action ǻ obrigatǭrio." };
  const allowed = new Set(LEAD_ACTION_DEFINITIONS.map((d) => d.id));
  if (!allowed.has(action as LeadEventAction)) {
    return { ok: false, error: "action nǜo permitido para lead." };
  }

  const common = validatePayloadCommon(payload);
  if (!common.ok) return common;

  const def = LEAD_ACTION_DEFINITIONS.find((d) => d.id === action)!;
  if (def.requiresNote && !common.value.note) {
    return {
      ok: false,
      error:
        "Descricao do contato (payload.note) e obrigatoria para register_contact.",
    };
  }
  if (def.requiresReason && !common.value.reason) {
    return {
      ok: false,
      error: "Motivo (payload.reason) ǻ obrigatǭrio para discard.",
    };
  }
  if (def.requiresAssignee && !normalizeText(common.value.assignee)) {
    return {
      ok: false,
      error: "Responsǭvel (payload.assignee) ǻ obrigatǭrio para assign.",
    };
  }
  if (def.requiresOs && !normalizeText(common.value.os)) {
    return {
      ok: false,
      error: "OS (payload.os) e obrigatoria para essa acao.",
    };
  }
  const partsValue = normalizeAmount(common.value.parts_value);
  if (def.requiresPartsValue && partsValue === undefined) {
    return {
      ok: false,
      error: "Valor de pecas (payload.parts_value) e obrigatorio para essa acao.",
    };
  }
  if (def.requiresPartsValue && partsValue !== undefined && partsValue < 0) {
    return {
      ok: false,
      error: "Valor de pecas (payload.parts_value) deve ser >= 0.",
    };
  }
  const laborValue = normalizeAmount(common.value.labor_value);
  if (def.requiresLaborValue && laborValue === undefined) {
    return {
      ok: false,
      error:
        "Valor de mao de obra (payload.labor_value) e obrigatorio para essa acao.",
    };
  }
  if (def.requiresLaborValue && laborValue !== undefined && laborValue < 0) {
    return {
      ok: false,
      error: "Valor de mao de obra (payload.labor_value) deve ser >= 0.",
    };
  }
  if (def.requiresValor && !normalizeText(common.value.valor)) {
    return {
      ok: false,
      error: "Valor (payload.valor) e obrigatorio para essa acao.",
    };
  }
  if (
    def.requiresChangedFields &&
    !normalizeChangedFields(common.value.changed_fields)
  ) {
    return {
      ok: false,
      error:
        "Campos alterados (payload.changed_fields) ǻ obrigatǭrio para update_field.",
    };
  }

  const normalized: EventPayload = {
    ...common.value,
    assignee: normalizeText(common.value.assignee),
    method: normalizeText(common.value.method),
    os: normalizeText(common.value.os),
    valor: normalizeText(common.value.valor),
    parts_value: partsValue,
    labor_value: laborValue,
    service_order_id: normalizeId(common.value.service_order_id),
    changed_fields: normalizeChangedFields(common.value.changed_fields),
  };

  return {
    ok: true,
    value: {
      leadId,
      action: action as LeadEventAction,
      payload: normalized,
    },
  };
}

export function validateTicketEventInput(
  raw: unknown
): ValidationResult<TicketEventInput> {
  if (!isPlainObject(raw)) {
    return { ok: false, error: "Body invǭlido (esperado objeto JSON)." };
  }

  const ticketIdRaw = (raw as any).ticketId;
  const actionRaw = (raw as any).action;
  const payload = applyActionDefaults(
    TICKET_ACTION_DEFINITIONS,
    actionRaw as TicketEventAction,
    coercePayload((raw as any).payload)
  );

  const ticketId = normalizeText(ticketIdRaw);
  if (!ticketId) return { ok: false, error: "ticketId ǻ obrigatǭrio." };
  if (!isUuid(ticketId)) {
    return { ok: false, error: "ticketId invǭlido (esperado uuid)." };
  }

  const action = normalizeText(actionRaw);
  if (!action) return { ok: false, error: "action ǻ obrigatǭrio." };
  const allowed = new Set(TICKET_ACTION_DEFINITIONS.map((d) => d.id));
  if (!allowed.has(action as TicketEventAction)) {
    return { ok: false, error: "action nǜo permitido para ticket." };
  }

  const common = validatePayloadCommon(payload);
  if (!common.ok) return common;

  const def = TICKET_ACTION_DEFINITIONS.find((d) => d.id === action)!;
  if (def.requiresTags && !normalizeTags(common.value.tags)) {
    return {
      ok: false,
      error: "Tags (payload.tags) ǻ obrigatǭrio para essa aǧǜo.",
    };
  }
  if (def.requiresAssignee && !normalizeText(common.value.assignee)) {
    return {
      ok: false,
      error: "Responsǭvel (payload.assignee) ǻ obrigatǭrio para assign.",
    };
  }

  const normalized: EventPayload = {
    ...common.value,
    tags: normalizeTags(common.value.tags),
    assignee: normalizeText(common.value.assignee),
  };

  return {
    ok: true,
    value: {
      ticketId,
      action: action as TicketEventAction,
      payload: normalized,
    },
  };
}



================================================
FILE: src/lib/expertconnect.ts
================================================
type ExpertConnectConfig = {
  apiBaseUrl: string;
  companyId: string;
  subscriptionKey: string;
  oauthTokenUrl: string;
  oauthClientId: string;
  oauthClientSecret: string;
  oauthScope?: string;
  fieldsInclude?: string;
};

const readEnv = (key: string) => {
  const value = process.env[key];
  return value && value.trim().length ? value.trim() : null;
};

export const getExpertConnectConfig = (): ExpertConnectConfig => {
  const apiBaseUrl =
    readEnv("EXPERTCONNECT_API_BASE_URL") ??
    "https://service-api.expertconnect.deere.com";
  const companyId = readEnv("EXPERTCONNECT_COMPANY_ID");
  const subscriptionKey = readEnv("EXPERTCONNECT_SUBSCRIPTION_KEY");
  const oauthTokenUrl = readEnv("EXPERTCONNECT_OAUTH_TOKEN_URL");
  const oauthClientId = readEnv("EXPERTCONNECT_OAUTH_CLIENT_ID");
  const oauthClientSecret = readEnv("EXPERTCONNECT_OAUTH_CLIENT_SECRET");
  const oauthScope = readEnv("EXPERTCONNECT_OAUTH_SCOPE") ?? undefined;
  // const fieldsInclude =
  //   readEnv("EXPERTCONNECT_FIELDS_INCLUDE") ??
  //   "webhooks,watchers,fields";

  const missing: string[] = [];
  if (!companyId) missing.push("EXPERTCONNECT_COMPANY_ID");
  if (!subscriptionKey) missing.push("EXPERTCONNECT_SUBSCRIPTION_KEY");
  if (!oauthTokenUrl) missing.push("EXPERTCONNECT_OAUTH_TOKEN_URL");
  if (!oauthClientId) missing.push("EXPERTCONNECT_OAUTH_CLIENT_ID");
  if (!oauthClientSecret) missing.push("EXPERTCONNECT_OAUTH_CLIENT_SECRET");

  if (missing.length) {
    throw new Error(`Missing ExpertConnect env vars: ${missing.join(", ")}`);
  }

  return {
    apiBaseUrl,
    companyId: companyId!,
    subscriptionKey: subscriptionKey!,
    oauthTokenUrl: oauthTokenUrl!,
    oauthClientId: oauthClientId!,
    oauthClientSecret: oauthClientSecret!,
    oauthScope,
    // fieldsInclude,
  };
};

type OAuthClientCredentialsResponse = {
  access_token: string;
  token_type?: string;
  expires_in?: number;
};

type TokenCache = {
  accessToken: string;
  expiresAtMs: number;
};

declare global {
  // eslint-disable-next-line no-var
  var __expertConnectTokenCache: TokenCache | undefined;
}

const getTokenCache = () => globalThis.__expertConnectTokenCache ?? null;
const setTokenCache = (cache: TokenCache | null) => {
  if (cache) globalThis.__expertConnectTokenCache = cache;
  else globalThis.__expertConnectTokenCache = undefined;
};

export const getExpertConnectAccessToken = async (
  config: ExpertConnectConfig
): Promise<string> => {
  const cached = getTokenCache();
  if (cached && Date.now() < cached.expiresAtMs) {
    return cached.accessToken;
  }

  const form = new URLSearchParams();
  form.set("grant_type", "client_credentials");
  form.set("client_id", config.oauthClientId);
  form.set("client_secret", config.oauthClientSecret);
  if (config.oauthScope) form.set("scope", config.oauthScope);

  const resp = await fetch(config.oauthTokenUrl, {
    method: "POST",
    headers: {
      Accept: "application/json",
      "Content-Type": "application/x-www-form-urlencoded",
      "Cache-Control": "no-cache",
    },
    body: form.toString(),
    cache: "no-store",
  });

  if (!resp.ok) {
    const text = await resp.text().catch(() => "");
    throw new Error(
      `ExpertConnect OAuth token request failed (${resp.status}): ${text.slice(
        0,
        300
      )}`
    );
  }

  const tokenJson = (await resp.json()) as OAuthClientCredentialsResponse;
  if (!tokenJson?.access_token) {
    throw new Error("ExpertConnect OAuth token response missing access_token");
  }

  const expiresInSec =
    typeof tokenJson.expires_in === "number" && tokenJson.expires_in > 0
      ? tokenJson.expires_in
      : 300;
  const expiresAtMs = Date.now() + Math.max(0, expiresInSec - 30) * 1000;
  setTokenCache({ accessToken: tokenJson.access_token, expiresAtMs });
  return tokenJson.access_token;
};

export const fetchExpertConnectTicketById = async (
  ticketId: string
): Promise<unknown> => {
  const config = getExpertConnectConfig();
  const accessToken = await getExpertConnectAccessToken(config);

  const url = new URL(
    `/api/v1/companies/${encodeURIComponent(
      config.companyId
    )}/tickets/${encodeURIComponent(ticketId)}`,
    config.apiBaseUrl
  );
  if (config.fieldsInclude) {
    url.searchParams.set("Fields.Include", config.fieldsInclude);
  }

  const resp = await fetch(url.toString(), {
    method: "GET",
    headers: {
      Authorization: `Bearer ${accessToken}`,
      "X-Subscription-Key": config.subscriptionKey,
      "Cache-Control": "no-cache",
      Accept: "application/json",
    },
    cache: "no-store",
  });

  const contentType = resp.headers.get("content-type") ?? "";
  const isJson = contentType.includes("application/json");
  const payload = isJson
    ? await resp.json().catch(() => null)
    : await resp.text().catch(() => null);

  if (!resp.ok) {
    const error = new Error(
      `ExpertConnect ticket fetch failed (${resp.status})`
    );
    (error as any).status = resp.status;
    (error as any).payload = payload;
    throw error;
  }

  if (payload && typeof payload === "object" && "data" in payload) {
    return (payload as { data: unknown }).data;
  }
  return payload;
};



================================================
FILE: src/lib/filters.ts
================================================
import { LeadCategory } from "./domain";

export const REGIOES = ["R1", "R2", "R3"] as const;

export const ESTADOS = [
  "AL",
  "BA",
  "CE",
  "PB",
  "PE",
  "PI",
  "RN",
  "SE",
] as const;

export type Regiao = (typeof REGIOES)[number];
export type Estado = (typeof ESTADOS)[number];

export type SortOrder = "recentes" | "antigos";

export type FiltersState = {
  search: string;
  regiao: Regiao | "";
  estado: Estado | "";
  tipoLead: LeadCategory | "";
  status: string[];
  sort: SortOrder;
  groupByEmpresa?: boolean;
  groupByChassi?: boolean;
};

export const INITIAL_FILTERS: FiltersState = {
  search: "",
  regiao: "",
  estado: "",
  tipoLead: "",
  status: ["atribuido", "em contato"],
  sort: "recentes",
  groupByEmpresa: false,
  groupByChassi: false,
};

export const LEAD_STATUS_OPTIONS = [
  { value: "atribuido", label: "atribuido" },
  { value: "descartado", label: "descartado" },
  { value: "em contato", label: "em contato" },
  { value: "fechado_com_os", label: "fechado (com OS)" },
  { value: "fechado_sem_os", label: "fechado (sem OS)" },
  { value: "novo", label: "novo" },
] as const;

export const LEAD_STATUS_LABELS = LEAD_STATUS_OPTIONS.reduce((acc, item) => {
  acc[item.value] = item.label;
  return acc;
}, {} as Record<string, string>);

export const REGIAO_FILTER_QUERIES: Record<Regiao, string> = {
  R1: "REGIONAL = 'R1'",
  R2: "REGIONAL = 'R2'",
  R3: "REGIONAL = 'R3'",
};

export const ESTADO_FILTER_QUERIES: Record<Estado, string> = {
  AL: "ESTADO = 'AL'",
  BA: "ESTADO = 'BA'",
  CE: "ESTADO = 'CE'",
  PB: "ESTADO = 'PB'",
  PE: "ESTADO = 'PE'",
  PI: "ESTADO = 'PI'",
  RN: "ESTADO = 'RN'",
  SE: "ESTADO = 'SE'",
};

// Query "global" para todas as regioes, se precisar
export const ALL_REGIOES_QUERY = "REGIONAL IN ('R1', 'R2', 'R3')";

// Exemplo de helper para montar WHERE dinamico
export function buildWhereByRegiaoEstado(
  regiao?: Regiao,
  estado?: Estado
): string {
  const clauses: string[] = [];
  if (regiao) {
    clauses.push(`REGIONAL = '${regiao}'`);
  }
  if (estado) {
    clauses.push(`ESTADO = '${estado}'`);
  }
  if (!clauses.length) return "1 = 1";
  return clauses.join(" AND ");
}

export const LEAD_TYPES = [
  "preventiva",
  "garantia_basica",
  "garantia_estendida",
  "reforma_componentes",
  "lamina",
  "dentes",
  "rodante",
  "disponibilidade",
  "reconexao",
  "transferencia_aor",
  "pops",
  "outros",
  "indefinido",
] as const satisfies LeadCategory[];

/**
 * Consultas de filtro padrao:
 *
 * Regiao:
 * - Todas as regioes: REGIONAL IN ('R1', 'R2', 'R3')
 * - R1: REGIONAL = 'R1'
 * - R2: REGIONAL = 'R2'
 * - R3: REGIONAL = 'R3'
 *
 * Estado:
 * - AL: ESTADO = 'AL'
 * - BA: ESTADO = 'BA'
 * - CE: ESTADO = 'CE'
 * - PB: ESTADO = 'PB'
 * - PE: ESTADO = 'PE'
 * - PI: ESTADO = 'PI'
 * - RN: ESTADO = 'RN'
 * - SE: ESTADO = 'SE'
 */



================================================
FILE: src/lib/filterStorage.ts
================================================
import { FiltersState, INITIAL_FILTERS, SortOrder } from "./filters";
import { INITIAL_TICKET_FILTERS, TicketFiltersState } from "./ticketFilters";

const isBrowser = typeof window !== "undefined";

export const FILTER_STORAGE_KEYS = {
  home: "filters:home",
  dashboardLeads: "filters:dashboard:leads",
  dashboardServiceOrders: "filters:dashboard:service-orders",
  dashboardTickets: "filters:dashboard:tickets",
};

function safeParse(value: string | null): unknown {
  if (!value) {
    return null;
  }
  try {
    return JSON.parse(value);
  } catch {
    return null;
  }
}

function asString(value: unknown, fallback: string): string {
  return typeof value === "string" ? value : fallback;
}

function asBoolean(value: unknown, fallback: boolean): boolean {
  return typeof value === "boolean" ? value : fallback;
}

function asStringArray(value: unknown, fallback: string[]): string[] {
  if (!Array.isArray(value)) {
    return fallback;
  }
  return value.every((item) => typeof item === "string") ? value : fallback;
}

function asSortOrder(value: unknown, fallback: SortOrder): SortOrder {
  return value === "recentes" || value === "antigos" ? value : fallback;
}

export function loadLeadFilters(
  key: string,
  fallback: FiltersState = INITIAL_FILTERS,
): FiltersState {
  if (!isBrowser) {
    return fallback;
  }
  const parsed = safeParse(window.localStorage.getItem(key));
  if (!parsed || typeof parsed !== "object") {
    return fallback;
  }
  const data = parsed as Partial<FiltersState>;
  return {
    search: asString(data.search, fallback.search),
    regiao: asString(data.regiao, fallback.regiao) as FiltersState["regiao"],
    estado: asString(data.estado, fallback.estado) as FiltersState["estado"],
    tipoLead: asString(
      data.tipoLead,
      fallback.tipoLead,
    ) as FiltersState["tipoLead"],
    status: asStringArray(data.status, fallback.status),
    sort: asSortOrder(data.sort, fallback.sort),
    groupByEmpresa: asBoolean(
      data.groupByEmpresa,
      fallback.groupByEmpresa ?? false,
    ),
    groupByChassi: asBoolean(
      data.groupByChassi,
      fallback.groupByChassi ?? false,
    ),
  };
}

export function loadTicketFilters(
  key: string,
  fallback: TicketFiltersState = INITIAL_TICKET_FILTERS,
): TicketFiltersState {
  if (!isBrowser) {
    return fallback;
  }
  const parsed = safeParse(window.localStorage.getItem(key));
  if (!parsed || typeof parsed !== "object") {
    return fallback;
  }
  const data = parsed as Partial<TicketFiltersState>;
  return {
    search: asString(data.search, fallback.search),
    status: asString(
      data.status,
      fallback.status,
    ) as TicketFiltersState["status"],
    sort: asSortOrder(data.sort, fallback.sort),
    groupByEmpresa: asBoolean(data.groupByEmpresa, fallback.groupByEmpresa),
    groupByChassi: asBoolean(data.groupByChassi, fallback.groupByChassi),
    consultor: asString(data.consultor, fallback.consultor),
    cliente: asString(data.cliente, fallback.cliente),
    equipe: asString(data.equipe, fallback.equipe),
  };
}

export function saveFilters(key: string, value: unknown): void {
  if (!isBrowser) {
    return;
  }
  try {
    window.localStorage.setItem(key, JSON.stringify(value));
  } catch {
    // Ignore storage failures (private mode, quota, etc).
  }
}



================================================
FILE: src/lib/format.ts
================================================
const dateTimeFormatter = new Intl.DateTimeFormat("pt-BR", {
  day: "2-digit",
  month: "2-digit",
  year: "numeric",
  hour: "2-digit",
  minute: "2-digit",
});

export const formatDateTimePtBR = (
  value: string | null | undefined,
  fallback = "N/A",
) => {
  if (!value) return fallback;
  const date = new Date(value);
  if (Number.isNaN(date.getTime())) return fallback;
  return dateTimeFormatter.format(date);
};

export const safeText = (
  value: string | number | null | undefined,
  fallback = "N/A",
) => {
  if (value === null || value === undefined) return fallback;
  const text = String(value).trim();
  return text.length ? text : fallback;
};

export const stringifyUnknown = (value: unknown, fallback = "N/A"): string => {
  if (value === null || value === undefined) return fallback;
  if (typeof value === "string") return safeText(value, fallback);
  if (typeof value === "number" || typeof value === "boolean") return String(value);
  if (Array.isArray(value)) {
    const parts = value
      .map((item) => stringifyUnknown(item, ""))
      .map((item) => item.trim())
      .filter(Boolean);
    return parts.length ? parts.join(", ") : fallback;
  }
  try {
    const json = JSON.stringify(value);
    return json && json !== "{}" ? json : fallback;
  } catch {
    return fallback;
  }
};



================================================
FILE: src/lib/leadData.ts
================================================
import type { Lead, LeadCategory } from "@/lib/domain";

export const LEAD_SELECT_COLUMNS = [
  "id",
  "status",
  "regional",
  "estado",
  "city",
  "consultor",
  "nome_contato",
  "telefone",
  "created_by",
  "chassi",
  "model_name",
  "cliente_base_enriquecida",
  "horimetro_atual_machine_list",
  "last_called_group",
  "lead_preventiva",
  "lead_garantia_basica",
  "lead_garantia_estendida",
  "lead_reforma_de_componentes",
  "lead_lamina",
  "lead_dentes",
  "lead_rodante",
  "lead_disponibilidade",
  "lead_reconexao",
  "lead_transferencia_de_aor",
  "lead_pops",
  "lead_outros",
  "imported_at",
  "updated_at",
].join(",");

export type LeadRow = {
  id: number;
  status: string | null;
  regional: string | null;
  estado: string | null;
  city: string | null;
  consultor: string | null;
  nome_contato: string | null;
  telefone: string | null;
  created_by?: string | null;
  chassi: string | null;
  model_name: string | null;
  cliente_base_enriquecida: string | null;
  horimetro_atual_machine_list: number | string | null;
  last_called_group: string | null;
  lead_preventiva: string | null;
  lead_garantia_basica: string | null;
  lead_garantia_estendida: string | null;
  lead_reforma_de_componentes: string | null;
  lead_lamina: string | null;
  lead_dentes: string | null;
  lead_rodante: string | null;
  lead_disponibilidade: string | null;
  lead_reconexao: string | null;
  lead_transferencia_de_aor: string | null;
  lead_pops: string | null;
  lead_outros: string | null;
  imported_at: string;
  updated_at: string | null;
};

export type LeadTypeColumn =
  | "lead_preventiva"
  | "lead_garantia_basica"
  | "lead_garantia_estendida"
  | "lead_reforma_de_componentes"
  | "lead_lamina"
  | "lead_dentes"
  | "lead_rodante"
  | "lead_disponibilidade"
  | "lead_reconexao"
  | "lead_transferencia_de_aor"
  | "lead_pops"
  | "lead_outros";

export const leadTypeOrder: { key: LeadTypeColumn; category: LeadCategory; label: string }[] =
  [
    { key: "lead_preventiva", category: "preventiva", label: "Preventiva" },
    { key: "lead_garantia_basica", category: "garantia_basica", label: "Garantia básica" },
    {
      key: "lead_garantia_estendida",
      category: "garantia_estendida",
      label: "Garantia estendida",
    },
    {
      key: "lead_reforma_de_componentes",
      category: "reforma_componentes",
      label: "Reforma de componentes",
    },
    { key: "lead_lamina", category: "lamina", label: "Lâmina" },
    { key: "lead_dentes", category: "dentes", label: "Dentes" },
    { key: "lead_rodante", category: "rodante", label: "Rodante" },
    { key: "lead_disponibilidade", category: "disponibilidade", label: "Disponibilidade" },
    { key: "lead_reconexao", category: "reconexao", label: "Reconexão" },
    {
      key: "lead_transferencia_de_aor",
      category: "transferencia_aor",
      label: "Transferência de AOR",
    },
    { key: "lead_pops", category: "pops", label: "POPs" },
    { key: "lead_outros", category: "outros", label: "Outros" },
  ];

export const isLeadCategory = (value: unknown): value is LeadCategory => {
  if (typeof value !== "string") return false;
  if (value === "indefinido") return true;
  return leadTypeOrder.some((entry) => entry.category === value);
};

const isYes = (value: string | null) =>
  value?.trim().toUpperCase() === "SIM";

export const mapLeadRow = (row: LeadRow): Lead => {
  const foundTypes = leadTypeOrder
    .filter((entry) => isYes(row[entry.key] as string | null))
    .map((entry) => entry.category);

  const tipoLeadList: LeadCategory[] = foundTypes.length ? foundTypes : ["indefinido"];
  const tipoLead: LeadCategory = tipoLeadList[0];

  const horimetro =
    row.horimetro_atual_machine_list === null
      ? null
      : Number(row.horimetro_atual_machine_list);

  const regionalRaw = row.regional?.trim() ?? null;
  const isControlRow =
    regionalRaw?.toLowerCase().startsWith("filtros aplicados:") ?? false;
  const regional = isControlRow ? null : regionalRaw;

  const estado = row.estado?.trim() ?? null;
  const status = row.status?.trim() ?? null;

  return {
    id: row.id,
    status,
    regional,
    estado,
    city: row.city,
    consultor: row.consultor,
    nomeContato: row.nome_contato,
    telefone: row.telefone,
    createdBy: row.created_by ?? null,
    chassi: row.chassi,
    modelName: row.model_name,
    clienteBaseEnriquecida: row.cliente_base_enriquecida,
    horimetroAtualMachineList: Number.isNaN(horimetro) ? null : horimetro,
    lastCalledGroup: row.last_called_group,
    leadPreventiva: row.lead_preventiva,
    leadGarantiaBasica: row.lead_garantia_basica,
    leadGarantiaEstendida: row.lead_garantia_estendida,
    leadReformaDeComponentes: row.lead_reforma_de_componentes,
    leadLamina: row.lead_lamina,
    leadDentes: row.lead_dentes,
    leadRodante: row.lead_rodante,
    leadDisponibilidade: row.lead_disponibilidade,
    leadReconexao: row.lead_reconexao,
    leadTransferenciaDeAor: row.lead_transferencia_de_aor,
    leadPops: row.lead_pops,
    leadOutros: row.lead_outros,
    importedAt: row.imported_at,
    updatedAt: row.updated_at ?? row.imported_at,
    tipoLead,
    tipoLeadList,
  };
};



================================================
FILE: src/lib/metrics.ts
================================================
import type { TimeRange } from "@/lib/domain";
import type { EventPayload } from "@/lib/events";

export type MetricsRange = TimeRange;

export type UserIdentity = {
  id: string;
  name?: string;
  email?: string;
};

export type UserActionMetricsRow = {
  actor_user_id: string;
  actor_email: string;
  actor_name: string;
  total_actions: number;
  unique_items: number;
  actions_breakdown: Record<string, number>;
};

export type UserActionEventRow = {
  actor_user_id: string;
  action: string;
  item_id: string;
  occurred_at: string;
  payload: EventPayload | null;
};

export type DailyActionMetricsRow = {
  actor_user_id: string;
  date: string;
  total_actions: number;
};

export const isMetricsRange = (value: string): value is MetricsRange =>
  value === "today" || value === "week" || value === "month" || value === "year";

const getUtcStartOfDay = (date: Date) =>
  new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate()));

export const getMetricsRangeStart = (
  range: MetricsRange,
  now: Date = new Date(),
): Date => {
  const start = getUtcStartOfDay(now);
  if (range === "today") return start;
  if (range === "week") {
    start.setUTCDate(start.getUTCDate() - 6);
    return start;
  }
  if (range === "month") {
    start.setUTCDate(start.getUTCDate() - 29);
    return start;
  }
  return new Date(Date.UTC(now.getUTCFullYear(), 0, 1));
};

export const getMetricsRangeEnd = (now: Date = new Date()): Date =>
  getUtcStartOfDay(now);

export const listMetricsRangeDays = (
  range: MetricsRange,
  now: Date = new Date(),
): string[] => {
  const start = getMetricsRangeStart(range, now);
  const end = getMetricsRangeEnd(now);
  const days: string[] = [];

  for (let cursor = new Date(start); cursor <= end; cursor.setUTCDate(cursor.getUTCDate() + 1)) {
    days.push(cursor.toISOString().slice(0, 10));
  }

  return days;
};



================================================
FILE: src/lib/metricsAggregation.ts
================================================
import "server-only";

import type {
  DailyActionMetricsRow,
  MetricsRange,
  UserActionMetricsRow,
} from "@/lib/metrics";
import { getMetricsRangeStart } from "@/lib/metrics";

export function rangeToStart(range: MetricsRange): Date {
  return getMetricsRangeStart(range);
}

type RawEventRow<ItemId extends string | number> = {
  actor_user_id: string | null;
  actor_email: string | null;
  actor_name: string | null;
  action: string | null;
  item_id: ItemId | null;
};

export function aggregateUserMetrics<ItemId extends string | number>(
  rows: RawEventRow<ItemId>[],
): UserActionMetricsRow[] {
  const byUser = new Map<
    string,
    {
      actor_user_id: string;
      actor_email: string;
      actor_name: string;
      total_actions: number;
      uniqueItems: Set<string>;
      actions_breakdown: Record<string, number>;
    }
  >();

  rows.forEach((row) => {
    const actorId = row.actor_user_id?.trim();
    const action = row.action?.trim();
    if (!actorId || !action) return;

    const key = actorId;
    const current = byUser.get(key) ?? {
      actor_user_id: actorId,
      actor_email: row.actor_email?.trim() ?? "",
      actor_name: row.actor_name?.trim() ?? "",
      total_actions: 0,
      uniqueItems: new Set<string>(),
      actions_breakdown: {},
    };

    current.total_actions += 1;
    current.actions_breakdown[action] = (current.actions_breakdown[action] ?? 0) + 1;

    if (row.item_id !== null && row.item_id !== undefined) {
      current.uniqueItems.add(String(row.item_id));
    }

    if (!current.actor_email && row.actor_email) current.actor_email = row.actor_email;
    if (!current.actor_name && row.actor_name) current.actor_name = row.actor_name;

    byUser.set(key, current);
  });

  return Array.from(byUser.values())
    .map((row) => ({
      actor_user_id: row.actor_user_id,
      actor_email: row.actor_email,
      actor_name: row.actor_name,
      total_actions: row.total_actions,
      unique_items: row.uniqueItems.size,
      actions_breakdown: row.actions_breakdown,
    }))
    .sort((a, b) => b.total_actions - a.total_actions);
}

type RawDailyRow = {
  actor_user_id: string | null;
  occurred_at: string | null;
};

export function aggregateDailyMetrics(rows: RawDailyRow[]): DailyActionMetricsRow[] {
  const byDay = new Map<string, Map<string, number>>();

  rows.forEach((row) => {
    const actorId = row.actor_user_id?.trim();
    if (!actorId) return;

    const occurredAt = row.occurred_at;
    if (!occurredAt) return;

    const date = new Date(occurredAt);
    if (Number.isNaN(date.getTime())) return;
    const dayKey = date.toISOString().slice(0, 10);

    const byActor = byDay.get(dayKey) ?? new Map<string, number>();
    byActor.set(actorId, (byActor.get(actorId) ?? 0) + 1);
    byDay.set(dayKey, byActor);
  });

  return Array.from(byDay.entries())
    .sort(([dateA], [dateB]) => dateA.localeCompare(dateB))
    .flatMap(([date, byActor]) =>
      Array.from(byActor.entries())
        .sort(([actorA], [actorB]) => actorA.localeCompare(actorB))
        .map(([actor_user_id, total_actions]) => ({
          actor_user_id,
          date,
          total_actions,
        }))
    );
}



================================================
FILE: src/lib/mockData.ts
================================================
import { Ticket } from "./domain";

const daysAgo = (days: number) =>
  new Date(Date.now() - days * 24 * 60 * 60 * 1000).toISOString();

export const mockTickets: Ticket[] = [
  {
    id: "ticket-1",
    number: "EXT-4321",
    title: "Ticket de exemplo (mock)",
    status: "aberto",
    statusCode: 1,
    serialNumber: "310L-ABC123",
    advisorName: "Consultor 1",
    customerName: "Cliente A",
    customerOrganization: "Organização Alfa",
    teamName: "Equipe Azul",
    updatedAt: daysAgo(1),
    createdAt: daysAgo(3),
    url: "https://example.com/tickets/EXT-4321",
  },
  {
    id: "ticket-2",
    number: "EXT-2310",
    title: "Ticket fechado (mock)",
    status: "fechado",
    statusCode: 2,
    serialNumber: "850J-FOO777",
    advisorName: "Consultora 2",
    customerName: "Cliente B",
    customerOrganization: "Organização Beta",
    teamName: "Equipe Verde",
    updatedAt: daysAgo(4),
    createdAt: daysAgo(5),
    url: "https://example.com/tickets/EXT-2310",
  },
  {
    id: "ticket-3",
    number: "EXT-9988",
    title: "Ticket sem chassi (mock)",
    status: "desconhecido",
    statusCode: null,
    serialNumber: null,
    advisorName: null,
    customerName: "Cliente C",
    customerOrganization: "Organização Gama",
    teamName: "Equipe Laranja",
    updatedAt: daysAgo(9),
    createdAt: daysAgo(10),
    url: "https://example.com/tickets/EXT-9988",
  },
];



================================================
FILE: src/lib/supabaseAdmin.ts
================================================
import "server-only";

import { createClient, type SupabaseClient } from "@supabase/supabase-js";

let supabaseAdmin: SupabaseClient | null = null;

export function getSupabaseAdminClient(): SupabaseClient {
  if (supabaseAdmin) return supabaseAdmin;

  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
  const serviceRoleKey = process.env.SUPABASE_SERVICE_ROLE_KEY;

  if (!supabaseUrl || !serviceRoleKey) {
    throw new Error(
      "Variǭveis NEXT_PUBLIC_SUPABASE_URL e SUPABASE_SERVICE_ROLE_KEY sǜo obrigatǭrias para Supabase Admin.",
    );
  }

  supabaseAdmin = createClient(supabaseUrl, serviceRoleKey, {
    auth: {
      persistSession: false,
      autoRefreshToken: false,
      detectSessionInUrl: false,
    },
  });

  return supabaseAdmin;
}




================================================
FILE: src/lib/supabaseClient.ts
================================================
import { createBrowserClient } from "@supabase/ssr";
import type { SupabaseClient } from "@supabase/supabase-js";

let browserClient: SupabaseClient | null = null;

export function createSupabaseBrowserClient(): SupabaseClient {
  if (browserClient) {
    return browserClient;
  }

  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
  const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;

  if (!supabaseUrl || !supabaseAnonKey) {
    throw new Error(
      "NEXT_PUBLIC_SUPABASE_URL and NEXT_PUBLIC_SUPABASE_ANON_KEY are required.",
    );
  }

  browserClient = createBrowserClient(supabaseUrl, supabaseAnonKey);
  return browserClient;
}



================================================
FILE: src/lib/supabaseServer.ts
================================================
import type { SupabaseClient } from "@supabase/supabase-js";
import { createSupabaseServerClient } from "./supabase/server";

export async function getSupabaseServerClient(): Promise<SupabaseClient> {
  return createSupabaseServerClient();
}



================================================
FILE: src/lib/supabaseUserClient.ts
================================================
import "server-only";

import type { SupabaseClient } from "@supabase/supabase-js";
import { createSupabaseServerClient } from "@/lib/supabase/server";

export async function getSupabaseUserClient(): Promise<SupabaseClient> {
  return createSupabaseServerClient();
}



================================================
FILE: src/lib/ticketDetails.ts
================================================
export type TicketDetailsApiError = {
  message: string;
  code: string;
  details?: unknown;
};

export type ExpertConnectTag =
  | string
  | {
      name?: string | null;
      subTags?: Array<string | { name?: string | null }> | null;
    };

export type ExpertConnectWatcher = {
  name?: string | null;
  type?: string | null;
  watchType?: string | null;
};

export type ExpertConnectCustomField = {
  definition?: { name?: string | null } | null;
  value?: unknown;
};

export type ExpertConnectMachineDetail = {
  date?: string | null;
  data?: string | null;
  machineHours?: number | string | null;
};

export type ExpertConnectMachine = {
  serialNumber?: string | null;
  productNote?: string | null;
  details?: ExpertConnectMachineDetail[] | null;
};

export type ExpertConnectTicketDetails = {
  id?: string | null;
  ticketId?: string | null;
  number?: string | null;
  title?: string | null;
  url?: string | null;

  status?: string | { name?: string | null; code?: number | null } | null;
  priority?: string | { name?: string | null; code?: number | null } | null;

  createdDate?: string | null;
  updatedDate?: string | null;
  closedDate?: string | null;

  customer?:
    | {
        name?: string | null;
        phone?: string | null;
        email?: string | null;
        organization?: string | null;
        account?: string | null;
        externalId?: string | null;
        segments?: Array<string | { name?: string | null }> | null;
      }
    | null;

  advisor?:
    | {
        name?: string | null;
        email?: string | null;
        racfid?: string | null;
        team?: string | null;
        division?: string | null;
        template?: string | null;
      }
    | null;

  product?:
    | {
        name?: string | null;
        serialNumber?: string | null;
        machineHours?: number | string | null;
      }
    | null;

  source?: string | null;
  support?: string | null;
  timeToFirstResponse?: string | number | null;

  tags?: ExpertConnectTag[] | null;
  machines?: ExpertConnectMachine[] | null;

  description?: string | null;
  resolution?: string | null;
  misc?: unknown;

  watchers?: ExpertConnectWatcher[] | null;
  fields?: ExpertConnectCustomField[] | null;

  webhooks?: unknown;
} & Record<string, unknown>;

export async function fetchTicketDetails(
  ticketId: string,
  options?: { signal?: AbortSignal },
): Promise<ExpertConnectTicketDetails> {
  const resp = await fetch(`/api/tickets/${encodeURIComponent(ticketId)}`, {
    method: "GET",
    cache: "no-store",
    signal: options?.signal,
  });

  if (!resp.ok) {
    const maybeJson = await resp.json().catch(() => null);
    const message =
      (maybeJson && typeof maybeJson === "object" && "message" in maybeJson
        ? String((maybeJson as any).message)
        : null) ?? "Falha ao buscar detalhes do ticket";
    const error: TicketDetailsApiError = {
      message,
      code:
        (maybeJson && typeof maybeJson === "object" && "code" in maybeJson
          ? String((maybeJson as any).code)
          : "unknown") ?? "unknown",
      details:
        maybeJson && typeof maybeJson === "object" && "details" in maybeJson
          ? (maybeJson as any).details
          : undefined,
    };
    throw Object.assign(new Error(error.message), { status: resp.status, error });
  }

  return (await resp.json()) as ExpertConnectTicketDetails;
}




================================================
FILE: src/lib/ticketDetailsViewModel.ts
================================================
import {
  ExpertConnectCustomField,
  ExpertConnectMachine,
  ExpertConnectTag,
  ExpertConnectTicketDetails,
  ExpertConnectWatcher,
} from "@/lib/ticketDetails";
import { formatDateTimePtBR, safeText, stringifyUnknown } from "@/lib/format";

const asNonEmptyString = (value: unknown): string | null => {
  if (typeof value !== "string") return null;
  const trimmed = value.trim();
  return trimmed.length ? trimmed : null;
};

const pickString = (obj: Record<string, unknown>, keys: string[]) => {
  for (const key of keys) {
    const found = asNonEmptyString(obj[key]);
    if (found) return found;
  }
  return null;
};

const pickDateString = (obj: Record<string, unknown>, keys: string[]) =>
  pickString(obj, keys);

const pickNested = (obj: Record<string, unknown>, keys: string[]) => {
  for (const key of keys) {
    const val = obj[key];
    if (val && typeof val === "object") return val as Record<string, unknown>;
  }
  return null;
};

const normalizeStatusOrPriority = (
  value:
    | string
    | { name?: string | null; code?: number | null }
    | null
    | undefined,
) => {
  if (!value) return null;
  if (typeof value === "string") return asNonEmptyString(value);
  return asNonEmptyString(value.name) ?? (value.code !== null && value.code !== undefined ? String(value.code) : null);
};

const normalizeSegments = (segments: unknown): string[] => {
  if (!segments) return [];
  if (Array.isArray(segments)) {
    return segments
      .map((item) => {
        if (typeof item === "string") return item.trim();
        if (item && typeof item === "object") {
          const name = asNonEmptyString((item as any).name);
          return name ?? "";
        }
        return "";
      })
      .map((s) => s.trim())
      .filter(Boolean);
  }
  return [];
};

const normalizeTags = (tags: ExpertConnectTag[] | null | undefined) => {
  if (!tags || !Array.isArray(tags)) return [];
  return tags
    .map((t) => {
      if (typeof t === "string") return { name: t.trim(), subTags: [] as string[] };
      const name = (t?.name ?? "")?.toString().trim();
      const subTagsRaw = t?.subTags ?? [];
      const subTags = Array.isArray(subTagsRaw)
        ? subTagsRaw
            .map((st) => (typeof st === "string" ? st : (st as any)?.name))
            .map((v) => (typeof v === "string" ? v.trim() : ""))
            .filter(Boolean)
        : [];
      return { name, subTags };
    })
    .filter((t) => t.name.length);
};

const normalizeMachines = (machines: ExpertConnectMachine[] | null | undefined) => {
  if (!machines || !Array.isArray(machines)) return [];
  return machines.map((m) => ({
    serialNumber: safeText(m.serialNumber, "Sem serial"),
    productNote: safeText(m.productNote, "N/A"),
    details: (m.details ?? [])
      ?.filter(Boolean)
      .map((d) => ({
        date: safeText(d.date ?? d.data, "N/A"),
        machineHours: safeText(d.machineHours as any, "N/A"),
      })) ?? [],
  }));
};

const normalizeWatchers = (watchers: ExpertConnectWatcher[] | null | undefined) => {
  if (!watchers || !Array.isArray(watchers)) return [];
  return watchers.map((w) => ({
    name: safeText(w.name, "N/A"),
    type: safeText(w.type, "N/A"),
    watchType: safeText(w.watchType, "N/A"),
  }));
};

const normalizeFields = (fields: ExpertConnectCustomField[] | null | undefined) => {
  if (!fields || !Array.isArray(fields)) return [];
  return fields
    .map((f) => ({
      name: safeText(f.definition?.name, "Campo"),
      value: stringifyUnknown(f.value, "N/A"),
    }))
    .filter((item) => item.name !== "Campo" || item.value !== "N/A");
};

export type TicketDetailsViewModel = {
  header: {
    number: string;
    title: string;
    status: string;
    priority: string;
    url: string | null;
  };
  contact: {
    name: string;
    phone: string;
    email: string;
    organization: string;
    account: string;
    externalId: string;
    segments: string[];
  };
  advisor: {
    name: string;
    email: string;
    racfid: string;
    team: string;
    division: string;
    template: string;
  };
  meta: {
    createdAt: string;
    updatedAt: string;
    closedAt: string;
    product: string;
    serialNumber: string;
    machineHours: string;
    status: string;
    source: string;
    support: string;
    timeToFirstResponse: string;
  };
  tags: { name: string; subTags: string[] }[];
  machines: ReturnType<typeof normalizeMachines>;
  description: {
    description: string;
    resolution: string;
    misc: string;
  };
  watchers: ReturnType<typeof normalizeWatchers>;
  customFields: ReturnType<typeof normalizeFields>;
};

export const buildTicketDetailsViewModel = (
  ticket: ExpertConnectTicketDetails,
): TicketDetailsViewModel => {
  const root = ticket as Record<string, unknown>;
  const customer =
    (ticket.customer as any) ??
    pickNested(root, ["customer", "contact", "requestor", "requester"]) ??
    {};
  const advisor =
    (ticket.advisor as any) ??
    pickNested(root, ["advisor", "consultant", "assignee", "owner"]) ??
    {};
  const product =
    (ticket.product as any) ??
    pickNested(root, ["product", "machine", "asset"]) ??
    {};

  const number =
    asNonEmptyString(ticket.number) ??
    pickString(root, ["ticketNumber", "number", "id"]) ??
    "N/A";
  const title =
    asNonEmptyString(ticket.title) ??
    pickString(root, ["subject", "title", "name"]) ??
    "N/A";

  const status =
    normalizeStatusOrPriority(ticket.status) ??
    pickString(root, ["statusName", "status"]) ??
    "N/A";

  const priority =
    normalizeStatusOrPriority(ticket.priority) ??
    pickString(root, ["priorityName", "priority"]) ??
    "N/A";

  const url =
    asNonEmptyString(ticket.url) ??
    pickString(root, ["url", "webUrl", "link"]) ??
    null;

  const createdIso =
    ticket.createdDate ??
    pickDateString(root, ["createdDate", "createdAt", "created_date", "created"]) ??
    null;
  const updatedIso =
    ticket.updatedDate ??
    pickDateString(root, ["updatedDate", "updatedAt", "updated_date", "updated"]) ??
    null;
  const closedIso =
    ticket.closedDate ??
    pickDateString(root, ["closedDate", "closedAt", "closed_date", "closed"]) ??
    null;

  const customerName =
    pickString(customer, ["name", "fullName", "customerName"]) ??
    pickString(root, ["customerName"]) ??
    "N/A";
  const customerPhone =
    pickString(customer, ["phone", "phoneNumber", "mobile"]) ??
    pickString(root, ["customerPhone", "phone"]) ??
    "N/A";
  const customerEmail =
    pickString(customer, ["email", "emailAddress"]) ??
    pickString(root, ["customerEmail", "email"]) ??
    "N/A";
  const organization =
    pickString(customer, ["organization", "company", "orgName"]) ??
    pickString(root, ["organization", "customerOrganization"]) ??
    "N/A";
  const account =
    pickString(customer, ["account", "accountName"]) ??
    pickString(root, ["account", "customerAccount"]) ??
    "N/A";
  const externalId =
    pickString(customer, ["externalId", "externalID", "external_id", "id"]) ??
    pickString(root, ["externalId", "external_id"]) ??
    "N/A";
  const segments = normalizeSegments(
    (customer as any).segments ?? (root as any).segments,
  );

  const advisorName =
    pickString(advisor, ["name", "fullName", "advisorName"]) ??
    pickString(root, ["advisorName"]) ??
    "N/A";
  const advisorEmail =
    pickString(advisor, ["email", "emailAddress"]) ??
    pickString(root, ["advisorEmail"]) ??
    "N/A";
  const racfid =
    pickString(advisor, ["racfid", "racfId", "racf", "userId"]) ??
    pickString(root, ["advisorRacfid", "racfid"]) ??
    "N/A";
  const team =
    pickString(advisor, ["team", "teamName"]) ??
    pickString(root, ["team", "teamName"]) ??
    "N/A";
  const division =
    pickString(advisor, ["division", "divisionName"]) ??
    pickString(root, ["division", "divisionName"]) ??
    "N/A";
  const template =
    pickString(advisor, ["template", "templateName"]) ??
    pickString(root, ["template", "templateName"]) ??
    "N/A";

  const productName =
    pickString(product, ["name", "product", "model", "modelName"]) ??
    pickString(root, ["product", "productName", "modelName"]) ??
    "N/A";
  const serialNumber =
    asNonEmptyString((product as any).serialNumber) ??
    pickString(root, ["serialNumber", "serial_number", "machineSerialNumber"]) ??
    "N/A";
  const machineHours = safeText(
    (product as any).machineHours ?? (root as any).machineHours,
    "N/A",
  );

  const source = safeText((root as any).source, "N/A");
  const support = safeText((root as any).support, "N/A");
  const timeToFirstResponse = safeText((root as any).timeToFirstResponse, "N/A");

  const description = safeText((root as any).description, "N/A");
  const resolution = safeText((root as any).resolution, "N/A");
  const miscValue = (root as any).misc ?? null;
  const misc = stringifyUnknown(miscValue, "N/A");

  return {
    header: {
      number: safeText(number, "N/A"),
      title: safeText(title, "N/A"),
      status: safeText(status, "N/A"),
      priority: safeText(priority, "N/A"),
      url,
    },
    contact: {
      name: safeText(customerName, "N/A"),
      phone: safeText(customerPhone, "N/A"),
      email: safeText(customerEmail, "N/A"),
      organization: safeText(organization, "N/A"),
      account: safeText(account, "N/A"),
      externalId: safeText(externalId, "N/A"),
      segments,
    },
    advisor: {
      name: safeText(advisorName, "N/A"),
      email: safeText(advisorEmail, "N/A"),
      racfid: safeText(racfid, "N/A"),
      team: safeText(team, "N/A"),
      division: safeText(division, "N/A"),
      template: safeText(template, "N/A"),
    },
    meta: {
      createdAt: formatDateTimePtBR(createdIso, "N/A"),
      updatedAt: formatDateTimePtBR(updatedIso, "N/A"),
      closedAt: closedIso ? formatDateTimePtBR(closedIso, "N/A") : "—",
      product: safeText(productName, "N/A"),
      serialNumber: safeText(serialNumber, "N/A"),
      machineHours,
      status: safeText(status, "N/A"),
      source,
      support,
      timeToFirstResponse,
    },
    tags: normalizeTags(ticket.tags),
    machines: normalizeMachines(ticket.machines),
    description: {
      description,
      resolution: resolution === "N/A" ? "—" : resolution,
      misc: misc === "N/A" ? "—" : misc,
    },
    watchers: normalizeWatchers(ticket.watchers),
    customFields: normalizeFields(ticket.fields),
  };
};




================================================
FILE: src/lib/ticketFilters.ts
================================================
import { SortOrder } from "./filters";
import { TicketStatus } from "./domain";

export type TicketFiltersState = {
  search: string;
  status: TicketStatus | "";
  sort: SortOrder;
  groupByEmpresa: boolean;
  groupByChassi: boolean;
  consultor: string;
  cliente: string;
  equipe: string;
};

export const INITIAL_TICKET_FILTERS: TicketFiltersState = {
  search: "",
  status: "",
  sort: "recentes",
  groupByEmpresa: false,
  groupByChassi: false,
  consultor: "",
  cliente: "",
  equipe: "",
};



================================================
FILE: src/lib/supabase/client.ts
================================================
export { createSupabaseBrowserClient } from "../supabaseClient";


================================================
FILE: src/lib/supabase/server.ts
================================================
import { createServerClient } from "@supabase/ssr";
import type { SupabaseClient } from "@supabase/supabase-js";
import { cookies } from "next/headers";

export async function createSupabaseServerClient(): Promise<SupabaseClient> {
  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
  const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;

  if (!supabaseUrl || !supabaseAnonKey) {
    throw new Error(
      "Variáveis NEXT_PUBLIC_SUPABASE_URL e NEXT_PUBLIC_SUPABASE_ANON_KEY são obrigatórias."
    );
  }

  const cookieStore = await cookies();

  return createServerClient(supabaseUrl, supabaseAnonKey, {
    cookies: {
      get(name) {
        return cookieStore.get(name)?.value;
      },
      set(name, value, options) {
        try {
          cookieStore.set({ name, value, ...options });
        } catch {
          // cookies podem ser somente-leitura em alguns contextos (ex.: RSC)
        }
      },
      remove(name, options) {
        try {
          cookieStore.set({
            name,
            value: "",
            ...options,
            maxAge: 0,
          });
        } catch {
          // ignora se cookies forem somente-leitura
        }
      },
    },
  });
}



================================================
FILE: src/types/leaflet-extensions.d.ts
================================================
declare module "leaflet/dist/leaflet-src.js";
declare module "leaflet-routing-machine/dist/leaflet-routing-machine.js";
declare module "leaflet.markercluster/dist/leaflet.markercluster-src.js";


